<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>index</title>
    <url>/POST/index.html</url>
    <content><![CDATA[<p>待整理的文章</p>
]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/index.html</url>
    <content><![CDATA[<h1 id="🎯️-Goals"><a class="header-anchor" href="#🎯️-Goals"></a>🎯️ Goals</h1>
<p>👉️ 他山之石，可以攻玉。<br>
学习借鉴其他人或者公司的做法，体会best/bad practicel。</p>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/index.html</url>
    <content><![CDATA[<h1 id="哈哈哈"><a class="header-anchor" href="#哈哈哈"></a>哈哈哈</h1>
<p>👉️ 日拱一卒，功不唐捐。</p>
<p>📇 体系化的知识，需要一步一个脚印地输入，</p>
<p>👣 也需要循序渐进地消化。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>emoji大全</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/emoji%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<h1 id="People"><a class="header-anchor" href="#People"></a>People</h1>
<table>
<thead>
<tr>
<th>😄 <code>:smile:</code></th>
<th>😆 <code>:laughing:</code></th>
<th>😫 <code>:tired_face:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>😊 <code>:blush:</code></td>
<td>😃 <code>:smiley:</code></td>
<td>☺️ <code>:relaxed:</code></td>
</tr>
<tr>
<td>😏 <code>:smirk:</code></td>
<td>😍 <code>:heart_eyes:</code></td>
<td>😘 <code>:kissing_heart:</code></td>
</tr>
<tr>
<td>😚 <code>:kissing_closed_eyes:</code></td>
<td>😳 <code>:flushed:</code></td>
<td>😌 <code>:relieved:</code></td>
</tr>
<tr>
<td>😆 <code>:satisfied:</code></td>
<td>😁 <code>:grin:</code></td>
<td>😉 <code>:wink:</code></td>
</tr>
<tr>
<td>😜 <code>:stuck_out_tongue_winking_eye:</code></td>
<td>😝 <code>:stuck_out_tongue_closed_eyes:</code></td>
<td>😀 <code>:grinning:</code></td>
</tr>
<tr>
<td>😗 <code>:kissing:</code></td>
<td>😙 <code>:kissing_smiling_eyes:</code></td>
<td>😛 <code>:stuck_out_tongue:</code></td>
</tr>
<tr>
<td>😴 <code>:sleeping:</code></td>
<td>😟 <code>:worried:</code></td>
<td>😦 <code>:frowning:</code></td>
</tr>
<tr>
<td>😧 <code>:anguished:</code></td>
<td>😮 <code>:open_mouth:</code></td>
<td>😬 <code>:grimacing:</code></td>
</tr>
<tr>
<td>😕 <code>:confused:</code></td>
<td>😯 <code>:hushed:</code></td>
<td>😑 <code>:expressionless:</code></td>
</tr>
<tr>
<td>😒 <code>:unamused:</code></td>
<td>😅 <code>:sweat_smile:</code></td>
<td>😓 <code>:sweat:</code></td>
</tr>
<tr>
<td>😥 <code>:disappointed_relieved:</code></td>
<td>😩 <code>:weary:</code></td>
<td>😔 <code>:pensive:</code></td>
</tr>
<tr>
<td>😞 <code>:disappointed:</code></td>
<td>😖 <code>:confounded:</code></td>
<td>😨 <code>:fearful:</code></td>
</tr>
<tr>
<td>😰 <code>:cold_sweat:</code></td>
<td>😣 <code>:persevere:</code></td>
<td>😢 <code>:cry:</code></td>
</tr>
<tr>
<td>😭 <code>:sob:</code></td>
<td>😂 <code>:joy:</code></td>
<td>😲 <code>:astonished:</code></td>
</tr>
<tr>
<td>😱 <code>:scream:</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>😠 <code>:angry:</code></td>
<td>😡 <code>:rage:</code></td>
<td>😤 <code>:triumph:</code></td>
</tr>
<tr>
<td>😪 <code>:sleepy:</code></td>
<td>😋 <code>:yum:</code></td>
<td>😷 <code>:mask:</code></td>
</tr>
<tr>
<td>😎 <code>:sunglasses:</code></td>
<td>😵 <code>:dizzy_face:</code></td>
<td>👿 <code>:imp:</code></td>
</tr>
<tr>
<td>😈 <code>:smiling_imp:</code></td>
<td>😐 <code>:neutral_face:</code></td>
<td>😶 <code>:no_mouth:</code></td>
</tr>
<tr>
<td>😇 <code>:innocent:</code></td>
<td>👽 <code>:alien:</code></td>
<td>💛 <code>:yellow_heart:</code></td>
</tr>
<tr>
<td>💙 <code>:blue_heart:</code></td>
<td>💜 <code>:purple_heart:</code></td>
<td>❤️ <code>:heart:</code></td>
</tr>
<tr>
<td>💚 <code>:green_heart:</code></td>
<td>💔 <code>:broken_heart:</code></td>
<td>💓 <code>:heartbeat:</code></td>
</tr>
<tr>
<td>💗 <code>:heartpulse:</code></td>
<td>💕 <code>:two_hearts:</code></td>
<td>💞 <code>:revolving_hearts:</code></td>
</tr>
<tr>
<td>💘 <code>:cupid:</code></td>
<td>💖 <code>:sparkling_heart:</code></td>
<td>✨ <code>:sparkles:</code></td>
</tr>
<tr>
<td>⭐️ <code>:star:</code></td>
<td>🌟 <code>:star2:</code></td>
<td>💫 <code>:dizzy:</code></td>
</tr>
<tr>
<td>💥 <code>:boom:</code></td>
<td>💥 <code>:collision:</code></td>
<td>💢 <code>:anger:</code></td>
</tr>
<tr>
<td>❗️ <code>:exclamation:</code></td>
<td>❓ <code>:question:</code></td>
<td>❕ <code>:grey_exclamation:</code></td>
</tr>
<tr>
<td>❔ <code>:grey_question:</code></td>
<td>💤 <code>:zzz:</code></td>
<td>💨 <code>:dash:</code></td>
</tr>
<tr>
<td>💦 <code>:sweat_drops:</code></td>
<td>🎶 <code>:notes:</code></td>
<td>🎵 <code>:musical_note:</code></td>
</tr>
<tr>
<td>🔥 <code>:fire:</code></td>
<td>💩 <code>:hankey:</code></td>
<td>💩 <code>:poop:</code></td>
</tr>
<tr>
<td>💩 <code>:shit:</code></td>
<td>👍 <code>:+1:</code></td>
<td>👍 <code>:thumbsup:</code></td>
</tr>
<tr>
<td>👎 <code>:-1:</code></td>
<td>👎 <code>:thumbsdown:</code></td>
<td>👌 <code>:ok_hand:</code></td>
</tr>
<tr>
<td>👊 <code>:punch:</code></td>
<td>👊 <code>:facepunch:</code></td>
<td>✊ <code>:fist:</code></td>
</tr>
<tr>
<td>✌️ <code>:v:</code></td>
<td>👋 <code>:wave:</code></td>
<td>✋ <code>:hand:</code></td>
</tr>
<tr>
<td>✋ <code>:raised_hand:</code></td>
<td>👐 <code>:open_hands:</code></td>
<td>☝️ <code>:point_up:</code></td>
</tr>
<tr>
<td>👇 <code>:point_down:</code></td>
<td>👈 <code>:point_left:</code></td>
<td>👉 <code>:point_right:</code></td>
</tr>
<tr>
<td>🙌 <code>:raised_hands:</code></td>
<td>🙏 <code>:pray:</code></td>
<td>👆 <code>:point_up_2:</code></td>
</tr>
<tr>
<td>👏 <code>:clap:</code></td>
<td>💪 <code>:muscle:</code></td>
<td>🤘 <code>:metal:</code></td>
</tr>
<tr>
<td>🖕 <code>:fu:</code></td>
<td>🚶 <code>:walking:</code></td>
<td>🏃 <code>:runner:</code></td>
</tr>
<tr>
<td>🏃 <code>:running:</code></td>
<td>👫 <code>:couple:</code></td>
<td>👪 <code>:family:</code></td>
</tr>
<tr>
<td>👬 <code>:two_men_holding_hands:</code></td>
<td>👭 <code>:two_women_holding_hands:</code></td>
<td>💃 <code>:dancer:</code></td>
</tr>
<tr>
<td>👯 <code>:dancers:</code></td>
<td>🙆 <code>:ok_woman:</code></td>
<td>🙅 <code>:no_good:</code></td>
</tr>
<tr>
<td>💁 <code>:information_desk_person:</code></td>
<td>🙋 <code>:raising_hand:</code></td>
<td>👰 <code>:bride_with_veil:</code></td>
</tr>
<tr>
<td>🙎 <code>:person_with_pouting_face:</code></td>
<td>🙍 <code>:person_frowning:</code></td>
<td>🙇 <code>:bow:</code></td>
</tr>
<tr>
<td>💏 <code>:couplekiss:</code></td>
<td>💑 <code>:couple_with_heart:</code></td>
<td>💆 <code>:massage:</code></td>
</tr>
<tr>
<td>💇 <code>:haircut:</code></td>
<td>💅 <code>:nail_care:</code></td>
<td>👦 <code>:boy:</code></td>
</tr>
<tr>
<td>👧 <code>:girl:</code></td>
<td>👩 <code>:woman:</code></td>
<td>👨 <code>:man:</code></td>
</tr>
<tr>
<td>👶 <code>:baby:</code></td>
<td>👵 <code>:older_woman:</code></td>
<td>👴 <code>:older_man:</code></td>
</tr>
<tr>
<td>👱 <code>:person_with_blond_hair:</code></td>
<td>👲 <code>:man_with_gua_pi_mao:</code></td>
<td>👳 <code>:man_with_turban:</code></td>
</tr>
<tr>
<td>👷 <code>:construction_worker:</code></td>
<td>👮 <code>:cop:</code></td>
<td>👼 <code>:angel:</code></td>
</tr>
<tr>
<td>👸 <code>:princess:</code></td>
<td>😺 <code>:smiley_cat:</code></td>
<td>😸 <code>:smile_cat:</code></td>
</tr>
<tr>
<td>😻 <code>:heart_eyes_cat:</code></td>
<td>😽 <code>:kissing_cat:</code></td>
<td>😼 <code>:smirk_cat:</code></td>
</tr>
<tr>
<td>🙀 <code>:scream_cat:</code></td>
<td>😿 <code>:crying_cat_face:</code></td>
<td>😹 <code>:joy_cat:</code></td>
</tr>
<tr>
<td>😾 <code>:pouting_cat:</code></td>
<td>👹 <code>:japanese_ogre:</code></td>
<td>👺 <code>:japanese_goblin:</code></td>
</tr>
<tr>
<td>🙈 <code>:see_no_evil:</code></td>
<td>🙉 <code>:hear_no_evil:</code></td>
<td>🙊 <code>:speak_no_evil:</code></td>
</tr>
<tr>
<td>💂 <code>:guardsman:</code></td>
<td>💀 <code>:skull:</code></td>
<td>🐾 <code>:feet:</code></td>
</tr>
<tr>
<td>👄 <code>:lips:</code></td>
<td>💋 <code>:kiss:</code></td>
<td>💧 <code>:droplet:</code></td>
</tr>
<tr>
<td>👂 <code>:ear:</code></td>
<td>👀 <code>:eyes:</code></td>
<td>👃 <code>:nose:</code></td>
</tr>
<tr>
<td>👅 <code>:tongue:</code></td>
<td>💌 <code>:love_letter:</code></td>
<td>👤 <code>:bust_in_silhouette:</code></td>
</tr>
<tr>
<td>👥 <code>:busts_in_silhouette:</code></td>
<td>💬 <code>:speech_balloon:</code></td>
<td>💭 <code>:thought_balloon:</code></td>
</tr>
</tbody>
</table>
<h1 id="Nature"><a class="header-anchor" href="#Nature"></a>Nature</h1>
<table>
<thead>
<tr>
<th>☀️ <code>:sunny:</code></th>
<th>☔️ <code>:umbrella:</code></th>
<th>☁️ <code>:cloud:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>❄️ <code>:snowflake:</code></td>
<td>⛄️ <code>:snowman:</code></td>
<td>⚡️ <code>:zap:</code></td>
</tr>
<tr>
<td>🌀 <code>:cyclone:</code></td>
<td>🌁 <code>:foggy:</code></td>
<td>🌊 <code>:ocean:</code></td>
</tr>
<tr>
<td>🐱 <code>:cat:</code></td>
<td>🐶 <code>:dog:</code></td>
<td>🐭 <code>:mouse:</code></td>
</tr>
<tr>
<td>🐹 <code>:hamster:</code></td>
<td>🐰 <code>:rabbit:</code></td>
<td>🐺 <code>:wolf:</code></td>
</tr>
<tr>
<td>🐸 <code>:frog:</code></td>
<td>🐯 <code>:tiger:</code></td>
<td>🐨 <code>:koala:</code></td>
</tr>
<tr>
<td>🐻 <code>:bear:</code></td>
<td>🐷 <code>:pig:</code></td>
<td>🐽 <code>:pig_nose:</code></td>
</tr>
<tr>
<td>🐮 <code>:cow:</code></td>
<td>🐗 <code>:boar:</code></td>
<td>🐵 <code>:monkey_face:</code></td>
</tr>
<tr>
<td>🐒 <code>:monkey:</code></td>
<td>🐴 <code>:horse:</code></td>
<td>🐎 <code>:racehorse:</code></td>
</tr>
<tr>
<td>🐫 <code>:camel:</code></td>
<td>🐑 <code>:sheep:</code></td>
<td>🐘 <code>:elephant:</code></td>
</tr>
<tr>
<td>🐼 <code>:panda_face:</code></td>
<td>🐍 <code>:snake:</code></td>
<td>🐦 <code>:bird:</code></td>
</tr>
<tr>
<td>🐤 <code>:baby_chick:</code></td>
<td>🐥 <code>:hatched_chick:</code></td>
<td>🐣 <code>:hatching_chick:</code></td>
</tr>
<tr>
<td>🐔 <code>:chicken:</code></td>
<td>🐧 <code>:penguin:</code></td>
<td>🐢 <code>:turtle:</code></td>
</tr>
<tr>
<td>🐛 <code>:bug:</code></td>
<td>🐝 <code>:honeybee:</code></td>
<td>🐜 <code>:ant:</code></td>
</tr>
<tr>
<td>🐞 <code>:beetle:</code></td>
<td>🐌 <code>:snail:</code></td>
<td>🐙 <code>:octopus:</code></td>
</tr>
<tr>
<td>🐠 <code>:tropical_fish:</code></td>
<td>🐟 <code>:fish:</code></td>
<td>🐳 <code>:whale:</code></td>
</tr>
<tr>
<td>🐋 <code>:whale2:</code></td>
<td>🐬 <code>:dolphin:</code></td>
<td>🐄 <code>:cow2:</code></td>
</tr>
<tr>
<td>🐏 <code>:ram:</code></td>
<td>🐀 <code>:rat:</code></td>
<td>🐃 <code>:water_buffalo:</code></td>
</tr>
<tr>
<td>🐅 <code>:tiger2:</code></td>
<td>🐇 <code>:rabbit2:</code></td>
<td>🐉 <code>:dragon:</code></td>
</tr>
<tr>
<td>🐐 <code>:goat:</code></td>
<td>🐓 <code>:rooster:</code></td>
<td>🐕 <code>:dog2:</code></td>
</tr>
<tr>
<td>🐖 <code>:pig2:</code></td>
<td>🐁 <code>:mouse2:</code></td>
<td>🐂 <code>:ox:</code></td>
</tr>
<tr>
<td>🐲 <code>:dragon_face:</code></td>
<td>🐡 <code>:blowfish:</code></td>
<td>🐊 <code>:crocodile:</code></td>
</tr>
<tr>
<td>🐪 <code>:dromedary_camel:</code></td>
<td>🐆 <code>:leopard:</code></td>
<td>🐈 <code>:cat2:</code></td>
</tr>
<tr>
<td>🐩 <code>:poodle:</code></td>
<td>🐾 <code>:paw_prints:</code></td>
<td>💐 <code>:bouquet:</code></td>
</tr>
<tr>
<td>🌸 <code>:cherry_blossom:</code></td>
<td>🌷 <code>:tulip:</code></td>
<td>🍀 <code>:four_leaf_clover:</code></td>
</tr>
<tr>
<td>🌹 <code>:rose:</code></td>
<td>🌻 <code>:sunflower:</code></td>
<td>🌺 <code>:hibiscus:</code></td>
</tr>
<tr>
<td>🍁 <code>:maple_leaf:</code></td>
<td>🍃 <code>:leaves:</code></td>
<td>🍂 <code>:fallen_leaf:</code></td>
</tr>
<tr>
<td>🌿 <code>:herb:</code></td>
<td>🍄 <code>:mushroom:</code></td>
<td>🌵 <code>:cactus:</code></td>
</tr>
<tr>
<td>🌴 <code>:palm_tree:</code></td>
<td>🌲 <code>:evergreen_tree:</code></td>
<td>🌳 <code>:deciduous_tree:</code></td>
</tr>
<tr>
<td>🌰 <code>:chestnut:</code></td>
<td>🌱 <code>:seedling:</code></td>
<td>🌼 <code>:blossom:</code></td>
</tr>
<tr>
<td>🌾 <code>:ear_of_rice:</code></td>
<td>🐚 <code>:shell:</code></td>
<td>🌐 <code>:globe_with_meridians:</code></td>
</tr>
<tr>
<td>🌞 <code>:sun_with_face:</code></td>
<td>🌝 <code>:full_moon_with_face:</code></td>
<td>🌚 <code>:new_moon_with_face:</code></td>
</tr>
<tr>
<td>🌑 <code>:new_moon:</code></td>
<td>🌒 <code>:waxing_crescent_moon:</code></td>
<td>🌓 <code>:first_quarter_moon:</code></td>
</tr>
<tr>
<td>🌔 <code>:waxing_gibbous_moon:</code></td>
<td>🌕 <code>:full_moon:</code></td>
<td>🌖 <code>:waning_gibbous_moon:</code></td>
</tr>
<tr>
<td>🌗 <code>:last_quarter_moon:</code></td>
<td>🌘 <code>:waning_crescent_moon:</code></td>
<td>🌜 <code>:last_quarter_moon_with_face:</code></td>
</tr>
<tr>
<td>🌛 <code>:first_quarter_moon_with_face:</code></td>
<td>🌔 <code>:moon:</code></td>
<td>🌍 <code>:earth_africa:</code></td>
</tr>
<tr>
<td>🌎 <code>:earth_americas:</code></td>
<td>🌏 <code>:earth_asia:</code></td>
<td>🌋 <code>:volcano:</code></td>
</tr>
<tr>
<td>🌌 <code>:milky_way:</code></td>
<td>⛅️ <code>:partly_sunny:</code></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="Object"><a class="header-anchor" href="#Object"></a>Object</h1>
<table>
<thead>
<tr>
<th>🎍 <code>:bamboo:</code></th>
<th>💝 <code>:gift_heart:</code></th>
<th>🎎 <code>:dolls:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>🎒 <code>:school_satchel:</code></td>
<td>🎓 <code>:mortar_board:</code></td>
<td>🎏 <code>:flags:</code></td>
</tr>
<tr>
<td>🎆 <code>:fireworks:</code></td>
<td>🎇 <code>:sparkler:</code></td>
<td>🎐 <code>:wind_chime:</code></td>
</tr>
<tr>
<td>🎑 <code>:rice_scene:</code></td>
<td>🎃 <code>:jack_o_lantern:</code></td>
<td>👻 <code>:ghost:</code></td>
</tr>
<tr>
<td>🎅 <code>:santa:</code></td>
<td>🎄 <code>:christmas_tree:</code></td>
<td>🎁 <code>:gift:</code></td>
</tr>
<tr>
<td>🔔 <code>:bell:</code></td>
<td>🔕 <code>:no_bell:</code></td>
<td>🎋 <code>:tanabata_tree:</code></td>
</tr>
<tr>
<td>🎉 <code>:tada:</code></td>
<td>🎊 <code>:confetti_ball:</code></td>
<td>🎈 <code>:balloon:</code></td>
</tr>
<tr>
<td>🔮 <code>:crystal_ball:</code></td>
<td>💿 <code>:cd:</code></td>
<td>📀 <code>:dvd:</code></td>
</tr>
<tr>
<td>💾 <code>:floppy_disk:</code></td>
<td>📷 <code>:camera:</code></td>
<td>📹 <code>:video_camera:</code></td>
</tr>
<tr>
<td>🎥 <code>:movie_camera:</code></td>
<td>💻 <code>:computer:</code></td>
<td>📺 <code>:tv:</code></td>
</tr>
<tr>
<td>📱 <code>:iphone:</code></td>
<td>☎️ <code>:phone:</code></td>
<td>☎️ <code>:telephone:</code></td>
</tr>
<tr>
<td>📞 <code>:telephone_receiver:</code></td>
<td>📟 <code>:pager:</code></td>
<td>📠 <code>:fax:</code></td>
</tr>
<tr>
<td>💽 <code>:minidisc:</code></td>
<td>📼 <code>:vhs:</code></td>
<td>🔉 <code>:sound:</code></td>
</tr>
<tr>
<td>🔈 <code>:speaker:</code></td>
<td>🔇 <code>:mute:</code></td>
<td>📢 <code>:loudspeaker:</code></td>
</tr>
<tr>
<td>📣 <code>:mega:</code></td>
<td>⌛️ <code>:hourglass:</code></td>
<td>⏳ <code>:hourglass_flowing_sand:</code></td>
</tr>
<tr>
<td>⏰ <code>:alarm_clock:</code></td>
<td>⌚️ <code>:watch:</code></td>
<td>📻 <code>:radio:</code></td>
</tr>
<tr>
<td>📡 <code>:satellite:</code></td>
<td>➿ <code>:loop:</code></td>
<td>🔍 <code>:mag:</code></td>
</tr>
<tr>
<td>🔎 <code>:mag_right:</code></td>
<td>🔓 <code>:unlock:</code></td>
<td>🔒 <code>:lock:</code></td>
</tr>
<tr>
<td>🔏 <code>:lock_with_ink_pen:</code></td>
<td>🔐 <code>:closed_lock_with_key:</code></td>
<td>🔑 <code>:key:</code></td>
</tr>
<tr>
<td>💡 <code>:bulb:</code></td>
<td>🔦 <code>:flashlight:</code></td>
<td>🔆 <code>:high_brightness:</code></td>
</tr>
<tr>
<td>🔅 <code>:low_brightness:</code></td>
<td>🔌 <code>:electric_plug:</code></td>
<td>🔋 <code>:battery:</code></td>
</tr>
<tr>
<td>📲 <code>:calling:</code></td>
<td>✉️ <code>:email:</code></td>
<td>📫 <code>:mailbox:</code></td>
</tr>
<tr>
<td>📮 <code>:postbox:</code></td>
<td>🛀 <code>:bath:</code></td>
<td>🛁 <code>:bathtub:</code></td>
</tr>
<tr>
<td>🚿 <code>:shower:</code></td>
<td>🚽 <code>:toilet:</code></td>
<td>🔧 <code>:wrench:</code></td>
</tr>
<tr>
<td>🔩 <code>:nut_and_bolt:</code></td>
<td>🔨 <code>:hammer:</code></td>
<td>💺 <code>:seat:</code></td>
</tr>
<tr>
<td>💰 <code>:moneybag:</code></td>
<td>💴 <code>:yen:</code></td>
<td>💵 <code>:dollar:</code></td>
</tr>
<tr>
<td>💷 <code>:pound:</code></td>
<td>💶 <code>:euro:</code></td>
<td>💳 <code>:credit_card:</code></td>
</tr>
<tr>
<td>💸 <code>:money_with_wings:</code></td>
<td>📧 <code>:e-mail:</code></td>
<td>📥 <code>:inbox_tray:</code></td>
</tr>
<tr>
<td>📤 <code>:outbox_tray:</code></td>
<td>✉️ <code>:envelope:</code></td>
<td>📨 <code>:incoming_envelope:</code></td>
</tr>
<tr>
<td>📯 <code>:postal_horn:</code></td>
<td>📪 <code>:mailbox_closed:</code></td>
<td>📬 <code>:mailbox_with_mail:</code></td>
</tr>
<tr>
<td>📭 <code>:mailbox_with_no_mail:</code></td>
<td>🚪 <code>:door:</code></td>
<td>🚬 <code>:smoking:</code></td>
</tr>
<tr>
<td>💣 <code>:bomb:</code></td>
<td>🔫 <code>:gun:</code></td>
<td>🔪 <code>:hocho:</code></td>
</tr>
<tr>
<td>💊 <code>:pill:</code></td>
<td>💉 <code>:syringe:</code></td>
<td>📄 <code>:page_facing_up:</code></td>
</tr>
<tr>
<td>📃 <code>:page_with_curl:</code></td>
<td>📑 <code>:bookmark_tabs:</code></td>
<td>📊 <code>:bar_chart:</code></td>
</tr>
<tr>
<td>📈 <code>:chart_with_upwards_trend:</code></td>
<td>📉 <code>:chart_with_downwards_trend:</code></td>
<td>📜 <code>:scroll:</code></td>
</tr>
<tr>
<td>📋 <code>:clipboard:</code></td>
<td>📆 <code>:calendar:</code></td>
<td>📅 <code>:date:</code></td>
</tr>
<tr>
<td>📇 <code>:card_index:</code></td>
<td>📁 <code>:file_folder:</code></td>
<td>📂 <code>:open_file_folder:</code></td>
</tr>
<tr>
<td>✂️ <code>:scissors:</code></td>
<td>📌 <code>:pushpin:</code></td>
<td>📎 <code>:paperclip:</code></td>
</tr>
<tr>
<td>✒️ <code>:black_nib:</code></td>
<td>✏️ <code>:pencil2:</code></td>
<td>📏 <code>:straight_ruler:</code></td>
</tr>
<tr>
<td>📐 <code>:triangular_ruler:</code></td>
<td>📕 <code>:closed_book:</code></td>
<td>📗 <code>:green_book:</code></td>
</tr>
<tr>
<td>📘 <code>:blue_book:</code></td>
<td>📙 <code>:orange_book:</code></td>
<td>📓 <code>:notebook:</code></td>
</tr>
<tr>
<td>📔 <code>:notebook_with_decorative_cover:</code></td>
<td>📒 <code>:ledger:</code></td>
<td>📚 <code>:books:</code></td>
</tr>
<tr>
<td>🔖 <code>:bookmark:</code></td>
<td>📛 <code>:name_badge:</code></td>
<td>🔬 <code>:microscope:</code></td>
</tr>
<tr>
<td>🔭 <code>:telescope:</code></td>
<td>📰 <code>:newspaper:</code></td>
<td>🏈 <code>:football:</code></td>
</tr>
<tr>
<td>🏀 <code>:basketball:</code></td>
<td>⚽️ <code>:soccer:</code></td>
<td>⚾️ <code>:baseball:</code></td>
</tr>
<tr>
<td>🎾 <code>:tennis:</code></td>
<td>🎱 <code>:8ball:</code></td>
<td>🏉 <code>:rugby_football:</code></td>
</tr>
<tr>
<td>🎳 <code>:bowling:</code></td>
<td>⛳️ <code>:golf:</code></td>
<td>🚵 <code>:mountain_bicyclist:</code></td>
</tr>
<tr>
<td>🚴 <code>:bicyclist:</code></td>
<td>🏇 <code>:horse_racing:</code></td>
<td>🏂 <code>:snowboarder:</code></td>
</tr>
<tr>
<td>🏊 <code>:swimmer:</code></td>
<td>🏄 <code>:surfer:</code></td>
<td>🎿 <code>:ski:</code></td>
</tr>
<tr>
<td>♠️ <code>:spades:</code></td>
<td>♥️ <code>:hearts:</code></td>
<td>♣️ <code>:clubs:</code></td>
</tr>
<tr>
<td>♦️ <code>:diamonds:</code></td>
<td>💎 <code>:gem:</code></td>
<td>💍 <code>:ring:</code></td>
</tr>
<tr>
<td>🏆 <code>:trophy:</code></td>
<td>🎼 <code>:musical_score:</code></td>
<td>🎹 <code>:musical_keyboard:</code></td>
</tr>
<tr>
<td>🎻 <code>:violin:</code></td>
<td>👾 <code>:space_invader:</code></td>
<td>🎮 <code>:video_game:</code></td>
</tr>
<tr>
<td>🃏 <code>:black_joker:</code></td>
<td>🎴 <code>:flower_playing_cards:</code></td>
<td>🎲 <code>:game_die:</code></td>
</tr>
<tr>
<td>🎯 <code>:dart:</code></td>
<td>🀄️ <code>:mahjong:</code></td>
<td>🎬 <code>:clapper:</code></td>
</tr>
<tr>
<td>📝 <code>:memo:</code></td>
<td>📝 <code>:pencil:</code></td>
<td>📖 <code>:book:</code></td>
</tr>
<tr>
<td>🎨 <code>:art:</code></td>
<td>🎤 <code>:microphone:</code></td>
<td>🎧 <code>:headphones:</code></td>
</tr>
<tr>
<td>🎺 <code>:trumpet:</code></td>
<td>🎷 <code>:saxophone:</code></td>
<td>🎸 <code>:guitar:</code></td>
</tr>
<tr>
<td>👞 <code>:shoe:</code></td>
<td>👡 <code>:sandal:</code></td>
<td>👠 <code>:high_heel:</code></td>
</tr>
<tr>
<td>💄 <code>:lipstick:</code></td>
<td>👢 <code>:boot:</code></td>
<td>👕 <code>:shirt:</code></td>
</tr>
<tr>
<td>👕 <code>:tshirt:</code></td>
<td>👔 <code>:necktie:</code></td>
<td>👚 <code>:womans_clothes:</code></td>
</tr>
<tr>
<td>👗 <code>:dress:</code></td>
<td>🎽 <code>:running_shirt_with_sash:</code></td>
<td>👖 <code>:jeans:</code></td>
</tr>
<tr>
<td>👘 <code>:kimono:</code></td>
<td>👙 <code>:bikini:</code></td>
<td>🎀 <code>:ribbon:</code></td>
</tr>
<tr>
<td>🎩 <code>:tophat:</code></td>
<td>👑 <code>:crown:</code></td>
<td>👒 <code>:womans_hat:</code></td>
</tr>
<tr>
<td>👞 <code>:mans_shoe:</code></td>
<td>🌂 <code>:closed_umbrella:</code></td>
<td>💼 <code>:briefcase:</code></td>
</tr>
<tr>
<td>👜 <code>:handbag:</code></td>
<td>👝 <code>:pouch:</code></td>
<td>👛 <code>:purse:</code></td>
</tr>
<tr>
<td>👓 <code>:eyeglasses:</code></td>
<td>🎣 <code>:fishing_pole_and_fish:</code></td>
<td>☕️ <code>:coffee:</code></td>
</tr>
<tr>
<td>🍵 <code>:tea:</code></td>
<td>🍶 <code>:sake:</code></td>
<td>🍼 <code>:baby_bottle:</code></td>
</tr>
<tr>
<td>🍺 <code>:beer:</code></td>
<td>🍻 <code>:beers:</code></td>
<td>🍸 <code>:cocktail:</code></td>
</tr>
<tr>
<td>🍹 <code>:tropical_drink:</code></td>
<td>🍷 <code>:wine_glass:</code></td>
<td>🍴 <code>:fork_and_knife:</code></td>
</tr>
<tr>
<td>🍕 <code>:pizza:</code></td>
<td>🍔 <code>:hamburger:</code></td>
<td>🍟 <code>:fries:</code></td>
</tr>
<tr>
<td>🍗 <code>:poultry_leg:</code></td>
<td>🍖 <code>:meat_on_bone:</code></td>
<td>🍝 <code>:spaghetti:</code></td>
</tr>
<tr>
<td>🍛 <code>:curry:</code></td>
<td>🍤 <code>:fried_shrimp:</code></td>
<td>🍱 <code>:bento:</code></td>
</tr>
<tr>
<td>🍣 <code>:sushi:</code></td>
<td>🍥 <code>:fish_cake:</code></td>
<td>🍙 <code>:rice_ball:</code></td>
</tr>
<tr>
<td>🍘 <code>:rice_cracker:</code></td>
<td>🍚 <code>:rice:</code></td>
<td>🍜 <code>:ramen:</code></td>
</tr>
<tr>
<td>🍲 <code>:stew:</code></td>
<td>🍢 <code>:oden:</code></td>
<td>🍡 <code>:dango:</code></td>
</tr>
<tr>
<td>🥚 <code>:egg:</code></td>
<td>🍞 <code>:bread:</code></td>
<td>🍩 <code>:doughnut:</code></td>
</tr>
<tr>
<td>🍮 <code>:custard:</code></td>
<td>🍦 <code>:icecream:</code></td>
<td>🍨 <code>:ice_cream:</code></td>
</tr>
<tr>
<td>🍧 <code>:shaved_ice:</code></td>
<td>🎂 <code>:birthday:</code></td>
<td>🍰 <code>:cake:</code></td>
</tr>
<tr>
<td>🍪 <code>:cookie:</code></td>
<td>🍫 <code>:chocolate_bar:</code></td>
<td>🍬 <code>:candy:</code></td>
</tr>
<tr>
<td>🍭 <code>:lollipop:</code></td>
<td>🍯 <code>:honey_pot:</code></td>
<td>🍎 <code>:apple:</code></td>
</tr>
<tr>
<td>🍏 <code>:green_apple:</code></td>
<td>🍊 <code>:tangerine:</code></td>
<td>🍋 <code>:lemon:</code></td>
</tr>
<tr>
<td>🍒 <code>:cherries:</code></td>
<td>🍇 <code>:grapes:</code></td>
<td>🍉 <code>:watermelon:</code></td>
</tr>
<tr>
<td>🍓 <code>:strawberry:</code></td>
<td>🍑 <code>:peach:</code></td>
<td>🍈 <code>:melon:</code></td>
</tr>
<tr>
<td>🍌 <code>:banana:</code></td>
<td>🍐 <code>:pear:</code></td>
<td>🍍 <code>:pineapple:</code></td>
</tr>
<tr>
<td>🍠 <code>:sweet_potato:</code></td>
<td>🍆 <code>:eggplant:</code></td>
<td>🍅 <code>:tomato:</code></td>
</tr>
<tr>
<td>🌽 <code>:corn:</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="Places"><a class="header-anchor" href="#Places"></a>Places</h1>
<table>
<thead>
<tr>
<th>🏠 <code>:house:</code></th>
<th>🏡 <code>:house_with_garden:</code></th>
<th>🏫 <code>:school:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>🏢 <code>:office:</code></td>
<td>🏣 <code>:post_office:</code></td>
<td>🏥 <code>:hospital:</code></td>
</tr>
<tr>
<td>🏦 <code>:bank:</code></td>
<td>🏪 <code>:convenience_store:</code></td>
<td>🏩 <code>:love_hotel:</code></td>
</tr>
<tr>
<td>🏨 <code>:hotel:</code></td>
<td>💒 <code>:wedding:</code></td>
<td>⛪️ <code>:church:</code></td>
</tr>
<tr>
<td>🏬 <code>:department_store:</code></td>
<td>🏤 <code>:european_post_office:</code></td>
<td>🌇 <code>:city_sunrise:</code></td>
</tr>
<tr>
<td>🌆 <code>:city_sunset:</code></td>
<td>🏯 <code>:japanese_castle:</code></td>
<td>🏰 <code>:european_castle:</code></td>
</tr>
<tr>
<td>⛺️ <code>:tent:</code></td>
<td>🏭 <code>:factory:</code></td>
<td>🗼 <code>:tokyo_tower:</code></td>
</tr>
<tr>
<td>🗾 <code>:japan:</code></td>
<td>🗻 <code>:mount_fuji:</code></td>
<td>🌄 <code>:sunrise_over_mountains:</code></td>
</tr>
<tr>
<td>🌅 <code>:sunrise:</code></td>
<td>🌠 <code>:stars:</code></td>
<td>🗽 <code>:statue_of_liberty:</code></td>
</tr>
<tr>
<td>🌉 <code>:bridge_at_night:</code></td>
<td>🎠 <code>:carousel_horse:</code></td>
<td>🌈 <code>:rainbow:</code></td>
</tr>
<tr>
<td>🎡 <code>:ferris_wheel:</code></td>
<td>⛲️ <code>:fountain:</code></td>
<td>🎢 <code>:roller_coaster:</code></td>
</tr>
<tr>
<td>🚢 <code>:ship:</code></td>
<td>🚤 <code>:speedboat:</code></td>
<td>⛵️ <code>:boat:</code></td>
</tr>
<tr>
<td>⛵️ <code>:sailboat:</code></td>
<td>🚣 <code>:rowboat:</code></td>
<td>⚓️ <code>:anchor:</code></td>
</tr>
<tr>
<td>🚀 <code>:rocket:</code></td>
<td>✈️ <code>:airplane:</code></td>
<td>🚁 <code>:helicopter:</code></td>
</tr>
<tr>
<td>🚂 <code>:steam_locomotive:</code></td>
<td>🚊 <code>:tram:</code></td>
<td>🚞 <code>:mountain_railway:</code></td>
</tr>
<tr>
<td>🚲 <code>:bike:</code></td>
<td>🚡 <code>:aerial_tramway:</code></td>
<td>🚟 <code>:suspension_railway:</code></td>
</tr>
<tr>
<td>🚠 <code>:mountain_cableway:</code></td>
<td>🚜 <code>:tractor:</code></td>
<td>🚙 <code>:blue_car:</code></td>
</tr>
<tr>
<td>🚘 <code>:oncoming_automobile:</code></td>
<td>🚗 <code>:car:</code></td>
<td>🚗 <code>:red_car:</code></td>
</tr>
<tr>
<td>🚕 <code>:taxi:</code></td>
<td>🚖 <code>:oncoming_taxi:</code></td>
<td>🚛 <code>:articulated_lorry:</code></td>
</tr>
<tr>
<td>🚌 <code>:bus:</code></td>
<td>🚍 <code>:oncoming_bus:</code></td>
<td>🚨 <code>:rotating_light:</code></td>
</tr>
<tr>
<td>🚓 <code>:police_car:</code></td>
<td>🚔 <code>:oncoming_police_car:</code></td>
<td>🚒 <code>:fire_engine:</code></td>
</tr>
<tr>
<td>🚑 <code>:ambulance:</code></td>
<td>🚐 <code>:minibus:</code></td>
<td>🚚 <code>:truck:</code></td>
</tr>
<tr>
<td>🚋 <code>:train:</code></td>
<td>🚉 <code>:station:</code></td>
<td>🚆 <code>:train2:</code></td>
</tr>
<tr>
<td>🚅 <code>:bullettrain_front:</code></td>
<td>🚄 <code>:bullettrain_side:</code></td>
<td>🚈 <code>:light_rail:</code></td>
</tr>
<tr>
<td>🚝 <code>:monorail:</code></td>
<td>🚃 <code>:railway_car:</code></td>
<td>🚎 <code>:trolleybus:</code></td>
</tr>
<tr>
<td>🎫 <code>:ticket:</code></td>
<td>⛽️ <code>:fuelpump:</code></td>
<td>🚦 <code>:vertical_traffic_light:</code></td>
</tr>
<tr>
<td>🚥 <code>:traffic_light:</code></td>
<td>⚠️ <code>:warning:</code></td>
<td>🚧 <code>:construction:</code></td>
</tr>
<tr>
<td>🔰 <code>:beginner:</code></td>
<td>🏧 <code>:atm:</code></td>
<td>🎰 <code>:slot_machine:</code></td>
</tr>
<tr>
<td>🚏 <code>:busstop:</code></td>
<td>💈 <code>:barber:</code></td>
<td>♨️ <code>:hotsprings:</code></td>
</tr>
<tr>
<td>🏁 <code>:checkered_flag:</code></td>
<td>🎌 <code>:crossed_flags:</code></td>
<td>🏮 <code>:izakaya_lantern:</code></td>
</tr>
<tr>
<td>🗿 <code>:moyai:</code></td>
<td>🎪 <code>:circus_tent:</code></td>
<td>🎭 <code>:performing_arts:</code></td>
</tr>
<tr>
<td>📍 <code>:round_pushpin:</code></td>
<td>🚩 <code>:triangular_flag_on_post:</code></td>
<td>🇯🇵 <code>:jp:</code></td>
</tr>
<tr>
<td>🇰🇷 <code>:kr:</code></td>
<td>🇨🇳 <code>:cn:</code></td>
<td>🇺🇸 <code>:us:</code></td>
</tr>
<tr>
<td>🇫🇷 <code>:fr:</code></td>
<td>🇪🇸 <code>:es:</code></td>
<td>🇮🇹 <code>:it:</code></td>
</tr>
<tr>
<td>🇷🇺 <code>:ru:</code></td>
<td>🇬🇧 <code>:gb:</code></td>
<td>🇬🇧 <code>:uk:</code></td>
</tr>
<tr>
<td>🇩🇪 <code>:de:</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="Symbols"><a class="header-anchor" href="#Symbols"></a>Symbols</h1>
<table>
<thead>
<tr>
<th>1️⃣ <code>:one:</code></th>
<th>2️⃣ <code>:two:</code></th>
<th>3️⃣ <code>:three:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>4️⃣ <code>:four:</code></td>
<td>5️⃣ <code>:five:</code></td>
<td>6️⃣ <code>:six:</code></td>
</tr>
<tr>
<td>7️⃣ <code>:seven:</code></td>
<td>8️⃣ <code>:eight:</code></td>
<td>9️⃣ <code>:nine:</code></td>
</tr>
<tr>
<td>🔟 <code>:keycap_ten:</code></td>
<td>🔢 <code>:1234:</code></td>
<td>0️⃣ <code>:zero:</code></td>
</tr>
<tr>
<td>#️⃣ <code>:hash:</code></td>
<td>🔣 <code>:symbols:</code></td>
<td>◀️ <code>:arrow_backward:</code></td>
</tr>
<tr>
<td>⬇️ <code>:arrow_down:</code></td>
<td>▶️ <code>:arrow_forward:</code></td>
<td>⬅️ <code>:arrow_left:</code></td>
</tr>
<tr>
<td>🔠 <code>:capital_abcd:</code></td>
<td>🔡 <code>:abcd:</code></td>
<td>🔤 <code>:abc:</code></td>
</tr>
<tr>
<td>↙️ <code>:arrow_lower_left:</code></td>
<td>↘️ <code>:arrow_lower_right:</code></td>
<td>➡️ <code>:arrow_right:</code></td>
</tr>
<tr>
<td>⬆️ <code>:arrow_up:</code></td>
<td>↖️ <code>:arrow_upper_left:</code></td>
<td>↗️ <code>:arrow_upper_right:</code></td>
</tr>
<tr>
<td>⏬ <code>:arrow_double_down:</code></td>
<td>⏫ <code>:arrow_double_up:</code></td>
<td>🔽 <code>:arrow_down_small:</code></td>
</tr>
<tr>
<td>⤵️ <code>:arrow_heading_down:</code></td>
<td>⤴️ <code>:arrow_heading_up:</code></td>
<td>↩️<code>:leftwards_arrow_with_hook:</code></td>
</tr>
<tr>
<td>↪️ <code>:arrow_right_hook:</code></td>
<td>↔️ <code>:left_right_arrow:</code></td>
<td>↕️ <code>:arrow_up_down:</code></td>
</tr>
<tr>
<td>🔼 <code>:arrow_up_small:</code></td>
<td>🔃 <code>:arrows_clockwise:</code></td>
<td>🔄 <code>:arrows_counterclockwise:</code></td>
</tr>
<tr>
<td>⏪ <code>:rewind:</code></td>
<td>⏩ <code>:fast_forward:</code></td>
<td>ℹ️ <code>:information_source:</code></td>
</tr>
<tr>
<td>🆗 <code>:ok:</code></td>
<td>🔀 <code>:twisted_rightwards_arrows:</code></td>
<td>🔁 <code>:repeat:</code></td>
</tr>
<tr>
<td>🔂 <code>:repeat_one:</code></td>
<td>🆕 <code>:new:</code></td>
<td>🔝 <code>:top:</code></td>
</tr>
<tr>
<td>🆙 <code>:up:</code></td>
<td>🆒 <code>:cool:</code></td>
<td>🆓 <code>:free:</code></td>
</tr>
<tr>
<td>🆖 <code>:ng:</code></td>
<td>🎦 <code>:cinema:</code></td>
<td>🈁 <code>:koko:</code></td>
</tr>
<tr>
<td>📶 <code>:signal_strength:</code></td>
<td>🈹 <code>:u5272:</code></td>
<td>🈴 <code>:u5408:</code></td>
</tr>
<tr>
<td>🈺 <code>:u55b6:</code></td>
<td>🈯️ <code>:u6307:</code></td>
<td>🈷️ <code>:u6708:</code></td>
</tr>
<tr>
<td>🈶 <code>:u6709:</code></td>
<td>🈵 <code>:u6e80:</code></td>
<td>🈚️ <code>:u7121:</code></td>
</tr>
<tr>
<td>🈸 <code>:u7533:</code></td>
<td>🈳 <code>:u7a7a:</code></td>
<td>🈲 <code>:u7981:</code></td>
</tr>
<tr>
<td>🈂️ <code>:sa:</code></td>
<td>🚻 <code>:restroom:</code></td>
<td>🚹 <code>:mens:</code></td>
</tr>
<tr>
<td>🚺 <code>:womens:</code></td>
<td>🚼 <code>:baby_symbol:</code></td>
<td>🚭 <code>:no_smoking:</code></td>
</tr>
<tr>
<td>🅿️ <code>:parking:</code></td>
<td>♿️ <code>:wheelchair:</code></td>
<td>🚇 <code>:metro:</code></td>
</tr>
<tr>
<td>🛄 <code>:baggage_claim:</code></td>
<td>🉑 <code>:accept:</code></td>
<td>🚾 <code>:wc:</code></td>
</tr>
<tr>
<td>🚰 <code>:potable_water:</code></td>
<td>🚮 <code>:put_litter_in_its_place:</code></td>
<td>㊙️ <code>:secret:</code></td>
</tr>
<tr>
<td>㊗️ <code>:congratulations:</code></td>
<td>Ⓜ️ <code>:m:</code></td>
<td>🛂 <code>:passport_control:</code></td>
</tr>
<tr>
<td>🛅 <code>:left_luggage:</code></td>
<td>🛃 <code>:customs:</code></td>
<td>🉐 <code>:ideograph_advantage:</code></td>
</tr>
<tr>
<td>🆑 <code>:cl:</code></td>
<td>🆘 <code>:sos:</code></td>
<td>🆔 <code>:id:</code></td>
</tr>
<tr>
<td>🚫 <code>:no_entry_sign:</code></td>
<td>🔞 <code>:underage:</code></td>
<td>📵 <code>:no_mobile_phones:</code></td>
</tr>
<tr>
<td>🚯 <code>:do_not_litter:</code></td>
<td>🚱 <code>:non-potable_water:</code></td>
<td>🚳 <code>:no_bicycles:</code></td>
</tr>
<tr>
<td>🚷 <code>:no_pedestrians:</code></td>
<td>🚸 <code>:children_crossing:</code></td>
<td>⛔️ <code>:no_entry:</code></td>
</tr>
<tr>
<td>✳️ <code>:eight_spoked_asterisk:</code></td>
<td>✴️ <code>:eight_pointed_black_star:</code></td>
<td>💟 <code>:heart_decoration:</code></td>
</tr>
<tr>
<td>🆚 <code>:vs:</code></td>
<td>📳 <code>:vibration_mode:</code></td>
<td>📴 <code>:mobile_phone_off:</code></td>
</tr>
<tr>
<td>💹 <code>:chart:</code></td>
<td>💱 <code>:currency_exchange:</code></td>
<td>♈️ <code>:aries:</code></td>
</tr>
<tr>
<td>♉️ <code>:taurus:</code></td>
<td>♊️ <code>:gemini:</code></td>
<td>♋️ <code>:cancer:</code></td>
</tr>
<tr>
<td>♌️ <code>:leo:</code></td>
<td>♍️ <code>:virgo:</code></td>
<td>♎️ <code>:libra:</code></td>
</tr>
<tr>
<td>♏️ <code>:scorpius:</code></td>
<td>♐️ <code>:sagittarius:</code></td>
<td>♑️ <code>:capricorn:</code></td>
</tr>
<tr>
<td>♒️ <code>:aquarius:</code></td>
<td>♓️ <code>:pisces:</code></td>
<td>⛎ <code>:ophiuchus:</code></td>
</tr>
<tr>
<td>🔯 <code>:six_pointed_star:</code></td>
<td>❎<code>:negative_squared_cross_mark:</code></td>
<td>🅰️ <code>:a:</code></td>
</tr>
<tr>
<td>🅱️ <code>:b:</code></td>
<td>🆎 <code>:ab:</code></td>
<td>🅾️ <code>:o2:</code></td>
</tr>
<tr>
<td>💠<code>:diamond_shape_with_a_dot_inside:</code></td>
<td>♻️ <code>:recycle:</code></td>
<td>🔚 <code>:end:</code></td>
</tr>
<tr>
<td>🔛 <code>:on:</code></td>
<td>🔜 <code>:soon:</code></td>
<td>🕐 <code>:clock1:</code></td>
</tr>
<tr>
<td>🕜 <code>:clock130:</code></td>
<td>🕙 <code>:clock10:</code></td>
<td>🕥 <code>:clock1030:</code></td>
</tr>
<tr>
<td>🕚 <code>:clock11:</code></td>
<td>🕦 <code>:clock1130:</code></td>
<td>🕛 <code>:clock12:</code></td>
</tr>
<tr>
<td>🕧 <code>:clock1230:</code></td>
<td>🕑 <code>:clock2:</code></td>
<td>🕝 <code>:clock230:</code></td>
</tr>
<tr>
<td>🕒 <code>:clock3:</code></td>
<td>🕞 <code>:clock330:</code></td>
<td>🕓 <code>:clock4:</code></td>
</tr>
<tr>
<td>🕟 <code>:clock430:</code></td>
<td>🕔 <code>:clock5:</code></td>
<td>🕠 <code>:clock530:</code></td>
</tr>
<tr>
<td>🕕 <code>:clock6:</code></td>
<td>🕡 <code>:clock630:</code></td>
<td>🕖 <code>:clock7:</code></td>
</tr>
<tr>
<td>🕢 <code>:clock730:</code></td>
<td>🕗 <code>:clock8:</code></td>
<td>🕣 <code>:clock830:</code></td>
</tr>
<tr>
<td>🕘 <code>:clock9:</code></td>
<td>🕤 <code>:clock930:</code></td>
<td>💲 <code>:heavy_dollar_sign:</code></td>
</tr>
<tr>
<td>©️ <code>:copyright:</code></td>
<td>®️ <code>:registered:</code></td>
<td>™️ <code>:tm:</code></td>
</tr>
<tr>
<td>❌ <code>:x:</code></td>
<td>❗️ <code>:heavy_exclamation_mark:</code></td>
<td>‼️ <code>:bangbang:</code></td>
</tr>
<tr>
<td>⁉️ <code>:interrobang:</code></td>
<td>⭕️ <code>:o:</code></td>
<td>✖️ <code>:heavy_multiplication_x:</code></td>
</tr>
<tr>
<td>➕ <code>:heavy_plus_sign:</code></td>
<td>➖ <code>:heavy_minus_sign:</code></td>
<td>➗ <code>:heavy_division_sign:</code></td>
</tr>
<tr>
<td>💮 <code>:white_flower:</code></td>
<td>💯 <code>:100:</code></td>
<td>✔️ <code>:heavy_check_mark:</code></td>
</tr>
<tr>
<td>☑️ <code>:ballot_box_with_check:</code></td>
<td>🔘 <code>:radio_button:</code></td>
<td>🔗 <code>:link:</code></td>
</tr>
<tr>
<td>➰ <code>:curly_loop:</code></td>
<td>〰️ <code>:wavy_dash:</code></td>
<td>〽️ <code>:part_alternation_mark:</code></td>
</tr>
<tr>
<td>🔱 <code>:trident:</code></td>
<td>:black_square: <code>:black_square:</code></td>
<td>:white_square: <code>:white_square:</code></td>
</tr>
<tr>
<td>✅ <code>:white_check_mark:</code></td>
<td>🔲 <code>:black_square_button:</code></td>
<td>🔳 <code>:white_square_button:</code></td>
</tr>
<tr>
<td>⚫️ <code>:black_circle:</code></td>
<td>⚪️ <code>:white_circle:</code></td>
<td>🔴 <code>:red_circle:</code></td>
</tr>
<tr>
<td>🔵 <code>:large_blue_circle:</code></td>
<td>🔷 <code>:large_blue_diamond:</code></td>
<td>🔶 <code>:large_orange_diamond:</code></td>
</tr>
<tr>
<td>🔹 <code>:small_blue_diamond:</code></td>
<td>🔸 <code>:small_orange_diamond:</code></td>
<td>🔺 <code>:small_red_triangle:</code></td>
</tr>
<tr>
<td>🔻 <code>:small_red_triangle_down:</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/index.html</url>
    <content><![CDATA[<p>😚</p>
]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/index.html</url>
    <content><![CDATA[<h1 id="哈哈哈"><a class="header-anchor" href="#哈哈哈"></a>哈哈哈</h1>
<p>👉️ 日拱一卒，功不唐捐。</p>
<p>📇 体系化的知识，需要一步一个脚印地输入，</p>
<p>👣 也需要循序渐进地消化。</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/index.html</url>
    <content><![CDATA[<h1 id="哈哈哈"><a class="header-anchor" href="#哈哈哈"></a>哈哈哈</h1>
<p>🎯️ Goals</p>
<p>👉️</p>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>index</title>
    <url>/POST/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html</url>
    <content><![CDATA[<p>深入java虚拟机</p>
]]></content>
      <categories>
        <category>POST</category>
        <category>深入理解JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>📖后端学习计划 - :cyclone:  书籍推荐</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.html</url>
    <content><![CDATA[<h1 id="🌀-书籍推荐"><a class="header-anchor" href="#🌀-书籍推荐"></a>🌀 书籍推荐</h1>
<p>📚✨🎞️📖👉🤓❤️🤣</p>
<p>🈂️</p>
<p>🏷️🔖🗞️📰📑📚🗂️📂📁💼🗒️📝📅📆📋📌📍📎🖇️⌛⌚⏰⏱️⏲️🕰️</p>
<p>🗂️📂📁🗓️📆📍📒</p>
<p>🗝️🔑🎹📻🔒🔓🔏🔐⚒️🪨🧱🔩🪛🔧🛠️🪵🛖⚙️🗜️🛢️⚗️💉🩻🩺🧬🧫🧪🩸🩹🩼💊🔬🔭🧰🪝⛓️🔗📿⚖️🧲🪜🦯🛡️🪚🏹♥️🎲🎖️🏆🎮🕹️🎰🥉🥇🥈🔔👟👗⚙️🔍🔎✒️🖋️🖊️🖌️🖍️📝🪥🚿🪠🪞🪒</p>
<p>🎧🎛️🎚️📯🥁🎙️🎤🪘📴📳📲♀️⚧️♂️🚬🪪🔋🪫🔌💻🖥️🪧⌨️🖱️🖲️💽💾💿📀🧮🎬📽️🎥📡📺📷📸📹📼💴💵🪙💰💳✉️📧📩📤📥📦📫🆘⭕⛔🚫🔇🔕❗❕❓❔‼️💯⁉️🔅🔆🔱⚜️✅➕➖✖️➗🟰™️®️©️🔘🔴🟠⚫🟤🟣🔵🟢🟡⚪🟥🟧🟨🟩🟦◻️◼️⬜⬛🟫🟪◾◽▪️▫️🔶🔲🗨️👁️‍🗨️</p>
<p>💫</p>
<p>🎯️</p>
<p>🛠️</p>
<p>📑</p>
<p>💻</p>
<p>🧑‍💻</p>
<p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是对应的脚注">[1]</span></a></sup></p>
<p>这是一句话2<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是对应222的脚注">[2]</span></a></sup></p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox"> a</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> b</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox"> c</p>
</li>
<li>
<p>如何翻盘？</p>
<ul>
<li>博客，记录学习的知识点。</li>
<li>github开源项目，目前不现实。</li>
</ul>
</li>
<li>
<p>许令波《深入分析Java Web技术内幕》</p>
<ul>
<li>我个人觉得这是一本水书，走马观花。但是也值得草草过一遍，因为每一个知识点都可以独立展开。</li>
</ul>
</li>
<li>
<p>姜承尧《MySQL技术内幕-InnoDB存储引擎》</p>
<ul>
<li>经典老书，知识点散乱，需要自己整理成知识卡片，缕出思路。</li>
<li>书上对每个知识点都解释的原因和目的，逻辑是清晰的</li>
</ul>
</li>
<li>
<p>掘金小册上《从根上理解MySQL》</p>
<ul>
<li>非常推荐，不适合碎片化阅读，需要大段大段的连续时间细读理解，建议周末连肝两天，每天10小时。</li>
<li>这本书非常细，没必要刻意记一些结构和数字。理解就够了</li>
<li>可以关注作者的工作号，上面有补充文章可以看</li>
<li>读完能彻底掌握MySQL原理的基础</li>
</ul>
</li>
<li>
<p>《高性能MySQL》，《高可用MySQL》</p>
<ul>
<li>简单看看即可，主要是拓展广度</li>
</ul>
</li>
<li>
<p>周志明-《深入理解Java虚拟机》</p>
<ul>
<li>JVM其实很复杂，这本书仅仅是入门级别的书，但是通读就可以应对大部分面试和工作场景</li>
<li>JVM工具上可以试一试jprofile，图形化很直观</li>
<li>Arthas必须会</li>
<li>书中“高效并发”这块内容，可以结合方腾飞的《Java并发编程的艺术》看，</li>
</ul>
</li>
<li>
<p>黄健宏-《Redis设计与实现》</p>
<ul>
<li>实际上这本书不值得推荐，里面有c语言源码，基于redis2.9，知识旧。</li>
<li>但是，对于基本数据结构的底层实现写的不错，需要自行整理下来（别去网上抄，网上的有问题）</li>
<li>就没发现关于Redis的好书，强烈建议直接官网文档</li>
</ul>
</li>
<li>
<p>MyBatis-官网</p>
<ul>
<li>没觉得有什么书好的，推荐官网上学习</li>
</ul>
</li>
<li>
<p>《深入理解Kafka:核心设计与实践原理》</p>
<ul>
<li>挺不错的书，原理和解释很全面了，就是废话贼多看得难受</li>
</ul>
</li>
<li>
<p>设计模式的两份资料</p>
<ul>
<li>比较理论化的<a href="https://refactoringguru.cn/design-patterns/catalog">https://refactoringguru.cn/design-patterns/catalog</a></li>
<li>接地气的：小傅哥(公众号：bugstack虫洞栈)《重学Java设计模式》 PDF，直接找我要</li>
<li>《HeadFirst设计模式》那本书废话太多，时间就是金钱，个人不推荐。</li>
</ul>
</li>
<li>
<p>《图解TCP》，《图解HTTP》</p>
<ul>
<li>简单过过就好，查缺补漏。其实书上有挺多不严谨，不明确的地方（相对教材）。</li>
<li>如果可以看回教材的话，还是看看教材。如果不是计算机专业，看谢希仁的就够了，Kurose的那本太深了，没必要。</li>
</ul>
</li>
<li>
<p>《Netty实战》</p>
<ul>
<li>用过Netty或许想学Netty，这本书跟着做就算<strong>入门</strong>了。</li>
</ul>
</li>
<li>
<p>并发编程类</p>
<ul>
<li>《Java并发编程实战》太深（一是抽象二是翻译），但是权威。没必要通读，看着目录找自己感兴趣的即可。</li>
<li>方腾飞的《Java并发编程的艺术》结合着敲，敲完就达标了。</li>
<li>葛一明的《实战Java高并发程序设计》，这本书是水书，很浅，但是有配套视频教程，对着敲很有效果。教程直接找我要。</li>
</ul>
</li>
<li>
<p>Spring这些就不推荐书了，时效性不高</p>
<ul>
<li>Spring思想就是工厂模式（容器），对Spring的基本概括就是依赖注入与AOP。</li>
<li>配置（xml/javaConfig声明）到Bean的过程（Resource-BeanDefinition-实例化-初始化-销毁），个人认为Spring的DI与AOP思想的实现就在BeanPostProcessor</li>
</ul>
</li>
<li>
<p>《图解Java多线程设计模式》</p>
<ul>
<li>都是些并发编程的应用，这里面的模式在框架设计层面都有体现。</li>
<li>可以对着将这些模式实现一遍，非常有帮助</li>
</ul>
</li>
<li>
<p>《图解网络-小林coding》</p>
<ul>
<li>作者有点功底的，就当优质博文看吧。PDF直接找我要</li>
</ul>
</li>
</ul>
<p>知识板块</p>
<p>计算机基础，操作系统</p>
<ul>
<li>硬件基本知识：CPU，缓存，内存，硬盘，DMA</li>
<li>线程调度，文件系统，用户态内核态</li>
<li>LInux命令，top, grep, sort, find, tail, sed</li>
<li>书：</li>
</ul>
<p>网络知识</p>
<ul>
<li>7层4层，</li>
<li>tcp udp ip</li>
<li>http，https(SSL TLS)</li>
<li>书：
<ul>
<li>《图解TCP》，《图解HTTP》过一下就好</li>
</ul>
</li>
</ul>
<p>数据库MySQL为例</p>
<ul>
<li>总体架构</li>
<li>索引的结构和原理, 数据页，bufferpool等等</li>
<li>执行计划与优化
<ul>
<li>索引下推，join，</li>
</ul>
</li>
<li>不同维度的锁。表锁行锁，意向锁，gap-lock next-key-lock等等</li>
<li>四个并发问题与隔离级别</li>
<li>redo log,undo log，MVVC，ReadView</li>
<li>binlog与主从，canal，读写分离（mycat中间件），多写MGR(了解)
<ul>
<li>这里上升到分布式系统层面视角</li>
</ul>
</li>
<li>information_schema架构。里面的系统表，以及各种配置项</li>
<li>分库分表的场景与将会面临的问题（弊端）， Sharding-JDBC(Sharding-Sphere), mycat</li>
<li>书
<ul>
<li>InnoDB存储引擎
<ul>
<li>老书，知识点散乱，需要自行整理</li>
</ul>
</li>
<li>高性能MySQL
<ul>
<li>比较浅，但是知识结构清晰，简单过一过就好</li>
</ul>
</li>
<li>高可用MySQL
<ul>
<li>我没看过，直观上感觉了解一下就好了</li>
</ul>
</li>
<li>官网reference
<ul>
<li>可以发现很多日常工作中坑的原因</li>
</ul>
</li>
<li>掘金小册《从根上理解MySQL》
<ul>
<li>这本书很仔细，适合深度理解，需要大段的连续时间研读。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>缓存Redis</p>
<ul>
<li>数据结构以及对应原理
<ul>
<li>找博客怕是找不全。可以通过《Redis设计与实现》自行整理，但这本书浅，很多知识点落后了（基于2.9的）</li>
</ul>
</li>
<li>配置文件一个个配置项看</li>
<li>应用场景
<ul>
<li>缓存，各种redis命令上的坑</li>
<li>用于分布式锁的优势劣势，RedLock（进阶）</li>
<li>限流（少）</li>
</ul>
</li>
<li>jedis，lettuce, redisson</li>
<li>热点数据，慢查询，expired</li>
<li>redis的使用规范</li>
<li>缓存的击穿穿透雪崩，与数据库一致性(双写一致性)问题
<ul>
<li>首先要明确，缓存的目的。它的应用场景就一定是写少读多，以此为出发点思考上述问题即可。</li>
<li>没经历就记八股文，有经历就能灵活处理</li>
<li>什么延迟双删也不知道是哪个脑瘫发明出来的</li>
</ul>
</li>
<li>主从，备份，持久化，cluster。
<ul>
<li>分片，hashtag，一致性问题，gossip协议等等 这种也上升到分布式系统设计的问题了。</li>
</ul>
</li>
<li>书
<ul>
<li>Redis知识只推荐官网，我没找到其它好的资料。英文不好只能硬啃没办法。</li>
<li>垃圾避坑：掘金上老钱的Redis，别浪费钱</li>
</ul>
</li>
</ul>
<p>设计模式</p>
<ul>
<li>理解过一遍就行，别钻牛角尖，个人认为设计模式是上层设计层思考的事情，而不是编码层去考虑，视角放高。</li>
<li>实际上绝大部分人都是crud, if else。</li>
<li>书：
<ul>
<li>比较理论化的<a href="https://refactoringguru.cn/design-patterns/catalog">https://refactoringguru.cn/design-patterns/catalog</a></li>
<li>接地气的：小傅哥(公众号：bugstack虫洞栈)《重学Java设计模式》 PDF，直接找我要</li>
</ul>
</li>
</ul>
<p>分布式架构</p>
<ul>
<li>dubbo SOA架构</li>
<li>SpringCloud微服务各种组件与作用（熔断，限流，网关，配置，总线，降级）</li>
<li>其实这部分知识，项目体量上不去这些组件很难深刻理解，知道它们在微服务中作用即可</li>
<li>zookeeper及其客户端curator，一些协调应用场景的实现（选主，分布式锁，watch机制）</li>
<li>分布式ID，</li>
</ul>
<p>Java基础</p>
<ul>
<li>JDK上String，Map, Collection，JUC（AQS,Lock,AtomicXxx, 线程池…）</li>
<li>AQS=state+等待队列</li>
</ul>
<p>消息中间件</p>
<ul>
<li>应用场景，动手试一试</li>
<li>Kafka, RocketMQ. 下面kafka为例</li>
<li>Topic, 副本replica，partition，leader, ISR,OSR，高水位低水位，segment file, rebalance</li>
<li>消息丢失，重复，有序，幂等处理
<ul>
<li>producer如何保证，broker如何保证，consumer如何处理可以保证。consumer与group的顺序，offset,</li>
</ul>
</li>
<li>书
<ul>
<li>《深入理解Kafka:核心设计与实践原理》
<ul>
<li>挺不错的书，原理很全面了，就是废话贼多看得难受，凑字数骗稿酬</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分布式事务</p>
<ul>
<li>先搞个seata实践一下</li>
<li>原理层面大致搜一搜就有了，真要理解得看很多（共识问题出发，Paxos，到ACID，再到BASE, 2PC，TCC）</li>
<li>2PC（基本原理） TCC（柔性，依赖业务编码，幂等）</li>
<li>Sage方案</li>
</ul>
<p>JVM</p>
<ul>
<li>直接看书吧，快速过即可问不了多深。《深入理解Java虚拟机》</li>
<li>基本上就是内存结构，Java内存模型，类加载，classloader，SPI，常用工具</li>
<li>CMS（在JDK9之后废弃），G1基本概念和原理</li>
<li>一般的排查方式jstack, jmap, jprofile,jvisualvm等等</li>
<li>阿里Arthas，基本就用两个命令watch trace</li>
</ul>
<p>Netty</p>
<ul>
<li>没用过就算了</li>
<li>Reactor模型中主从Reactor的变体(去掉线程池的变体)</li>
<li>事件循环EventLoop，Channel，ChannelPipeline，Inbound/Outbound</li>
<li>实现分片拷贝</li>
<li>粘包拆包的四种方案。</li>
<li>实现长连接，心跳，断线重连</li>
</ul>
<p>Spring，SpringMVC，SpringBoot</p>
<ul>
<li>Spring思想就是工厂模式（容器）。基本概括就是依赖注入与AOP。</li>
<li>常用注解</li>
<li>配置（xml/javaConfig声明）到Bean的过程（Resource-BeanDefinition-实例化-初始化-销毁），个人认为Spring的DI与AOP思想的实现就在BeanPostProcessor</li>
<li>容器refresh过程，循环依赖</li>
<li>SpringMVC源码可以看看，挺不错的</li>
<li>SpringBoot的spring.factories（看看starter包里/META-INF/spring.factories）</li>
</ul>
<p>MyBatis</p>
<ul>
<li>太简单了，官网跟着写一轮就好了</li>
<li>xml方式配置，config方式配置</li>
<li>xml方式声明sql，注解方式声明sql</li>
<li>框架原理方面网上都有，也比较简单</li>
<li>可以看看源码，写得还是很不错的。</li>
</ul>
<p>Dubbo</p>
<ul>
<li>用的少，活跃度也不太行了。</li>
<li>官网看一看，搜一搜面试题就好</li>
<li>主要是各个协议的特点。因为Dubbo本身就是RMI的解决方案，传输协议，解压缩，编码等等是实现上关键点</li>
</ul>
<pre><code class=" mermaid">flowchart TD
A[start] --&gt; B&#123;It&#x27;s TURE?&#125;
B --Yes--&gt; C[OK]
c --&gt; D[Rethink]
D --&gt; B
B ----&gt; |No| E[End]
</code></pre>
<section class="footnotes"><h1>📚Reference</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>这是对应222的脚注
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
      <tags>
        <tag>Tag</tag>
        <tag>Tag2</tag>
      </tags>
  </entry>
  <entry>
    <title>非常详细的Docker学习笔记</title>
    <url>/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/detail_docker_study_note.html</url>
    <content><![CDATA[<h1 id="一、Docker-简介"><a class="header-anchor" href="#一、Docker-简介"></a>一、Docker 简介</h1>
<p>Docker 两个主要部件：</p>
<ul>
<li>Docker: 开源的容器虚拟化平台</li>
<li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – <a href="https://registry.hub.docker.com/search?q=library">Docker Hub</a></li>
</ul>
<p>Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091033_189.png" alt="非常详细的 Docker 学习笔记"></p>
<h2 id="1-1-Docker-守护进程"><a class="header-anchor" href="#1-1-Docker-守护进程"></a>1.1 Docker 守护进程</h2>
<p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p>
<h2 id="1-2-Docker-客户端"><a class="header-anchor" href="#1-2-Docker-客户端"></a>1.2 Docker 客户端</h2>
<p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p>
<h2 id="1-3-Docker-内部"><a class="header-anchor" href="#1-3-Docker-内部"></a>1.3 Docker 内部</h2>
<p>要理解 Docker 内部构建，需要理解以下三种部件：</p>
<ul>
<li>Docker 镜像 - Docker images</li>
<li>Docker 仓库 - Docker registeries</li>
<li>Docker 容器 - Docker containers</li>
</ul>
<h3 id="Docker-镜像"><a class="header-anchor" href="#Docker-镜像"></a>Docker 镜像</h3>
<p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p>
<h3 id="Docker-仓库"><a class="header-anchor" href="#Docker-仓库"></a>Docker 仓库</h3>
<p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p>
<h3 id="Docker-容器"><a class="header-anchor" href="#Docker-容器"></a>Docker 容器</h3>
<p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p>
<h2 id="1-4-libcontainer"><a class="header-anchor" href="#1-4-libcontainer"></a>1.4 libcontainer</h2>
<p>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091034_223.png" alt="非常详细的 Docker 学习笔记"></p>
<ul>
<li>图片来源: <a href="http://blog.docker.com/2014/03/docker-0-9-introducing-execution-drivers-and-libcontainer/">Docker 0.9: introducing execution drivers and libcontainer</a></li>
</ul>
<h2 id="1-5-命名空间「Namespaces」"><a class="header-anchor" href="#1-5-命名空间「Namespaces」"></a>1.5 命名空间「Namespaces」</h2>
<h3 id="pid-namespace"><a class="header-anchor" href="#pid-namespace"></a>pid namespace</h3>
<p>不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p>
<ul>
<li>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li>
<li>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li>
<li>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li>
<li>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</li>
</ul>
<p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/">Introduction to Linux namespaces – Part 3: PID</a></p>
<h3 id="mnt-namespace"><a class="header-anchor" href="#mnt-namespace"></a>mnt namespace</h3>
<p>类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p>
<h3 id="net-namespace"><a class="header-anchor" href="#net-namespace"></a>net namespace</h3>
<p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/">Introduction to Linux namespaces – Part 5: NET</a></p>
<h3 id="uts-namespace"><a class="header-anchor" href="#uts-namespace"></a>uts namespace</h3>
<p>UTS (“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction to Linux namespaces – Part 1: UTS</a></p>
<h3 id="ipc-namespace"><a class="header-anchor" href="#ipc-namespace"></a>ipc namespace</h3>
<p>container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/">Introduction to Linux namespaces – Part 2: IPC</a></p>
<h3 id="user-namespace"><a class="header-anchor" href="#user-namespace"></a>user namespace</h3>
<p>每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p>
<p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p>
<h3 id="Reference"><a class="header-anchor" href="#Reference"></a>Reference</h3>
<ul>
<li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/">Docker Getting Start: Related Knowledge</a></li>
<li><a href="https://ruby-china.org/topics/22004">Docker 介绍以及其相关术语、底层原理和技术</a></li>
</ul>
<h2 id="1-6-资源配额「cgroups」"><a class="header-anchor" href="#1-6-资源配额「cgroups」"></a>1.6 资源配额「cgroups」</h2>
<p>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p>
<ul>
<li>memory
<ul>
<li>内存相关的限制</li>
</ul>
</li>
<li>cpu
<ul>
<li>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li>
</ul>
</li>
<li>blkio
<ul>
<li>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li>
</ul>
</li>
<li>devices
<ul>
<li>设备权限限制</li>
</ul>
</li>
</ul>
<p>参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/">how to use cgroup</a></p>
<h1 id="二、Docker-安装"><a class="header-anchor" href="#二、Docker-安装"></a>二、Docker 安装</h1>
<p>docker 的相关安装方法这里不作介绍，具体安装参考 <a href="https://docs.docker.com/installation/">官档</a></p>
<p>获取当前 docker 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker version<br>Client version: 1.3.2<br>Client API version: 1.15<br>Go version (client): go1.3.3<br>Git commit (client): 39fa2fa/1.3.2<br>OS/Arch (client): linux/amd64<br>Server version: 1.3.2<br>Server API version: 1.15<br>Go version (server): go1.3.3<br>Git commit (server): 39fa2fa/1.3.2<br></code></pre></td></tr></table></figure>
<h1 id="三、Docker-基础用法"><a class="header-anchor" href="#三、Docker-基础用法"></a>三、Docker 基础用法</h1>
<p><a href="https://registry.hub.docker.com/">Docker HUB</a> : Docker镜像首页，包括官方镜像和其它公开镜像</p>
<p>因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 <a href="http://opskumu.github.io/docker.cn">docker.cn</a> 镜像，镜像保持和官方一致，关键是速度块，推荐使用。</p>
<h2 id="3-1-Search-images"><a class="header-anchor" href="#3-1-Search-images"></a>3.1 Search images</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker search ubuntu<br></code></pre></td></tr></table></figure>
<h2 id="3-2-Pull-images"><a class="header-anchor" href="#3-2-Pull-images"></a>3.2 Pull images</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker pull ubuntu <span class="hljs-comment"># 获取 ubuntu 官方镜像 </span><br>$ sudo docker images <span class="hljs-comment"># 查看当前镜像列表 </span><br></code></pre></td></tr></table></figure>
<h2 id="3-3-Running-an-interactive-shell"><a class="header-anchor" href="#3-3-Running-an-interactive-shell"></a>3.3 Running an interactive shell</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -i -t ubuntu:14.04 /bin/bash<br></code></pre></td></tr></table></figure>
<ul>
<li>docker run - 运行一个容器</li>
<li>-t - 分配一个（伪）tty (link is external)</li>
<li>-i - 交互模式 (so we can interact with it)</li>
<li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li>
<li>/bin/bash - 运行命令 bash shell</li>
</ul>
<p>注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker ps <span class="hljs-comment"># 查看当前运行的容器, ps -a 列出当前系统所有的容器 </span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>6c9129e9df10        ubuntu:14.04        /bin/bash 6 minutes ago       Up 6 minutes                            cranky_babbage<br></code></pre></td></tr></table></figure>
<h2 id="3-4-相关快捷键"><a class="header-anchor" href="#3-4-相关快捷键"></a>3.4 相关快捷键</h2>
<ul>
<li>退出：Ctrl-Dorexit</li>
<li>detach：Ctrl-P + Ctrl-Q</li>
<li>attach:docker attach CONTAINER-ID</li>
</ul>
<h1 id="四、Docker-命令帮助"><a class="header-anchor" href="#四、Docker-命令帮助"></a>四、Docker 命令帮助</h1>
<h2 id="4-1-docker-help"><a class="header-anchor" href="#4-1-docker-help"></a>4.1 docker help</h2>
<h3 id="docker-command"><a class="header-anchor" href="#docker-command"></a>docker command</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker   <span class="hljs-comment"># docker 命令帮助</span><br>Commands:<br>    attach    Attach to a running container                 <span class="hljs-comment"># 当前 shell 下 attach 连接指定运行镜像</span><br>    build     Build an image from a Dockerfile              <span class="hljs-comment"># 通过 Dockerfile 定制镜像</span><br>    commit    Create a new image from a container<span class="hljs-string">&#x27;s changes # 提交当前容器为新的镜像</span><br><span class="hljs-string">    cp        Copy files/folders from the containers filesystem to the host path</span><br><span class="hljs-string">              # 从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="hljs-string">    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="hljs-string">    diff      Inspect changes on a container&#x27;</span>s filesystem   <span class="hljs-comment"># 查看 docker 容器变化</span><br>    events    Get real time events from the server          <span class="hljs-comment"># 从 docker 服务获取容器实时事件</span><br>    <span class="hljs-built_in">exec</span>      Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> an existing container        <span class="hljs-comment"># 在已存在的容器上运行命令</span><br>    <span class="hljs-built_in">export</span>    Stream the contents of a container as a tar archive   <br>              <span class="hljs-comment"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br>    <span class="hljs-built_in">history</span>   Show the <span class="hljs-built_in">history</span> of an image                  <span class="hljs-comment"># 展示一个镜像形成历史</span><br>    images    List images                                   <span class="hljs-comment"># 列出系统当前镜像</span><br>    import    Create a new filesystem image from the contents of a tarball  <br>              <span class="hljs-comment"># 从tar包中的内容创建一个新的文件系统映像[对应 export]</span><br>    info      Display system-wide information               <span class="hljs-comment"># 显示系统相关信息</span><br>    inspect   Return low-level information on a container   <span class="hljs-comment"># 查看容器详细信息</span><br>    <span class="hljs-built_in">kill</span>      Kill a running container                      <span class="hljs-comment"># kill 指定 docker 容器</span><br>    load      Load an image from a tar archive              <span class="hljs-comment"># 从一个 tar 包中加载一个镜像[对应 save]</span><br>    login     Register or Login to the docker registry server   <br>              <span class="hljs-comment"># 注册或者登陆一个 docker 源服务器</span><br>    <span class="hljs-built_in">logout</span>    Log out from a Docker registry server         <span class="hljs-comment"># 从当前 Docker registry 退出</span><br>    logs      Fetch the logs of a container                 <span class="hljs-comment"># 输出当前容器日志信息</span><br>    port      Lookup the public-facing port <span class="hljs-built_in">which</span> is NAT-ed to PRIVATE_PORT<br>              <span class="hljs-comment"># 查看映射端口对应的容器内部源端口</span><br>    pause     Pause all processes within a container        <span class="hljs-comment"># 暂停容器</span><br>    ps        List containers                               <span class="hljs-comment"># 列出容器列表</span><br>    pull      Pull an image or a repository from the docker registry server<br>              <span class="hljs-comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span><br>    push      Push an image or a repository to the docker registry server<br>              <span class="hljs-comment"># 推送指定镜像或者库镜像至docker源服务器</span><br>    restart   Restart a running container                   <span class="hljs-comment"># 重启运行的容器</span><br>    <span class="hljs-built_in">rm</span>        Remove one or more containers                 <span class="hljs-comment"># 移除一个或者多个容器</span><br>    rmi       Remove one or more images                 <br>              <span class="hljs-comment"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br>    run       Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> a new container<br>              <span class="hljs-comment"># 创建一个新的容器并运行一个命令</span><br>    save      Save an image to a tar archive                <span class="hljs-comment"># 保存一个镜像为一个 tar 包[对应 load]</span><br>    search    Search <span class="hljs-keyword">for</span> an image on the Docker Hub         <span class="hljs-comment"># 在 docker hub 中搜索镜像</span><br>    start     Start a stopped containers                    <span class="hljs-comment"># 启动容器</span><br>    stop      Stop a running containers                     <span class="hljs-comment"># 停止容器</span><br>    tag       Tag an image into a repository                <span class="hljs-comment"># 给源中镜像打标签</span><br>    top       Lookup the running processes of a container   <span class="hljs-comment"># 查看容器中运行的进程信息</span><br>    unpause   Unpause a paused container                    <span class="hljs-comment"># 取消暂停容器</span><br>    version   Show the docker version information           <span class="hljs-comment"># 查看 docker 版本号</span><br>    <span class="hljs-built_in">wait</span>      Block until a container stops, <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span> its <span class="hljs-built_in">exit</span> code   <br>              <span class="hljs-comment"># 截取容器停止时的退出状态值</span><br>Run <span class="hljs-string">&#x27;docker COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure>
<h3 id="docker-option"><a class="header-anchor" href="#docker-option"></a>docker option</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Usage of docker:<br>  --api-enable-cors=<span class="hljs-literal">false</span>                Enable CORS headers <span class="hljs-keyword">in</span> the remote API                      <span class="hljs-comment"># 远程 API 中开启 CORS 头</span><br>  -b, --bridge=<span class="hljs-string">&quot;&quot;</span>                        Attach containers to a pre-existing network bridge         <span class="hljs-comment"># 桥接网络</span><br>                                           use <span class="hljs-string">&#x27;none&#x27;</span> to <span class="hljs-built_in">disable</span> container networking<br>  --bip=<span class="hljs-string">&quot;&quot;</span>                               Use this CIDR notation address <span class="hljs-keyword">for</span> the network bridge<span class="hljs-string">&#x27;s IP, not compatible with -b</span><br><span class="hljs-string">                                         # 和 -b 选项不兼容，具体没有测试过</span><br><span class="hljs-string">  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式</span><br><span class="hljs-string">  -D, --debug=false                      Enable debug mode                                          # debug 模式</span><br><span class="hljs-string">  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器</span><br><span class="hljs-string">  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域</span><br><span class="hljs-string">  -e, --exec-driver=&quot;native&quot;             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器</span><br><span class="hljs-string">  --fixed-cidr=&quot;&quot;                        IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)</span><br><span class="hljs-string">                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)</span><br><span class="hljs-string">  -G, --group=&quot;docker&quot;                   Group to assign the unix socket specified by -H when running in daemon mode</span><br><span class="hljs-string">                                           use &#x27;</span><span class="hljs-string">&#x27; (the empty string) to disable setting of a group</span><br><span class="hljs-string">  -g, --graph=&quot;/var/lib/docker&quot;          Path to use as the root of the docker runtime              # 容器运行的根目录路径</span><br><span class="hljs-string">  -H, --host=[]                          The socket(s) to bind to in daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]</span><br><span class="hljs-string">                                           specified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.</span><br><span class="hljs-string">  --icc=true                             Enable inter-container communication                       # 跨容器通信</span><br><span class="hljs-string">  --insecure-registry=[]                 Enable insecure communication with specified registries (no certificate verification for HTTPS and enable HTTP fallback) (e.g., localhost:5000 or 10.20.0.0/16)</span><br><span class="hljs-string">  --ip=&quot;0.0.0.0&quot;                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip</span><br><span class="hljs-string">  --ip-forward=true                      Enable net.ipv4.ip_forward                                 # 开启转发</span><br><span class="hljs-string">  --ip-masq=true                         Enable IP masquerading for bridge&#x27;</span>s IP range<br>  --iptables=<span class="hljs-literal">true</span>                        Enable Docker<span class="hljs-string">&#x27;s addition of iptables rules                 # 添加对应 iptables 规则</span><br><span class="hljs-string">  --mtu=0                                Set the containers network MTU                             # 设置网络 mtu</span><br><span class="hljs-string">                                           if no value is provided: default to the default route MTU or 1500 if no default route is available</span><br><span class="hljs-string">  -p, --pidfile=&quot;/var/run/docker.pid&quot;    Path to use for daemon PID file                            # 指定 pid 文件位置</span><br><span class="hljs-string">  --registry-mirror=[]                   Specify a preferred Docker registry mirror                  </span><br><span class="hljs-string">  -s, --storage-driver=&quot;&quot;                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动</span><br><span class="hljs-string">  --selinux-enabled=false                Enable selinux support                                     # 开启 selinux 支持</span><br><span class="hljs-string">  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项</span><br><span class="hljs-string">  --tls=false                            Use TLS; implied by tls-verify flags                       # 开启 tls</span><br><span class="hljs-string">  --tlscacert=&quot;/root/.docker/ca.pem&quot;     Trust only remotes providing a certificate signed by the CA given here</span><br><span class="hljs-string">  --tlscert=&quot;/root/.docker/cert.pem&quot;     Path to TLS certificate file                               # tls 证书文件位置</span><br><span class="hljs-string">  --tlskey=&quot;/root/.docker/key.pem&quot;       Path to TLS key file                                       # tls key 文件位置</span><br><span class="hljs-string">  --tlsverify=false                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机</span><br><span class="hljs-string">  -v, --version=false                    Print version information and quit                         # 输出 docker 版本信息</span><br></code></pre></td></tr></table></figure>
<h2 id="4-2-docker-search"><a class="header-anchor" href="#4-2-docker-search"></a>4.2 docker search</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker search --<span class="hljs-built_in">help</span><br>Usage: docker search TERM<br>Search the Docker Hub <span class="hljs-keyword">for</span> images <span class="hljs-comment"># 从 Docker Hub 搜索镜像 --automated=false Only show automated builds</span><br>  --no-trunc=<span class="hljs-literal">false</span> Don<span class="hljs-string">&#x27;t truncate output</span><br><span class="hljs-string">  -s, --stars=0 Only displays with at least xxx stars</span><br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">$ sudo docker <span class="hljs-keyword">search</span> -s <span class="hljs-number">100</span> ubuntu # 查找 star 数至少为 <span class="hljs-number">100</span> 的镜像，找出只有官方镜像 <span class="hljs-keyword">start</span> 数超过 <span class="hljs-number">100</span>，默认不加 s 选项找出所有相关 ubuntu 镜像 <br><span class="hljs-type">NAME</span>      DESCRIPTION                  STARS     OFFICIAL   AUTOMATED<br>ubuntu    Official Ubuntu base image <span class="hljs-number">425</span> [OK] <br></code></pre></td></tr></table></figure>
<h2 id="4-3-docker-info"><a class="header-anchor" href="#4-3-docker-info"></a>4.3 docker info</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">sudo</span> <span class="hljs-string">docker</span> <span class="hljs-string">info</span> <br><span class="hljs-attr">Containers:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 容器个数 </span><br><span class="hljs-attr">Images:</span> <span class="hljs-number">22</span> <span class="hljs-comment"># 镜像个数 </span><br><span class="hljs-attr">Storage Driver:</span> <span class="hljs-string">devicemapper</span> <span class="hljs-comment"># 存储驱动 </span><br><span class="hljs-attr">Pool Name:</span> <span class="hljs-string">docker-8:17-3221225728-pool</span><br><span class="hljs-attr">Pool Blocksize:</span> <span class="hljs-number">65.54</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">Data file:</span> <span class="hljs-string">/data/docker/devicemapper/devicemapper/data</span><br><span class="hljs-attr">Metadata file:</span> <span class="hljs-string">/data/docker/devicemapper/devicemapper/metadata</span><br><span class="hljs-attr">Data Space Used:</span> <span class="hljs-number">1.83</span> <span class="hljs-string">GB</span><br> <span class="hljs-attr">Data Space Total:</span> <span class="hljs-number">107.4</span> <span class="hljs-string">GB</span><br><span class="hljs-attr">Metadata Space Used:</span> <span class="hljs-number">2.191</span> <span class="hljs-string">MB</span><br> <span class="hljs-attr">Metadata Space Total:</span> <span class="hljs-number">2.147</span> <span class="hljs-string">GB</span><br><span class="hljs-attr">Library Version:</span> <span class="hljs-number">1.02</span><span class="hljs-number">.84</span><span class="hljs-string">-RHEL7</span> <span class="hljs-string">(2014-03-26)</span> <span class="hljs-attr">Execution Driver:</span> <span class="hljs-string">native-0.2</span> <span class="hljs-comment"># 存储驱动 Kernel Version: 3.10.0-123.el7.x86_64</span><br><span class="hljs-attr">Operating System:</span> <span class="hljs-string">CentOS</span> <span class="hljs-string">Linux</span> <span class="hljs-number">7</span> <span class="hljs-string">(Core)</span> <br></code></pre></td></tr></table></figure>
<h2 id="4-4-docker-pull-docker-push"><a class="header-anchor" href="#4-4-docker-pull-docker-push"></a>4.4 docker pull &amp;&amp; docker push</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker pull --<span class="hljs-built_in">help</span> <span class="hljs-comment"># pull 拉取镜像 </span><br>Usage: docker pull [OPTIONS] NAME[:TAG] Pull an image or a repository from the registry<br>-a, --all-tags=<span class="hljs-literal">false</span> Download all tagged images <span class="hljs-keyword">in</span> the repository <br><br>$ sudo docker push <span class="hljs-comment"># push 推送指定镜像 </span><br>Usage: docker push NAME[:TAG] Push an image or a repository to the registry<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker pull ubuntu <span class="hljs-comment"># 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像 </span><br>$ sudo docker pull ubuntu:14.04 <span class="hljs-comment"># 下载指定版本 ubuntu 官方镜像 </span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker push 192.168.0.100:5000/ubuntu <span class="hljs-comment"># 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户] </span><br>$ sudo docker push 192.168.0.100:5000/ubuntu:14.04 <span class="hljs-comment"># 推送指定镜像到私有源 </span><br></code></pre></td></tr></table></figure>
<h2 id="4-5-docker-images"><a class="header-anchor" href="#4-5-docker-images"></a>4.5 docker images</h2>
<p>列出当前系统镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker images --<span class="hljs-built_in">help</span><br><br>Usage: docker images [OPTIONS] [NAME] List images<br><br>  -a, --all=<span class="hljs-literal">false</span> Show all images (by default filter out the intermediate image layers) <span class="hljs-comment"># -a 显示当前系统的所有镜像，包括过渡层镜像，默认 docker images 显示最终镜像，不包括过渡层镜像 </span><br>  -f, --filter=[] Provide filter values (i.e. <span class="hljs-string">&#x27;dangling=true&#x27;</span>) --no-trunc=<span class="hljs-literal">false</span> Don<span class="hljs-string">&#x27;t truncate output</span><br><span class="hljs-string">  -q, --quiet=false Only show numeric IDs</span><br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker images <span class="hljs-comment"># 显示当前系统镜像，不包括过渡层镜像 </span><br>$ sudo docker images -a <span class="hljs-comment"># 显示当前系统所有镜像，包括过渡层镜像 </span><br>$ sudo docker images ubuntu <span class="hljs-comment"># 显示当前系统 docker ubuntu 库中的所有镜像 </span><br>REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                     12.04               ebe4be4dd427 4 weeks ago         210.6 MB<br>ubuntu                     14.04               e54ca5efa2e9 4 weeks ago         276.5 MB<br>ubuntu                     14.04-ssh           6334d3ac099a 7 weeks ago         383.2 MB<br></code></pre></td></tr></table></figure>
<h2 id="4-6-docker-rmi"><a class="header-anchor" href="#4-6-docker-rmi"></a>4.6 docker rmi</h2>
<p>删除一个或者多个镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker rmi --<span class="hljs-built_in">help</span><br>Usage: docker rmi IMAGE [IMAGE...] Remove one or more images<br>  -f, --force=<span class="hljs-literal">false</span> Force removal of the image <span class="hljs-comment"># 强制移除镜像不管是否有容器使用该镜像 --no-prune=false Do not delete untagged parents # 不要删除未标记的父镜像 </span><br></code></pre></td></tr></table></figure>
<h2 id="4-7-docker-run"><a class="header-anchor" href="#4-7-docker-run"></a>4.7 docker run</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --<span class="hljs-built_in">help</span><br>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br>Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> a new container<br>  -a, --attach=[]            Attach to stdin, stdout or stderr.<br>  -c, --cpu-shares=0         CPU shares (relative weight)                       <span class="hljs-comment"># 设置 cpu 使用权重</span><br>  --cap-add=[]               Add Linux capabilities<br>  --cap-drop=[]              Drop Linux capabilities<br>  --cidfile=<span class="hljs-string">&quot;&quot;</span>               Write the container ID to the file                 <span class="hljs-comment"># 把容器 id 写入到指定文件</span><br>  --cpuset=<span class="hljs-string">&quot;&quot;</span>                CPUs <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to allow execution (0-3, 0,1)        <span class="hljs-comment"># cpu 绑定</span><br>  -d, --detach=<span class="hljs-literal">false</span>         Detached mode: Run container <span class="hljs-keyword">in</span> the background, <span class="hljs-built_in">print</span> new container <span class="hljs-built_in">id</span> <span class="hljs-comment"># 后台运行容器</span><br>  --device=[]                Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc)<br>  --dns=[]                   Set custom dns servers                             <span class="hljs-comment"># 设置 dns</span><br>  --dns-search=[]            Set custom dns search domains                      <span class="hljs-comment"># 设置 dns 域搜索</span><br>  -e, --<span class="hljs-built_in">env</span>=[]               Set environment variables                          <span class="hljs-comment"># 定义环境变量</span><br>  --entrypoint=<span class="hljs-string">&quot;&quot;</span>            Overwrite the default entrypoint of the image      <span class="hljs-comment"># ？</span><br>  --env-file=[]              Read <span class="hljs-keyword">in</span> a line delimited file of ENV variables     <span class="hljs-comment"># 从指定文件读取变量值</span><br>  --expose=[]                Expose a port from the container without publishing it to your host    <span class="hljs-comment"># 指定对外提供服务端口</span><br>  -h, --hostname=<span class="hljs-string">&quot;&quot;</span>          Container host name                                <span class="hljs-comment"># 设置容器主机名</span><br>  -i, --interactive=<span class="hljs-literal">false</span>    Keep stdin open even <span class="hljs-keyword">if</span> not attached               <span class="hljs-comment"># 保持标准输出开启即使没有 attached</span><br>  --<span class="hljs-built_in">link</span>=[]                  Add <span class="hljs-built_in">link</span> to another container (name:<span class="hljs-built_in">alias</span>)         <span class="hljs-comment"># 添加链接到另外一个容器</span><br>  --lxc-conf=[]              (lxc exec-driver only) Add custom lxc options --lxc-conf=<span class="hljs-string">&quot;lxc.cgroup.cpuset.cpus = 0,1&quot;</span><br>  -m, --memory=<span class="hljs-string">&quot;&quot;</span>            Memory <span class="hljs-built_in">limit</span> (format: &lt;number&gt;&lt;optional unit&gt;, <span class="hljs-built_in">where</span> unit = b, k, m or g) <span class="hljs-comment"># 内存限制</span><br>  --name=<span class="hljs-string">&quot;&quot;</span>                  Assign a name to the container                     <span class="hljs-comment"># 设置容器名</span><br>  --net=<span class="hljs-string">&quot;bridge&quot;</span>             Set the Network mode <span class="hljs-keyword">for</span> the container             <span class="hljs-comment"># 设置容器网络模式</span><br>                               <span class="hljs-string">&#x27;bridge&#x27;</span>: creates a new network stack <span class="hljs-keyword">for</span> the container on the docker bridge<br>                               <span class="hljs-string">&#x27;none&#x27;</span>: no networking <span class="hljs-keyword">for</span> this container<br>                               <span class="hljs-string">&#x27;container:&lt;name|id&gt;&#x27;</span>: reuses another container network stack<br>                               <span class="hljs-string">&#x27;host&#x27;</span>: use the host network stack inside the container.  Note: the host mode gives the container full access to <span class="hljs-built_in">local</span> system services such as D-bus and is therefore considered insecure.<br>  -P, --publish-all=<span class="hljs-literal">false</span>    Publish all exposed ports to the host interfaces   <span class="hljs-comment"># 自动映射容器对外提供服务的端口</span><br>  -p, --publish=[]           Publish a container<span class="hljs-string">&#x27;s port to the host             # 指定端口映射</span><br><span class="hljs-string">                               format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</span><br><span class="hljs-string">                               (use &#x27;</span>docker port<span class="hljs-string">&#x27; to see the actual mapping)</span><br><span class="hljs-string">  --privileged=false         Give extended privileges to this container         # 提供更多的权限给容器</span><br><span class="hljs-string">  --restart=&quot;&quot;               Restart policy to apply when a container exits (no, on-failure[:max-retry], always)</span><br><span class="hljs-string">  --rm=false                 Automatically remove the container when it exits (incompatible with -d) # 如果容器退出自动移除和 -d 选项冲突</span><br><span class="hljs-string">  --security-opt=[]          Security Options</span><br><span class="hljs-string">  --sig-proxy=true           Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied.</span><br><span class="hljs-string">  -t, --tty=false            Allocate a pseudo-tty                              # 分配伪终端</span><br><span class="hljs-string">  -u, --user=&quot;&quot;              Username or UID                                    # 指定运行容器的用户 uid 或者用户名</span><br><span class="hljs-string">  -v, --volume=[]            Bind mount a volume (e.g., from the host: -v /host:/container, from docker: -v /container)</span><br><span class="hljs-string">                             # 挂载卷</span><br><span class="hljs-string">  --volumes-from=[]          Mount volumes from the specified container(s)      # 从指定容器挂载卷</span><br><span class="hljs-string">  -w, --workdir=&quot;&quot;           Working directory inside the container             # 指定容器工作目录</span><br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker images ubuntu<br>REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu              14.04               e54ca5efa2e9 4 weeks ago         276.5 MB<br>... ... <br>$ sudo docker run -t -i -c 100 -m 512MB -h test1 -d --name=<span class="hljs-string">&quot;docker_test1&quot;</span> ubuntu /bin/bash <br><span class="hljs-comment"># 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器 a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5 </span><br>$ sudo docker ps <br>CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES<br>a424ca613c9f        ubuntu:14.04    /bin/bash 6 seconds ago       Up 5 seconds                    docker_test1 <br>$ sudo docker attach docker_test1<br>root@test1:/<span class="hljs-comment"># pwd </span><br>/<br>root@test1:/<span class="hljs-comment"># exit </span><br><span class="hljs-built_in">exit</span> <br></code></pre></td></tr></table></figure>
<p>关于cpu优先级:</p>
<blockquote>
<p>By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time -<a href="https://wiki.archlinux.org/index.php/cgroups">archlinux cgroups</a></p>
</blockquote>
<h2 id="4-8-docker-start-stop-kill…-…"><a class="header-anchor" href="#4-8-docker-start-stop-kill…-…"></a>4.8 docker start|stop|kill… …</h2>
<p>dockerstart|stop|kill|restart|pause|unpause|rm|commit|inspect|logs</p>
<ul>
<li>
<p>docker start CONTAINER [CONTAINER…]</p>
<ul>
<li># 运行一个或多个停止的容器</li>
</ul>
</li>
<li>
<p>docker stop CONTAINER [CONTAINER…]</p>
<ul>
<li># 停掉一个或多个运行的容器-t选项可指定超时时间</li>
</ul>
</li>
<li>
<p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p>
<ul>
<li># 默认 kill 发送 SIGKILL 信号-s可以指定发送 kill 信号类型</li>
</ul>
</li>
<li>
<p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p>
<ul>
<li># 重启一个或多个运行的容器-t选项可指定超时时间</li>
</ul>
</li>
<li>
<p>docker pause CONTAINER</p>
<ul>
<li># 暂停一个容器，方便 commit</li>
</ul>
</li>
<li>
<p>docker unpause CONTAINER</p>
<ul>
<li># 继续暂停的容器</li>
</ul>
</li>
<li>
<p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p>
<ul>
<li># 移除一个或多个容器</li>
<li>-f, --force=false Force removal of running container</li>
<li>-l, --link=false Remove the specified link and not the underlying container</li>
<li>-v, --volumes=false Remove the volumes associated with the container</li>
</ul>
</li>
<li>
<p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>
<ul>
<li># 提交指定容器为镜像</li>
<li>-a, --author=“” Author (e.g., “John Hannibal Smith <a href="mailto:hannibal@a-team.com">hannibal@a-team.com</a>”)</li>
<li>-m, --message=“” Commit message</li>
<li>-p, --pause=true Pause container during commit
<ul>
<li># 默认 commit 是暂停状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE…]</p>
<ul>
<li># 查看容器或者镜像的详细信息</li>
</ul>
</li>
<li>
<p>docker logs CONTAINER</p>
<ul>
<li># 输出指定容器日志信息</li>
<li>-f, --follow=false Follow log output
<ul>
<li># 类似 tail -f</li>
</ul>
</li>
<li>-t, --timestamps=false Show timestamps</li>
<li>–tail=“all” Output the specified number of lines at the end of logs (defaults to all logs)</li>
</ul>
</li>
</ul>
<p>参考文档：<a href="https://docs.docker.com/reference/run/">Docker Run Reference</a></p>
<h2 id="4-9-Docker-1-3-新增特性和命令"><a class="header-anchor" href="#4-9-Docker-1-3-新增特性和命令"></a>4.9 Docker 1.3 新增特性和命令</h2>
<h3 id="Digital-Signature-Verification"><a class="header-anchor" href="#Digital-Signature-Verification"></a>Digital Signature Verification</h3>
<p>Docker 1.3 版本将使用数字签名自动验证所有官方库的来源和完整性，如果一个官方镜像被篡改或者被破坏，目前 Docker 只会对这种情况发出警告而并不阻止容器的运行。</p>
<h3 id="Inject-new-processes-withdocker-exec"><a class="header-anchor" href="#Inject-new-processes-withdocker-exec"></a>Inject new processes withdocker exec</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> --<span class="hljs-built_in">help</span><br>Usage: docker <span class="hljs-built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...] Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> an existing container<br>  -d, --detach=<span class="hljs-literal">false</span> Detached mode: run <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> the background<br>  -i, --interactive=<span class="hljs-literal">false</span> Keep STDIN open even <span class="hljs-keyword">if</span> not attached<br>  -t, --<span class="hljs-built_in">tty</span>=<span class="hljs-literal">false</span> Allocate a pseudo-TTY<br></code></pre></td></tr></table></figure>
<p>为了简化调试，可以使用docker exec命令通过 Docker API 和 CLI 在运行的容器上运行程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it ubuntu_bash bash<br></code></pre></td></tr></table></figure>
<p>上例将在容器 ubuntu_bash 中创建一个新的 Bash 会话。</p>
<h3 id="Tune-container-lifecycles-withdocker-create"><a class="header-anchor" href="#Tune-container-lifecycles-withdocker-create"></a>Tune container lifecycles withdocker create</h3>
<p>我们可以通过docker run <image name>命令创建一个容器并运行其中的程序，因为有很多用户要求创建容器的时候不启动容器，所以docker create应运而生了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker create -t -i fedora bash<br>6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752<br></code></pre></td></tr></table></figure>
<p>上例创建了一个可写的容器层 (并且打印出容器 ID)，但是并不运行它，可以使用以下命令运行该容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker start -a -i 6d8af538ec5<br>bash-4.2<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<h3 id="Security-Options"><a class="header-anchor" href="#Security-Options"></a>Security Options</h3>
<p>通过–security-opt选项，运行容器时用户可自定义 SELinux 和 AppArmor 卷标和配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker run --security-opt label:<span class="hljs-built_in">type</span>:svirt_apache -i -t centos \ bash<br></code></pre></td></tr></table></figure>
<p>上例只允许容器监听在 Apache 端口，这个选项的好处是用户不需要运行 docker 的时候指定–privileged选项，降低安全风险。</p>
<p>参考文档：<a href="http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/">Docker 1.3: signed images, process injection, security options, Mac shared directories</a></p>
<h2 id="4-10-Docker-1-5-新特性"><a class="header-anchor" href="#4-10-Docker-1-5-新特性"></a>4.10 Docker 1.5 新特性</h2>
<p>参考文档：<a href="http://dockerone.com/article/202">Docker 1.5 新特性</a></p>
<h1 id="五、Docker-端口映射"><a class="header-anchor" href="#五、Docker-端口映射"></a>五、Docker 端口映射</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip </span><br>$ sudo docker inspect &lt;container_id&gt; | grep IPAddress | <span class="hljs-built_in">cut</span> -d ’<span class="hljs-string">&quot;’ -f 4</span><br></code></pre></td></tr></table></figure>
<p>无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。</p>
<p>Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。</p>
<h2 id="5-1-自动映射端口"><a class="header-anchor" href="#5-1-自动映射端口"></a>5.1 自动映射端口</h2>
<p>-P使用时需要指定–expose选项，指定需要对外提供服务的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -P --expose 22 --name server  ubuntu:14.04<br></code></pre></td></tr></table></figure>
<p>使用docker run -P自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000…49900) 自动选择，你可以通过docker ps、docker inspect &lt;container_id&gt;或者docker port &lt;container_id&gt; <port>确定具体的绑定信息。</p>
<h2 id="5-2-绑定端口到指定接口"><a class="header-anchor" href="#5-2-绑定端口到指定接口"></a>5.2 绑定端口到指定接口</h2>
<p>基本语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;<br></code></pre></td></tr></table></figure>
<p>默认不指定绑定 ip 则监听所有网络接口。</p>
<h3 id="绑定-TCP-端口"><a class="header-anchor" href="#绑定-TCP-端口"></a>绑定 TCP 端口</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine. </span><br>$ sudo docker run -p 127.0.0.1:80:8080 &lt;image&gt; &lt;cmd&gt; <span class="hljs-comment"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine. </span><br>$ sudo docker run -p 127.0.0.1::8080 &lt;image&gt; &lt;cmd&gt; <span class="hljs-comment"># Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine. </span><br>$ sudo docker run -p 80:8080 &lt;image&gt; &lt;cmd&gt; <span class="hljs-comment"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces </span><br>$ sudo docker run -p 8080 &lt;image&gt; &lt;cmd&gt;<br></code></pre></td></tr></table></figure>
<h3 id="绑定-UDP-端口"><a class="header-anchor" href="#绑定-UDP-端口"></a>绑定 UDP 端口</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine. </span><br>$ sudo docker run -p 127.0.0.1:53:5353/udp &lt;image&gt; &lt;cmd&gt;<br></code></pre></td></tr></table></figure>
<h1 id="六、Docker-网络配置"><a class="header-anchor" href="#六、Docker-网络配置"></a>六、Docker 网络配置</h1>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091034_634.png" alt="非常详细的 Docker 学习笔记"></p>
<p>图: <a href="http://www.slideshare.net/janghoonsim/docker-container-and-lightweight-virtualization">Docker - container and lightweight virtualization</a></p>
<p>Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：</p>
<ul>
<li>creates the docker0 bridge if not present
<ul>
<li># 如果 docker0 不存在则创建</li>
</ul>
</li>
<li>searches for an IP address range which doesn’t overlap with an existing route
<ul>
<li># 搜索一个与当前路由不冲突的 ip 段</li>
</ul>
</li>
<li>picks an IP in the selected range
<ul>
<li># 在确定的范围中选择 ip</li>
</ul>
</li>
<li>assigns this IP to the docker0 bridge
<ul>
<li># 绑定 ip 到 docker0</li>
</ul>
</li>
</ul>
<h2 id="6-1-Docker-四种网络模式"><a class="header-anchor" href="#6-1-Docker-四种网络模式"></a>6.1 Docker 四种网络模式</h2>
<p>四种网络模式摘自 <a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker 网络详解及 pipework 源码解读与实践</a></p>
<p>docker run 创建 Docker 容器时，可以用 --net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p>
<ul>
<li>host 模式，使用 --net=host 指定。</li>
<li>container 模式，使用 --net=container:NAMEorID 指定。</li>
<li>none 模式，使用 --net=none 指定。</li>
<li>bridge 模式，使用 --net=bridge 指定，默认设置。</li>
</ul>
<h3 id="host-模式"><a class="header-anchor" href="#host-模式"></a>host 模式</h3>
<p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="container-模式"><a class="header-anchor" href="#container-模式"></a>container 模式</h3>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h3 id="none模式"><a class="header-anchor" href="#none模式"></a>none模式</h3>
<p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<h3 id="bridge模式"><a class="header-anchor" href="#bridge模式"></a>bridge模式</h3>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_252.png" alt="非常详细的 Docker 学习笔记"></p>
<p>图:<a href="http://www.wickedawesometech.us/2014/07/the-container-world-part-2-networking.html">The Container World | Part 2 Networking</a></p>
<p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p>
<h2 id="6-2-列出当前主机网桥"><a class="header-anchor" href="#6-2-列出当前主机网桥"></a>6.2 列出当前主机网桥</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo brctl show <span class="hljs-comment"># brctl 工具依赖 bridge-utils 软件包 bridge name bridge id STP enabled interfaces</span><br>docker0 8000.000000000000 no<br></code></pre></td></tr></table></figure>
<h2 id="6-3-查看当前-docker0-ip"><a class="header-anchor" href="#6-3-查看当前-docker0-ip"></a>6.3 查看当前 docker0 ip</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo ifconfig docker0<br>docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx<br>inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0<br></code></pre></td></tr></table></figure>
<p>在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。</p>
<h2 id="6-4-运行一个容器"><a class="header-anchor" href="#6-4-运行一个容器"></a>6.4 运行一个容器</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d ubuntu /bin/bash<br>52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4 <br>$ sudo brctl show<br>bridge name bridge <span class="hljs-built_in">id</span> STP enabled interfaces<br>docker0 8000.fef213db5a66 no vethQCDY1N<br></code></pre></td></tr></table></figure>
<p>以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。</p>
<h3 id="使用特定范围的-IP"><a class="header-anchor" href="#使用特定范围的-IP"></a>使用特定范围的 IP</h3>
<p>Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过-b选项自定义桥接网卡，需要安装bridge-utils软件包。</p>
<p>基本步骤如下：</p>
<ul>
<li>
<p>ensure Docker is stopped</p>
<ul>
<li># 确保 docker 的进程是停止的</li>
</ul>
</li>
<li>
<p>create your own bridge (bridge0 for example)</p>
<ul>
<li># 创建自定义网桥</li>
</ul>
</li>
<li>
<p>assign a specific IP to this bridge</p>
<ul>
<li># 给网桥分配特定的 ip</li>
</ul>
</li>
<li>
<p>start Docker with the -b=bridge0 parameter</p>
<ul>
<li># 以 -b 的方式指定网桥</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Stopping Docker and removing docker0 </span><br>$ sudo service docker stop <br>$ sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev docker0 down <br>$ sudo brctl delbr docker0 <span class="hljs-comment"># Create our own bridge </span><br>$ sudo brctl addbr bridge0 <br>$ sudo ip addr add 192.168.5.1/24 dev bridge0 <br>$ sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev bridge0 up <span class="hljs-comment"># Confirming that our bridge is up and running </span><br>$ ip addr show bridge0<br>4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default<br>    <span class="hljs-built_in">link</span>/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.5.1/24 scope global bridge0<br>       valid_lft forever preferred_lft forever <span class="hljs-comment"># Tell Docker about it and restart (on Ubuntu) </span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;DOCKER_OPTS=&quot;-b=bridge0&quot;&#x27;</span> &gt;&gt; /etc/default/docker <br>$ sudo service docker start<br></code></pre></td></tr></table></figure>
<p>参考文档: <a href="https://docs.docker.com/articles/networking/">Network Configuration</a></p>
<h2 id="6-5-不同主机间容器通信"><a class="header-anchor" href="#6-5-不同主机间容器通信"></a>6.5 不同主机间容器通信</h2>
<p>不同容器之间的通信可以借助于 pipework 这个工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/jpetazzo/pipework.git<br>$ sudo <span class="hljs-built_in">cp</span> -rp pipework/pipework /usr/local/bin/<br></code></pre></td></tr></table></figure>
<h3 id="安装相应依赖软件"><a class="header-anchor" href="#安装相应依赖软件"></a>安装相应依赖软件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get install iputils-arping bridge-utils -y<br></code></pre></td></tr></table></figure>
<h3 id="桥接网络"><a class="header-anchor" href="#桥接网络"></a>桥接网络</h3>
<p>桥接网络可以参考 <a href="https://github.com/opskumu/Day/blob/master/tips/tips.md">日常问题处理 Tips</a> 关于桥接的配置说明，这里不再赘述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># brctl show</span><br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>br0             8000.000c291412cd       no              eth0<br>docker0         8000.56847afe9799       no              vetheb48029<br></code></pre></td></tr></table></figure>
<p>可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。</p>
<ul>
<li>ubuntu</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo service docker stop<br>$ sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev docker0 down<br>$ sudo brctl delbr docker0<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;DOCKER_OPTS=&quot;-b=br0&quot;&#x27;</span> &gt;&gt; /etc/default/docker<br>$ sudo service docker start<br></code></pre></td></tr></table></figure>
<ul>
<li>CentOS 7/RHEL 7</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo systemctl stop docker<br>$ sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev docker0 down<br>$ sudo brctl delbr docker0<br>$ <span class="hljs-built_in">cat</span> /etc/sysconfig/docker | grep <span class="hljs-string">&#x27;OPTIONS=&#x27;</span><br>OPTIONS=--selinux-enabled -b=br0 -H fd://<br>$ sudo systemctl start docker<br></code></pre></td></tr></table></figure>
<h3 id="pipework"><a class="header-anchor" href="#pipework"></a>pipework</h3>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_900.png" alt="非常详细的 Docker 学习笔记"></p>
<p>不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/jpetazzo/pipework.git<br>$ sudo <span class="hljs-built_in">cp</span> -rp pipework/pipework /usr/local/bin/<br>$ pipework <br>Syntax:<br>pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; &lt;ipaddr&gt;/&lt;subnet&gt;[@default_gateway] [macaddr][@vlan]<br>pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; dhcp [macaddr][@vlan]<br>pipework --<span class="hljs-built_in">wait</span> [-i containerinterface]<br></code></pre></td></tr></table></figure>
<p>如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上–net=none，防止自动分配的 IP 在局域网中有冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --<span class="hljs-built_in">rm</span> -ti --net=none ubuntu:14.04 /bin/bash<br>root@a46657528059:/<span class="hljs-comment">#</span><br>$                  <span class="hljs-comment"># Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态</span><br>$ sudo docker  ps<br>CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES<br>a46657528059    ubuntu:14.04   <span class="hljs-string">&quot;/bin/bash&quot;</span>   4 minutes ago   Up 4 minutes               hungry_lalande<br>$ sudo pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2 <br><span class="hljs-comment"># 默认不指定网卡设备名，则默认添加为 eth1</span><br><span class="hljs-comment"># 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=true 权限在容器中手动添加，</span><br><span class="hljs-comment"># 但这种安全性有缺陷，可以通过 ip netns 操作</span><br>$ sudo docker attach a46657528059<br>root@a46657528059:/<span class="hljs-comment"># ifconfig eth0</span><br>eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d  <br>          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0<br>          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:8 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000 <br>          RX bytes:648 (648.0 B)  TX bytes:690 (690.0 B)<br><br>root@a46657528059:/<span class="hljs-comment"># route -n</span><br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0<br>192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0<br></code></pre></td></tr></table></figure>
<p>使用ip netns添加静态路由，避免创建容器使用–privileged=true选项造成一些不必要的安全问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker inspect --format=<span class="hljs-string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span> a46657528059 <span class="hljs-comment"># 获取指定容器 pid</span><br>6350<br>$ sudo <span class="hljs-built_in">ln</span> -s /proc/6350/ns/net /var/run/netns/6350<br>$ sudo ip netns <span class="hljs-built_in">exec</span> 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2<br>$ sudo ip netns <span class="hljs-built_in">exec</span> 6350 ip route    <span class="hljs-comment"># 添加成功</span><br>192.168.0.0/16 via 192.168.115.2 dev eth0 <br>... ...<br></code></pre></td></tr></table></figure>
<p>在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。</p>
<p>另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：</p>
<ul>
<li><a href="https://github.com/jpetazzo/pipework">Pipework 官方文档</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker 网络详解及 pipework 源码解读与实践</a></li>
</ul>
<h1 id="七、Dockerfile"><a class="header-anchor" href="#七、Dockerfile"></a>七、Dockerfile</h1>
<p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过docker build命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p>
<p>Dockerfile 有以下指令选项:</p>
<ul>
<li>FROM</li>
<li>MAINTAINER</li>
<li>RUN</li>
<li>CMD</li>
<li>EXPOSE</li>
<li>ENV</li>
<li>ADD</li>
<li>COPY</li>
<li>ENTRYPOINT</li>
<li>VOLUME</li>
<li>USER</li>
<li>WORKDIR</li>
<li>ONBUILD</li>
</ul>
<h2 id="7-1-FROM"><a class="header-anchor" href="#7-1-FROM"></a>7.1 FROM</h2>
<p>用法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM &lt;image&gt;<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM &lt;image&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li>
<li>FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始。</li>
<li>FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。</li>
<li>如果FROM语句没有指定镜像标签，则默认使用latest标签。</li>
</ul>
<h2 id="7-2-MAINTAINER"><a class="header-anchor" href="#7-2-MAINTAINER"></a>7.2 MAINTAINER</h2>
<p>用法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">MAINTAINER &lt;name&gt;<br></code></pre></td></tr></table></figure>
<p>指定创建镜像的用户</p>
<p>RUN 有两种使用方式</p>
<ul>
<li>RUN</li>
<li>RUN <a href="http://opskumu.github.io/exec%20form">“executable”, “param1”, “param2”</a></li>
</ul>
<p>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。</p>
<p>exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">RUN [ <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>&quot;</span> ]<br></code></pre></td></tr></table></figure>
<p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">RUN [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>&quot;</span> ]<br></code></pre></td></tr></table></figure>
<p>RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build --no-cache，如此便不会缓存。</p>
<h2 id="7-3-CMD"><a class="header-anchor" href="#7-3-CMD"></a>7.3 CMD</h2>
<p>CMD有三种使用方式:</p>
<ul>
<li>CMD <a href="http://opskumu.github.io/exec%20form,%20this%20is%20the%20preferred%20form,%20%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9">“executable”,“param1”,“param2”</a></li>
<li>CMD <a href="http://opskumu.github.io/as%20default%20parameters%20to%20%60ENTRYPOINT%60">“param1”,“param2”</a></li>
<li>CMD command param1 param2 (shell form)</li>
</ul>
<p>CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p>
<p>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p>
<blockquote>
<p>CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p>
</blockquote>
<h2 id="7-4-EXPOSE"><a class="header-anchor" href="#7-4-EXPOSE"></a>7.4 EXPOSE</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">EXPOSE &lt;port&gt; [&lt;port&gt;...]<br></code></pre></td></tr></table></figure>
<p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。</p>
<h2 id="7-5-ENV"><a class="header-anchor" href="#7-5-ENV"></a>7.5 ENV</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ENV &lt;key&gt; &lt;value&gt;       <span class="hljs-comment"># 只能设置一个变量</span><br>ENV &lt;key&gt;=&lt;value&gt; ...   <span class="hljs-comment"># 允许一次设置多个变量</span><br></code></pre></td></tr></table></figure>
<p>指定一个环节变量，会被后续RUN指令使用，并在容器运行时保留。</p>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ENV myName=<span class="hljs-string">&quot;John Doe&quot;</span> myDog=Rex\ The\ Dog \<br>    myCat=fluffy<br></code></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ENV myName John Doe<br>ENV myDog Rex The Dog<br>ENV myCat fluffy<br></code></pre></td></tr></table></figure>
<h2 id="7-6-ADD"><a class="header-anchor" href="#7-6-ADD"></a>7.6 ADD</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ADD &lt;src&gt;... &lt;dest&gt;<br></code></pre></td></tr></table></figure>
<p>ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。</p>
<p>支持通过 GO 的正则模糊匹配，具体规则可参见 <a href="http://golang.org/pkg/path/filepath/#Match">Go filepath.Match</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ADD hom* /mydir/        <span class="hljs-comment"># adds all files starting with &quot;hom&quot;</span><br>ADD hom?.txt /mydir/    <span class="hljs-comment"># ? is replaced with any single character</span><br></code></pre></td></tr></table></figure>
<ul>
<li>路径必须是绝对路径，如果 不存在，会自动创建对应目录</li>
<li>路径必须是 Dockerfile 所在路径的相对路径</li>
<li>如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li>
</ul>
<h2 id="7-7-COPY"><a class="header-anchor" href="#7-7-COPY"></a>7.7 COPY</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">COPY &lt;src&gt;... &lt;dest&gt;<br></code></pre></td></tr></table></figure>
<p>COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</p>
<h2 id="7-8-ENTRYPOINT"><a class="header-anchor" href="#7-8-ENTRYPOINT"></a>7.8 ENTRYPOINT</h2>
<ul>
<li>ENTRYPOINT <a href="http://opskumu.github.io/the%20preferred%20exec%20form%EF%BC%8C%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9">“executable”, “param1”, “param2”</a></li>
<li>ENTRYPOINT command param1 param2 (shell form)</li>
</ul>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用docker run --entrypoint选项。</p>
<p>每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</p>
<h3 id="Exec-form-ENTRYPOINT-例子"><a class="header-anchor" href="#Exec-form-ENTRYPOINT-例子"></a>Exec form ENTRYPOINT 例子</h3>
<p>通过ENTRYPOINT使用 exec form 方式设置稳定的默认命令和选项，而使用CMD添加默认之外经常被改动的选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM ubuntu<br>ENTRYPOINT [<span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>]<br>CMD [<span class="hljs-string">&quot;-c&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>通过 Dockerfile 使用ENTRYPOINT展示前台运行 Apache 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM debian:stable<br>RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2<br>EXPOSE 80 443<br>VOLUME [<span class="hljs-string">&quot;/var/www&quot;</span>, <span class="hljs-string">&quot;/var/log/apache2&quot;</span>, <span class="hljs-string">&quot;/etc/apache2&quot;</span>]<br>ENTRYPOINT [<span class="hljs-string">&quot;/usr/sbin/apache2ctl&quot;</span>, <span class="hljs-string">&quot;-D&quot;</span>, <span class="hljs-string">&quot;FOREGROUND&quot;</span>]<br></code></pre></td></tr></table></figure>
<h3 id="Shell-form-ENTRYPOINT-例子"><a class="header-anchor" href="#Shell-form-ENTRYPOINT-例子"></a>Shell form ENTRYPOINT 例子</h3>
<p>这种方式会在/bin/sh -c中执行，会忽略任何CMD或者docker run命令行选项，为了确保docker stop能够停止长时间运行ENTRYPOINT的容器，确保执行的时候使用exec选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM ubuntu<br>ENTRYPOINT <span class="hljs-built_in">exec</span> top -b<br></code></pre></td></tr></table></figure>
<p>如果在ENTRYPOINT忘记使用exec选项，则可以使用CMD补上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM ubuntu<br>ENTRYPOINT top -b<br>CMD --ignored-param1 <span class="hljs-comment"># --ignored-param2 ... --ignored-param3 ... 依此类推</span><br></code></pre></td></tr></table></figure>
<h2 id="7-9-VOLUME"><a class="header-anchor" href="#7-9-VOLUME"></a>7.9 VOLUME</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">VOLUME [<span class="hljs-string">&quot;/data&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p>
<h2 id="7-10-USER"><a class="header-anchor" href="#7-10-USER"></a>7.10 USER</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">USER daemon<br></code></pre></td></tr></table></figure>
<p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p>
<h2 id="7-11-WORKDIR"><a class="header-anchor" href="#7-11-WORKDIR"></a>7.11 WORKDIR</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">WORKDIR /path/to/workdir<br></code></pre></td></tr></table></figure>
<p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br>RUN <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure>
<p>最终路径是/a/b/c。</p>
<p>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ENV DIRPATH /path<br>WORKDIR <span class="hljs-variable">$DIRPATH</span>/<span class="hljs-variable">$DIRNAME</span><br></code></pre></td></tr></table></figure>
<p>最终路径则为 /path/$DIRNAME。</p>
<h2 id="7-12-ONBUILD"><a class="header-anchor" href="#7-12-ONBUILD"></a>7.12 ONBUILD</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ONBUILD [INSTRUCTION]<br></code></pre></td></tr></table></figure>
<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[...]<br>ONBUILD ADD . /app/src<br>ONBUILD RUN /usr/local/bin/python-build --<span class="hljs-built_in">dir</span> /app/src<br>[...]<br></code></pre></td></tr></table></figure>
<p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Automatically run the following</span><br>ADD . /app/src<br>RUN /usr/local/bin/python-build --<span class="hljs-built_in">dir</span> /app/src<br></code></pre></td></tr></table></figure>
<p>使用ONBUILD指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p>
<h2 id="7-13-Dockerfile-Examples"><a class="header-anchor" href="#7-13-Dockerfile-Examples"></a>7.13 Dockerfile Examples</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Nginx</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># VERSION               0.0.1</span><br>FROM      ubuntu<br>MAINTAINER Victor Vieux &lt;victor@docker.com&gt;<br>RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server<br>  <br><span class="hljs-comment"># Firefox over VNC</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># VERSION               0.3</span><br>FROM ubuntu<br><span class="hljs-comment"># Install vnc, xvfb in order to create a &#x27;fake&#x27; display and firefox</span><br>RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox<br>RUN <span class="hljs-built_in">mkdir</span> ~/.vnc<br><span class="hljs-comment"># Setup a password</span><br>RUN x11vnc -storepasswd 1234 ~/.vnc/passwd<br><span class="hljs-comment"># Autostart firefox (might not be the best way, but it does the trick)</span><br>RUN bash -c <span class="hljs-string">&#x27;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#x27;</span><br>EXPOSE 5900<br>CMD    [<span class="hljs-string">&quot;x11vnc&quot;</span>, <span class="hljs-string">&quot;-forever&quot;</span>, <span class="hljs-string">&quot;-usepw&quot;</span>, <span class="hljs-string">&quot;-create&quot;</span>]<br>  <br><span class="hljs-comment"># Multiple images example</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># VERSION               0.1</span><br>FROM ubuntu<br>RUN <span class="hljs-built_in">echo</span> foo &gt; bar<br><span class="hljs-comment"># Will output something like ===&gt; 907ad6c2736f</span><br>FROM ubuntu<br>RUN <span class="hljs-built_in">echo</span> moo &gt; oink<br><span class="hljs-comment"># Will output something like ===&gt; 695d7793cbe4</span><br> <br><span class="hljs-comment"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span><br><span class="hljs-comment"># /oink.</span><br></code></pre></td></tr></table></figure>
<h2 id="7-14-docker-build"><a class="header-anchor" href="#7-14-docker-build"></a>7.14 docker build</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker build --<span class="hljs-built_in">help</span><br>Usage: docker build [OPTIONS] PATH | URL | -<br>Build a new image from the <span class="hljs-built_in">source</span> code at PATH<br>  --force-rm=<span class="hljs-literal">false</span>     Always remove intermediate containers, even after unsuccessful builds <span class="hljs-comment"># 移除过渡容器，即使构建失败</span><br>  --no-cache=<span class="hljs-literal">false</span>     Do not use cache when building the image                              <span class="hljs-comment"># 不实用 cache        </span><br>  -q, --quiet=<span class="hljs-literal">false</span>    Suppress the verbose output generated by the containers               <br>  --<span class="hljs-built_in">rm</span>=<span class="hljs-literal">true</span>            Remove intermediate containers after a successful build               <span class="hljs-comment"># 构建成功后移除过渡层容器</span><br>  -t, --tag=<span class="hljs-string">&quot;&quot;</span>         Repository name (and optionally a tag) to be applied to the resulting image <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> of success<br></code></pre></td></tr></table></figure>
<p>参考文档:<a href="https://docs.docker.com/reference/builder/">Dockerfile Reference</a></p>
<h2 id="7-15-dockerfile-最佳实践"><a class="header-anchor" href="#7-15-dockerfile-最佳实践"></a>7.15 dockerfile 最佳实践</h2>
<ul>
<li>使用.dockerignore文件</li>
</ul>
<p>为了在docker build过程中更快上传和更加高效，应该使用一个.dockerignore文件用来排除构建镜像时不需要的文件或目录。例如,除非.git在构建过程中需要用到，否则你应该将它添加到.dockerignore文件中，这样可以节省很多时间。</p>
<ul>
<li>避免安装不必要的软件包</li>
</ul>
<p>为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。</p>
<ul>
<li>每个容器都跑一个进程</li>
</ul>
<p>在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 <a href="https://docs.docker.com/userguide/dockerlinks/">Linking Containers Together</a>。</p>
<ul>
<li>最小化层</li>
</ul>
<p>我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于Dockerfile，应该找到可读性和最小化层之间的平衡。</p>
<ul>
<li>多行参数排序</li>
</ul>
<p>如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用\换行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">RUN apt-get update &amp;&amp; apt-get install -y \<br>  bzr \<br>  cvs \<br>  git \<br>  mercurial \<br>  subversion<br></code></pre></td></tr></table></figure>
<ul>
<li>创建缓存</li>
</ul>
<p>镜像构建过程中会按照Dockerfile的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在docker build时添加–no-cache=true选项。</p>
<p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比Dockerfile指令和子镜像就足够了。ADD和COPY指令除外，执行ADD和COPY时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。RUN apt-get -y update命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p>
<blockquote>
<p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p>
</blockquote>
<h3 id="Dockerfile-指令"><a class="header-anchor" href="#Dockerfile-指令"></a>Dockerfile 指令</h3>
<ul>
<li>FROM: 只要可能就使用官方镜像库作为基础镜像</li>
<li>RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的RUN语句使用\分隔符分成多行
<ul>
<li>不建议RUN apt-get update独立成行，否则如果后续包有更新，那么也不会再执行更新</li>
<li>避免使用RUN apt-get upgrade或者dist-upgrade，很多必要的包在一个非privileged权限的容器里是无法升级的。如果知道某个包更新，使用apt-get install -y xxx</li>
<li>标准写法
<ul>
<li>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">RUN apt-get update &amp;&amp; apt-get install -y \<br>    aufs-tools \<br>    automake \<br>    btrfs-tools \<br>    build-essential \<br>    curl \<br>    dpkg-sig \<br>    git \<br>    iptables \<br>    libapparmor-dev \<br>    libcap-dev \<br>    libsqlite3-dev \<br>    lxc=1.0* \<br>    mercurial \<br>    parallel \<br>    reprepro \<br>    ruby1.9.1 \<br>    ruby1.9.1-dev \<br>    s3cmd=1.1.0*<br></code></pre></td></tr></table></figure>
<ul>
<li>CMD: 推荐使用CMD [“executable”, “param1”, “param2”…]这种格式，CMD [“param”, “param”]则配合ENTRYPOINT使用</li>
<li>EXPOSE: Dockerfile 指定要公开的端口，使用docker run时指定映射到宿主机的端口即可</li>
<li>ENV: 为了使新的软件更容易运行，可以使用ENV更新PATH变量。如ENV PATH /usr/local/nginx/bin:$PATH确保CMD [“nginx”]即可运行</li>
</ul>
<p>ENV也可以这样定义变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ENV PG_MAJOR 9.3<br>ENV PG_VERSION 9.3.4<br>RUN curl -SL http://example.com/postgres-<span class="hljs-variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …<br>ENV PATH /usr/local/postgres-<span class="hljs-variable">$PG_MAJOR</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>
<ul>
<li>ADDorCOPY:ADD比COPY多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li>
</ul>
<p>如不推荐这种方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ADD http://example.com/big.tar.xz /usr/src/things/<br>RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things<br>RUN make -C /usr/src/things all<br></code></pre></td></tr></table></figure>
<p>推荐使用 curl 或者 wget 替换，使用如下方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">RUN <span class="hljs-built_in">mkdir</span> -p /usr/src/things \<br>    &amp;&amp; curl -SL http://example.com/big.tar.gz \<br>    | tar -xJC /usr/src/things \<br>    &amp;&amp; make -C /usr/src/things all<br></code></pre></td></tr></table></figure>
<p>如果不需要添加 tar 文件，推荐使用COPY。</p>
<p>参考文档:</p>
<ul>
<li><a href="https://docs.docker.com/articles/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
<li><a href="http://dockerone.com/article/131">Dockerfile最佳实践（一）</a></li>
<li><a href="http://dockerone.com/article/132">Dockerfile最佳实践（二）</a></li>
</ul>
<h1 id="八、容器数据管理"><a class="header-anchor" href="#八、容器数据管理"></a>八、容器数据管理</h1>
<p>docker管理数据的方式有两种：</p>
<ul>
<li>数据卷</li>
<li>数据卷容器</li>
</ul>
<h2 id="8-1-数据卷"><a class="header-anchor" href="#8-1-数据卷"></a>8.1 数据卷</h2>
<p>数据卷是一个或多个容器专门指定绕过Union File System的目录，为持续性或共享数据提供一些有用的功能：</p>
<ul>
<li>数据卷可以在容器间共享和重用</li>
<li>数据卷数据改变是直接修改的</li>
<li>数据卷数据改变不会被包括在容器中</li>
<li>数据卷是持续性的，直到没有容器使用它们</li>
</ul>
<h3 id="添加一个数据卷"><a class="header-anchor" href="#添加一个数据卷"></a>添加一个数据卷</h3>
<p>你可以使用-v选项添加一个数据卷，或者可以使用多次-v选项为一个 docker 容器运行挂载多个数据卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash <span class="hljs-comment"># 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷 bash-4.1# ls -ld /data/</span><br>drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/<br>bash-4.1<span class="hljs-comment"># df -Th</span><br>Filesystem    Type    Size  Used Avail Use% Mounted on<br>... ...<br>              ext4     91G  4.6G   82G   6% /data<br></code></pre></td></tr></table></figure>
<p>创建的数据卷可以通过docker inspect获取宿主机对应路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker inspect data<br>... ... <span class="hljs-string">&quot;Volumes&quot;</span>: &#123; <span class="hljs-string">&quot;/data&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9&quot;</span> &#125;, <span class="hljs-comment"># 可以看到创建的数据卷宿主机路径 ... ...</span><br></code></pre></td></tr></table></figure>
<p>或者直接指定获取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker inspect --format=<span class="hljs-string">&quot;&#123;&#123; .Volumes &#125;&#125;&quot;</span> data<br>map[/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9]<br></code></pre></td></tr></table></figure>
<h3 id="挂载宿主机目录为一个数据卷"><a class="header-anchor" href="#挂载宿主机目录为一个数据卷"></a>挂载宿主机目录为一个数据卷</h3>
<p>-v选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --name web -v /source/:/web -t -i ubuntu:14.04 /bin/bash<br>bash-4.1<span class="hljs-comment"># ls -ld /web/</span><br>drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/<br>bash-4.1<span class="hljs-comment"># df -Th</span><br>... ...<br>              ext4     91G  4.6G   82G   6% /web<br>bash-4.1<span class="hljs-comment"># exit </span><br></code></pre></td></tr></table></figure>
<p>默认挂载卷是可读写的，可以在挂载时指定只读</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --<span class="hljs-built_in">rm</span> --name <span class="hljs-built_in">test</span> -v /source/:/test:ro -t -i ubuntu:14.04 /bin/bash<br></code></pre></td></tr></table></figure>
<h2 id="8-2-创建和挂载一个数据卷容器"><a class="header-anchor" href="#8-2-创建和挂载一个数据卷容器"></a>8.2 创建和挂载一个数据卷容器</h2>
<p>如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。</p>
<p>创建数据卷容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d -v /test --name <span class="hljs-built_in">test</span> ubuntu:14.04 <span class="hljs-built_in">echo</span> hello<br></code></pre></td></tr></table></figure>
<p>使用–volumes-from选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d --volumes-from <span class="hljs-built_in">test</span> --name test1 ubuntu:14.04 /bin/bash<br></code></pre></td></tr></table></figure>
<p>添加另一个容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d --volumes-from <span class="hljs-built_in">test</span> --name test2 ubuntu:14.04 /bin/bash<br></code></pre></td></tr></table></figure>
<p>也可以继承其它挂载有 /test 卷的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash<br></code></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20150212/20150212091035_912.png" alt="非常详细的 Docker 学习笔记"></p>
<h2 id="8-3-备份、恢复或迁移数据卷"><a class="header-anchor" href="#8-3-备份、恢复或迁移数据卷"></a>8.3 备份、恢复或迁移数据卷</h2>
<h3 id="备份"><a class="header-anchor" href="#备份"></a>备份</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --<span class="hljs-built_in">rm</span> --volumes-from <span class="hljs-built_in">test</span> -v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu:14.04 tar cvf /backup/test.tar /test<br>tar: Removing leading `/<span class="hljs-string">&#x27; from member names</span><br><span class="hljs-string">/test/</span><br><span class="hljs-string">/test/b</span><br><span class="hljs-string">/test/d</span><br><span class="hljs-string">/test/c</span><br><span class="hljs-string">/test/a</span><br></code></pre></td></tr></table></figure>
<p>启动一个新的容器并且从test容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份 test 卷中所有的数据为 test.tar，执行完成之后删除容器–rm，此时备份就在当前的目录下，名为test.tar。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 宿主机当前目录下产生了 test 卷的备份文件 </span><br>test.tar test.tar<br></code></pre></td></tr></table></figure>
<h3 id="恢复"><a class="header-anchor" href="#恢复"></a>恢复</h3>
<p>你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i -d -v /test --name test4 ubuntu:14.04  /bin/bash <br>$ sudo docker run --<span class="hljs-built_in">rm</span> --volumes-from test4 -v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu:14.04 tar xvf /backup/test.tar -C / <span class="hljs-comment"># 恢复之前的文件到新建卷中，执行完后自动删除容器 </span><br><span class="hljs-built_in">test</span>/ <span class="hljs-built_in">test</span>/b <span class="hljs-built_in">test</span>/d <span class="hljs-built_in">test</span>/c <span class="hljs-built_in">test</span>/a<br></code></pre></td></tr></table></figure>
<h2 id="8-4-删除-Volumes"><a class="header-anchor" href="#8-4-删除-Volumes"></a>8.4 删除 Volumes</h2>
<p>Volume 只有在下列情况下才能被删除：</p>
<ul>
<li>docker rm -v删除容器时添加了-v选项</li>
<li>docker run --rm运行容器时添加了–rm选项</li>
</ul>
<p>否则，会在/var/lib/docker/vfs/dir目录中遗留很多不明目录。</p>
<p>参考文档：</p>
<ul>
<li><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes">Managing Data in Containers</a></li>
<li><a href="http://dockerone.com/article/128">深入理解Docker Volume（一）</a></li>
<li><a href="http://dockerone.com/article/129">深入理解Docker Volume（二）</a></li>
</ul>
<h1 id="九、链接容器"><a class="header-anchor" href="#九、链接容器"></a>九、链接容器</h1>
<p>docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。</p>
<h2 id="9-1-容器命名"><a class="header-anchor" href="#9-1-容器命名"></a>9.1 容器命名</h2>
<p>在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：</p>
<ul>
<li>1、给容器命名方便记忆，如命名运行 web 应用的容器为 web</li>
<li>2、为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db</li>
</ul>
<p>可以通过–name选项给容器自定义命名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -d -t -i --name <span class="hljs-built_in">test</span> ubuntu:14.04 bash              <br>$ sudo docker  inspect --format=<span class="hljs-string">&quot;&#123;&#123; .Nmae &#125;&#125;&quot;</span> <span class="hljs-built_in">test</span><br>/test<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：容器名称必须唯一，即你只能命名一个叫test的容器。如果你想复用容器名，则必须在创建新的容器前通过docker rm删除旧的容器或者创建容器时添加–rm选项。</p>
</blockquote>
<h2 id="9-2-链接容器"><a class="header-anchor" href="#9-2-链接容器"></a>9.2 链接容器</h2>
<p>链接允许容器间安全通信，使用–link选项创建链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -d --name db training/postgres<br></code></pre></td></tr></table></figure>
<p>基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -d -P --name web --<span class="hljs-built_in">link</span> db:db training/webapp python app.py<br></code></pre></td></tr></table></figure>
<p>–link <name or id>:alias选项指定链接到的容器。</p>
<p>查看 web 容器的链接关系:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker inspect -f <span class="hljs-string">&quot;&#123;&#123; .HostConfig.Links &#125;&#125;&quot;</span> web<br>[/db:/web/db]<br></code></pre></td></tr></table></figure>
<p>可以看到 web 容器被链接到 db 容器为/web/db，这允许 web 容器访问 db 容器的信息。</p>
<p>容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加-p或-P指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。</p>
<p>Docker 主要通过以下两个方式提供连接信息给接收容器：</p>
<ul>
<li>环境变量</li>
<li>更新/etc/hosts文件</li>
</ul>
<h3 id="环境变量"><a class="header-anchor" href="#环境变量"></a>环境变量</h3>
<p>当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。</p>
<p>首先，Docker 会在每个通过–link选项指定别名的目标容器上设置一个<alias>_NAME环境变量。如果一个名为 web 的容器通过–link db:webdb被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为WEBDB_NAME=/web/webdb.</p>
<p>以之前的为例，Docker 还会设置端口变量:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run --<span class="hljs-built_in">rm</span> --name web2 --<span class="hljs-built_in">link</span> db:db training/webapp <span class="hljs-built_in">env</span><br>. . .<br>DB_NAME=/web2/db<br>DB_PORT=tcp://172.17.0.5:5432           <br>DB_PORT_5432_TCP=tcp://172.17.0.5:5432  <span class="hljs-comment"># &lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt; 协议可以是 TCP 或 UDP</span><br>DB_PORT_5432_TCP_PROTO=tcp<br>DB_PORT_5432_TCP_PORT=5432<br>DB_PORT_5432_TCP_ADDR=172.17.0.5<br>. . .<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量</p>
</blockquote>
<h3 id="更新-etc-hosts文件"><a class="header-anchor" href="#更新-etc-hosts文件"></a>更新/etc/hosts文件</h3>
<p>除了环境变量，Docker 会在目标容器上添加相关主机条目到/etc/hosts中，上例中就是 web 容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker run -t -i --<span class="hljs-built_in">rm</span> --<span class="hljs-built_in">link</span> db:db training/webapp /bin/bash<br>root@aed84ee21bde:/opt/webapp<br><span class="hljs-comment"># cat /etc/hosts</span><br>172.17.0.7  aed84ee21bde<br>. . .<br>172.17.0.5  db<br></code></pre></td></tr></table></figure>
<blockquote>
<p>/etc/host文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。</p>
</blockquote>
<h1 id="十、构建私有库"><a class="header-anchor" href="#十、构建私有库"></a>十、构建私有库</h1>
<p>Docker 官方提供了 docker registry 的构建方法 <a href="https://github.com/docker/docker-registry">docker-registry</a></p>
<h2 id="10-1-快速构建"><a class="header-anchor" href="#10-1-快速构建"></a>10.1 快速构建</h2>
<p>快速构建 docker registry 通过以下两步:</p>
<ul>
<li>安装 docker</li>
<li>运行 registry:docker run -p 5000:5000 registry</li>
</ul>
<p>这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/">official image from the Docker hub</a></p>
<h2 id="10-2-不使用容器构建-registry"><a class="header-anchor" href="#10-2-不使用容器构建-registry"></a>10.2 不使用容器构建 registry</h2>
<h3 id="安装必要的软件"><a class="header-anchor" href="#安装必要的软件"></a>安装必要的软件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev<br></code></pre></td></tr></table></figure>
<h3 id="配置-docker-registry"><a class="header-anchor" href="#配置-docker-registry"></a>配置 docker-registry</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo pip install docker-registry<br></code></pre></td></tr></table></figure>
<p>或者 使用 github clone 手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/dotcloud/docker-registry.git<br>$ <span class="hljs-built_in">cd</span> docker-registry/<br>$ <span class="hljs-built_in">cp</span> config/config_sample.yml config/config.yml<br>$ <span class="hljs-built_in">mkdir</span> /data/registry -p<br>$ pip install .<br></code></pre></td></tr></table></figure>
<h3 id="运行"><a class="header-anchor" href="#运行"></a>运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-registry<br></code></pre></td></tr></table></figure>
<h3 id="高级启动方式-不推荐"><a class="header-anchor" href="#高级启动方式-不推荐"></a>高级启动方式 [不推荐]</h3>
<p>使用gunicorn控制:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application<br></code></pre></td></tr></table></figure>
<p>或者对外监听开放</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application<br></code></pre></td></tr></table></figure>
<h2 id="10-3-提交指定容器到私有库"><a class="header-anchor" href="#10-3-提交指定容器到私有库"></a>10.3 提交指定容器到私有库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04<br>$ docker push 私有库IP:5000/ubuntu<br></code></pre></td></tr></table></figure>
<p>更多的配置选项推荐阅读官方文档:</p>
<ul>
<li><a href="https://github.com/docker/docker-registry/blob/master/README.md">Docker-Registry README</a></li>
<li><a href="https://github.com/docker/docker-registry/blob/master/ADVANCED.md">Docker-Registry advanced use</a></li>
</ul>
<p>来自：<a href="http://opskumu.github.io/docker.html">http://opskumu.github.io/docker.html</a></p>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统理论序幕</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%BA%8F%E5%B9%95.html</url>
    <content><![CDATA[<hr>
<ul>
<li>
<p>分布式系统</p>
<ul>
<li>分布式系统是其组件分布在连网的计算机上，组件之间通过传递消息进行通信和协调的系统。</li>
<li>为什么要分布式
<ul>
<li>高可用，可拓展，性价比</li>
</ul>
</li>
<li>三个特点：不共享内存（需要网络传输），不共享时钟，不共享操作系统</li>
<li>三个问题：网络问题，时钟问题，部分失效partial failure</li>
<li>请求结果存在三态：成功，失败，超时</li>
<li>三大方向：分布式存储系统，分布式计算系统，分布式调度系统
<ul>
<li>各个方向都有一些特定的算法，但是分布式共识问题是分布式系统中最基本的问题：如何让分布式系统中的节点达成共识</li>
</ul>
</li>
</ul>
</li>
<li>
<p>共识</p>
<ul>
<li>什么是共识</li>
<li>为什么要达成共识
<ul>
<li>在共识的帮助下，<strong>分布式系统就可以像单一节点一样工作</strong>——所以共识问题是分布式系统最基本的问题。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>模型</p>
<ul>
<li>网络模块
<ul>
<li>同步：响应时间是有限的</li>
<li>异步：响应时间无限的</li>
</ul>
</li>
<li>故障类型
<ul>
<li>Fail-stop failures 节点宕机并停止响应 (也就是常说的 not Byzantine)</li>
<li>Byzantine failures 源自“拜占庭将军问题”，节点响应的消息无法预料，可能矛盾或者无意义。也就是除了通信故障还可能存在消息篡改和伪造。</li>
</ul>
</li>
<li>消息模型
<ul>
<li>口信型消息oral messages（未签名（口头的）的消息）</li>
<li>签名型消息signed messages</li>
</ul>
</li>
</ul>
</li>
<li>
<p>异步系统中的共识问题</p>
<ul>
<li>FLP不可能结论</li>
<li>分布式共识算法需要具有的两个属性：<strong>安全性(safety)<strong>和</strong>活性(liveness)</strong>
<ul>
<li>安全性：所有正确的进程都认同同一个值</li>
<li>活性：分布式系统最终会认同某一个值</li>
<li>每一个共识算法要么牺牲掉一个属性，要么放宽对网络异步的假设。</li>
</ul>
</li>
<li>FLP结论的启示
<ul>
<li>不再尝试寻找异步通信系统中，共识问题的完全正确的解法。可以找到一些方法，绕开FLP不可能，满足大部分情况下都能达成共识
<ul>
<li>故障屏蔽Fault masking
<ul>
<li>故障屏蔽假设故障的进程最终会恢复，并找到一种重新加入分布式系统的方式。如果没有收到来自某个进程的消息，就一直等待直到收到预期的消息。</li>
<li>例如，两阶段提交事务使用持久存储，能够从崩溃中恢复。</li>
</ul>
</li>
<li>故障检测Failure detectors</li>
<li>随机性算法Non-Determinism</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>同步系统中的共识问题</p>
<ul>
<li>我们熟知的 Paxos 在异步系统中，由于<strong>活锁</strong>的存在，并没有完全解决共识问题（liveness不满足）。但 Paxos 被广泛应用在各种分布式系统中，就是因为在达成共识之前，系统并没有那么“异步”，还是有极大概率达成共识的。</li>
<li><strong>同步系统中，如果 N 个进程中最多有 f 个会出现崩溃故障，那么经过 f + 1 轮消息传递后即可达成共识。</strong> 《Authenticated Algorithms for Byzantine Agreement》</li>
</ul>
</li>
<li>
<p>分布式理论发展历程</p>
<ul>
<li>
<p>费林分类法（Flynn’s Taxonomy），MIMD引出并行和分布式系统</p>
</li>
<li>
<p>分布式系统的三个问题与三个方向</p>
</li>
<li>
<p>逻辑时钟。Lamport的《Time, Clocks and the Ordering of Events in a Distributed System》</p>
</li>
<li>
<p>拜占庭将军问题。Lamport的《Byzantine Generals Problem》</p>
</li>
<li>
<p>分布式状态机副本</p>
</li>
<li>
<p>分布式快照</p>
</li>
<li>
<p>FLP结论。《Impossibility of Distributed Consensus with One Faulty Process》</p>
<ul>
<li>证明了：在一个异步系统中，即使只有一个进程出了故障，也没有算法能够<strong>保证</strong>达成共识。</li>
<li>注意：不是说只要有一个进程故障就不能达成共识，而是说无法确保达成共识。</li>
</ul>
</li>
<li>
<p>Paxos算法</p>
</li>
<li>
<p>PBFT</p>
</li>
<li>
<p>分布式系统的基本问题：共识</p>
</li>
</ul>
</li>
<li>
<p>拜占庭将军问题</p>
<ul>
<li>分布式共识问题
<ul>
<li>什么是共识
<ul>
<li>系统中的多个节点对某个值达成一致</li>
</ul>
</li>
<li>为什么要达成共识</li>
</ul>
</li>
<li>容错算法分为两类</li>
<li>有无恶意行为区分使用BFT还是CFT</li>
</ul>
</li>
<li>
<p>Poxas是属于CFT的一种</p>
</li>
<li>
<p>Poxas重要性</p>
<ul>
<li>Chubby作者MikeBurrows说过，这世界上只有一种一致性共识算法，那就是Paxos</li>
</ul>
</li>
</ul>
<hr>
<p>分布式计算中，共识Consensus问题是最重要的，最基本的问题。共识使得分布式系统表现出一致的行为，就像是单一节点一样。Lamport提出的拜占庭将军问题（The Byzantine Generals Problem），借助拜占庭将军的故事，很好地抽象了分布式系统面临的共识问题，并且探讨和论证了解决办法。</p>
<p>拜占庭将军问题描述的是最为复杂的一种分布式故障场景，不仅含有通信故障（消息丢失，重复），而且包含恶意行为（篡改消息，伪造消息）。解决拜占庭将军问题的算法称之为拜占庭容错算法（Byzantine Fault Tolerance，BFT）。对于解决不含有恶意行为场景下的容错算法，统称为非拜占庭容错算法，也就是故障容错算法（Crash Fault Tolerance, CFT）。事实上，计算机分布式系统中，最常用的就是CFT。</p>
<ul>
<li>拜占庭容错算法 BFT
<ul>
<li>节点间存在通信故障，恶意行为的场景下，如何达成共识。</li>
<li>这种故障场景，称之为拜占庭故障</li>
<li>常用于开放式分布式系统，如区块链技术</li>
<li>常见算法：口信型消息算法，签名型消息算法，PBFT算法，PoW算法</li>
</ul>
</li>
<li>非拜占庭容错算法，故障容错算法 CFG
<ul>
<li>节点间不存在恶意行为的场景下（非拜占庭故障），如何达成共识</li>
<li>常见算法：Paxos算法，Raft算法，ZAB算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>分布式理论</tag>
      </tags>
  </entry>
  <entry>
    <title>BasicPaxos算法</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/BasicPaxos%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<hr>
<ul>
<li>
<p>CFT 非拜占庭容错算法， 故障容错算法</p>
</li>
<li>
<p>目的</p>
<ul>
<li>多节点就某一个值达成共识</li>
<li>达成了共识后，值就不会再变了，但如果我们想改变数据的值，可以实现状态机，和提议新的指令。</li>
</ul>
</li>
<li>
<p>三个角色</p>
<ul>
<li>Proposer，Acceptor，Learner</li>
</ul>
</li>
<li>
<p>单调递增的提案编号</p>
<ul>
<li>论文提到了思路。独立、递增、存储在可靠性设备中。具体细节实现，可以参考Hashicorp Raft的CurrentTerm的实现（Raft.setCurrentTerm()、raftState.getCurrentTerm()、raftState.setCurrentTerm()），原子、递增、持久存储。</li>
</ul>
</li>
<li>
<p>二阶段提交思想</p>
<ul>
<li>准备阶段
<ul>
<li>各个节点依据自身情况，响应“准备请求”中的提案</li>
<li>若收到的提案编号小于等于 已收到的“准备请求”中最大的提案编号，则不响应</li>
<li>若之前已经接受了某个提案，那么这次“准备请求”的响应中，会包含已经接受的最大编号的提案信息。（Proposer会根据响应处理接下来“接受请求”的提案值，如果大多数节点已经接受了一个一致的值，则以这个值为准。）</li>
</ul>
</li>
<li>接受阶段
<ul>
<li>各个节点依据自身情况，接收“接受请求”中的提案</li>
<li>若“接受请求”中提案编号小于已经响应的<strong>准备请求</strong>的提案编号，则会拒绝。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大多数原则，而不是全部</p>
<ul>
<li>提供了一定的容错能力</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>分布式系统
<ul>
<li>分布式系统是其组件分布在连网的计算机上，组件之间通过传递消息进行通信和协调的系统。</li>
<li>三个特点：不共享内存（需要网络传输），不共享时钟，不共享操作系统</li>
<li>三个问题：网络问题，时钟问题，部分失效partial failure</li>
<li>请求结果存在三态：成功，失败，超时</li>
<li>三大方向：分布式存储系统，分布式计算系统，分布式调度系统
<ul>
<li>各个方向都有一些特定的算法，但是分布式共识问题是分布式系统中最基本的问题：如何让分布式系统中的节点达成共识</li>
</ul>
</li>
</ul>
</li>
<li>共识
<ul>
<li>什么是共识</li>
<li>为什么要达成共识</li>
<li></li>
</ul>
</li>
<li>拜占庭将军问题
<ul>
<li>分布式共识问题
<ul>
<li>什么是共识
<ul>
<li>系统中的多个节点对某个值达成一致</li>
</ul>
</li>
<li>为什么要达成共识</li>
</ul>
</li>
<li>容错算法分为两类</li>
<li>有无恶意行为区分使用BFT还是CFT</li>
</ul>
</li>
<li>Paxos是属于CFT的一种</li>
<li>Paxos重要性
<ul>
<li>Chubby作者MikeBurrows说过，这世界上只有一种一致性共识算法，那就是Paxos</li>
</ul>
</li>
</ul>
<hr>
<p>Paxos算法包含两部分</p>
<ul>
<li>
<p>一个是Basic Paxos算法，描述多节点之间如何就一个值达成共识。</p>
</li>
<li>
<p>一个是Multi Paxos思想，描述多个节点之间如何就一系列值达成共识。</p>
</li>
</ul>
<p>先大致了解一下拜占庭将军问题。</p>
<p>拜占庭将军问题（The Byzantine Generals Problem）是Lamport借助一个将军的故事来展现<strong>分布式共识问题</strong>，并且探讨和论证了解决的办法。可以认为拜占庭将军问题是分布式领域最复杂的一个容错模型，它提供了分布式共识问题的解决思路。</p>
<p>简单说，拜占庭将军问题描述了一种分布式故障场景，除了存在**通信故障（crash fault）<strong>行为，还存在</strong>恶意行为（corrupt）**的一个场景。</p>
<ul>
<li>
<p>通信故障crash fault：消息丢失，消息重复等</p>
</li>
<li>
<p>恶意行为corrupt：篡改消息，伪造消息等</p>
</li>
</ul>
<p>我们依据是否场景中是否存在恶意行为，可以将容错算法</p>
<ul>
<li>对于存在恶意行为的场景（如区块链），要解决共识问题，必须使用拜占庭容错算法（Byzantine Fault Tolerance，BFT）</li>
<li>对于不存在恶意行为，只存在通信故障行为的场景，要解决共识问题，就可以使用非拜占庭容错算法，也就是故障容错算法（Crash Fault Tolerance, CFT）</li>
</ul>
<p>Paxos算法是CFT算法的一种，它解决的是当集群节点中不存在恶意行为（篡改，伪造信息），只可能出现通信故障（消息丢失，重复）情况下的共识问题。</p>
<p>角色：Client, Proposer，Acceptor， Learner</p>
<p>Proposal, proposal identified number,</p>
<p>Basic Paxos是一个经典的两阶段提交。</p>
<blockquote>
<p>Phase 1<br>
Phase 1a: Prepare<br>
A Proposer creates a message, which we call a “Prepare”, identified with a number n. Note that n is not the value to be proposed and maybe agreed on, but just a number which uniquely identifies this initial message by the proposer (to be sent to the acceptors). The number n must be greater than any number used in any of the previous Prepare messages by this Proposer. Then, it sends the Prepare message containing n to a Quorum of Acceptors. Note that the Prepare message only contains the number n (that is, it does not have to contain e.g. the proposed value, often denoted by v). The Proposer decides who is in the Quorum[how?]. A Proposer should not initiate Paxos if it cannot communicate with at least a Quorum of Acceptors.</p>
<p>一个Proposer创建一个Prepare消息，使用一个数组n唯一标识，记做Prepare[n,]。要注意，n不是被提议的值，只是一个数字，被proposer用来唯一标识这条初始消息（发往各个acceptor）的数字而已。数字n对于这个proposer而言，必须是递增的未被使用过的。然后这个Prepare[n]消息会被发往法定数量的acceptor。注意这个消息只携带数字n，并不包含提议值v。</p>
<p>Phase 1b: Promise<br>
Any of the Acceptors waits for a Prepare message from any of the Proposers. If an Acceptor receives a Prepare message, the Acceptor must look at the identifier number n of the just received Prepare message. There are two cases.<br>
If n is higher than every previous proposal number received, from any of the Proposers, by the Acceptor, then the Acceptor must return a message, which we call a “Promise”, to the Proposer, to ignore all future proposals having a number less than n. If the Acceptor accepted a proposal at some point in the past, it must include the previous proposal number, say m, and the corresponding accepted value, say w, in its response to the Proposer.<br>
Otherwise (that is, n is less than or equal to any previous proposal number received from any Proposer by the Acceptor) the Acceptor can ignore the received proposal. It does not have to answer in this case for Paxos to work. However, for the sake of optimization, sending a denial (Nack) response would tell the Proposer that it can stop its attempt to create consensus with proposal n.</p>
<p>若一个Acceptor接收到了prepare[n,]消息，它会查看这个提案号n是否是它之前收到的所有消息中最大的，如果是，则会返回一个响应给proposer，记做promise[]。并且会忽略之后收到的提案号小于n的所有提案。如果这个aceeptor在之前接受了(accepted)一个提案[m,w]，那么promise响应就必须带上这个提案信息，记做promise[m,w]。</p>
<p>否则，如果acceptor收到的提案号小于或等于之前收到的任何提案号，acceptor就会忽略掉这个消息。出于优化的考虑，acceptor会响应一个拒绝给proposer，让proposer不要再使用n作为提案号。</p>
<p>Phase 2<br>
Phase 2a: Accept<br>
If a Proposer receives a majority of Promises from a Quorum of Acceptors, it needs to set a value v to its proposal. If any Acceptors had previously accepted any proposal, then they’ll have sent their values to the Proposer, who now must set the value of its proposal, v, to the value associated with the highest proposal number reported by the Acceptors, let’s call it z. If none of the Acceptors had accepted a proposal up to this point, then the Proposer may choose the value it originally wanted to propose, say x.[19]<br>
The Proposer sends an Accept message, (n, v), to a Quorum of Acceptors with the chosen value for its proposal, v, and the proposal number n (which is the same as the number contained in the Prepare message previously sent to the Acceptors). So, the Accept message is either (n, v=z) or, in case none of the Acceptors previously accepted a value, (n, v=x).<br>
This Accept message should be interpreted as a “request”, as in “Accept this proposal, please!”.</p>
<p>如果一个proposer收到了大部分acceptor的promise消息，</p>
<p>Phase 2b: Accepted<br>
If an Acceptor receives an Accept message, (n, v), from a Proposer, it must accept it if and only if it has not already promised (in Phase 1b of the Paxos protocol) to only consider proposals having an identifier greater than n.<br>
If the Acceptor has not already promised (in Phase 1b) to only consider proposals having an identifier greater than n, it should register the value v (of the just received Accept message) as the accepted value (of the Protocol), and send an Accepted message to the Proposer and every Learner (which can typically be the Proposers themselves).<br>
Else, it can ignore the Accept message or request.<br>
Note that an Acceptor can accept multiple proposals. This can happen when another Proposer, unaware of the new value being decided, starts a new round with a higher identification number n. In that case, the Acceptor can promise and later accept the new proposed value even though it has accepted another one earlier. These proposals may even have different values in the presence of certain failures[example needed]. However, the Paxos protocol will guarantee that the Acceptors will ultimately agree on a single value.</p>
</blockquote>
<p>第一阶段：</p>
<ul>
<li>prepare准备：proposer向acceptors提出一个提案</li>
<li>promise承诺：acceptor承诺只接受最大提案号的提案</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>accept</li>
<li>accepted</li>
</ul>
<ol>
<li>如果<strong>准备请求</strong>的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个准备请求；</li>
<li>如果<strong>接受请求</strong>中的提案的提案编号，小于接受者已经响应的<strong>准备请求</strong>的提案编号，那么接受者将承诺不通过这个提案；</li>
<li>如果接受者之前有通过提案，那么接受者将承诺，会在<strong>准备请求</strong>的响应中，包含已经通过的最大编号的提案信息。</li>
</ol>
<p>怎么保障提案号不重复呢？</p>
<p>可以通过独立单调递增、随机超时，来避免重复冲突，比如，可以参考Hashicorp Raft对CurrentTerm的实现。</p>
<p>@Tung 目前看来，比较关键的就是提案编号的单调递增，以及大多数原则</p>
<p>Paxos能保证一旦达成共识，后面除了提案编号变大之外，提案的值不变，而且2pc的第一阶段就能感知到已经通过的提案的信息。</p>
<p>混淆了副本和共识的概念？，集群就某个提案形成大多数后达成了共识，但是副本不保证一致，在2f+1个节点的集群里，只要f+1个节点接受某个提案k，则就k达成共识，但是副本只保证至少f+1个是正确的提案，其余的节点上的提案不做保证。简单的说法是此时需要获取某个提案的话，需要从2f+1个节点上都获取一次，再确认集群提交的提案是哪个，才算是从集群的一次读取过程。</p>
<p><img src="https://tximgcdn.tung7.com/BasicPaxos%E7%AE%97%E6%B3%95/BasicPaxos%E7%AE%97%E6%B3%95_20210807005639_357847.png" alt="image-20210807005634094"></p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>分布式理论</tag>
      </tags>
  </entry>
  <entry>
    <title>MultiPaxos思想</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/MultiPaxos%E6%80%9D%E6%83%B3.html</url>
    <content><![CDATA[<p>兰伯特Lamport提到的 Multi-Paxos 是<strong>一种思想</strong>，不是算法。</p>
<p>而 Multi-Paxos 算法是<strong>一个统称</strong>，它是指基于 Multi-Paxos 思想，通过多个 Basic Paxos 实例实现一系列值的共识的算法（比如 Chubby 的 Multi-Paxos 实现、Raft 算法等）</p>
<p>两个问题：</p>
<ol>
<li>如果多个提议者同时提交提案，可能出现因为提案编号冲突，也可能出现没有提议者能够收到大多数响应，最终主备失败重新协商。</li>
<li>准备阶段和接受阶段两轮的往返消息多，性能和延迟问题。
<ol>
<li>兰伯特提到：“当领导者处于稳定状态时，省掉准备阶段，直接进入接受阶段”这个优化机制</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>引入Leader</p>
<ul>
<li>作为唯一Proposer，</li>
<li>避免多个节点作为Propos同时提案，使得没有提议者能够获得大多数响应，导致准备阶段失败，重新协商的情况</li>
<li>在论文中，兰伯特没有说如何选举领导者，需要我们在实现 Multi-Paxos 算法的时候自己实现。</li>
<li>可以通过BasicPaxos算法进行选主。</li>
</ul>
</li>
<li>
<p>省略准备阶段</p>
<ul>
<li>当Leader稳定时，可以省略准备阶段，直接进入接受阶段</li>
<li>稳定的意思是。领导者节点上，序列中的命令是最新的，<strong>不需要通过准备阶段来发现之前被大多数节点通过的提案。</strong>。当领导者处于稳定状态时，因为只有一个领导者即是单机，单机自然是时间有序的，不需要逻辑时间，直接使用单机物理时间，所以可以忽略时间概念(一般单机上是不会感知时间的，都是按照操作的先后顺序)。</li>
<li><strong>不存在提案冲突</strong>：重复执行 Basic Paxos 相比，Multi-Paxos 引入领导者节点之后，因为只有领导者节点一个提议者，只有它说了算，所以就不存在提案冲突，可以直接进入接受阶段。</li>
</ul>
</li>
<li>
<p>选主</p>
</li>
<li>
<p>主节点续租Lease</p>
</li>
<li>
<p>成员变更</p>
</li>
<li>
<p>一致性</p>
<ul>
<li>同步写，强一致性</li>
</ul>
</li>
<li>
<p>BasicPaxos算法经过证明</p>
</li>
<li>
<p>MultiPaxos思想的工程实现需要证明是最大的挑战</p>
</li>
<li>
<p>Raft算法也是经过证明的</p>
</li>
</ul>
<p>怎么确定acceptor总数，涉及代码实现和成员变更；扩容涉及到成员变更。<br>
首先，使用什么数据结构来保存acceptor总数，这属于编程实现，不属于算法了，绝大多数算法都不会约定的这么细的。</p>
<p>其实，学习Multi-Paxos的最好的方式，是先理解Raft，再回过头来，学习Multi-Paxos。如果在学习Multi-Paxos中遇到不理解的，可以在学习完Raft后，再回头来研究学习。</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>分布式理论</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL XA</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/MySQL%20XA.html</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/7003d58ea182">MySQL XA 介绍 - 简书 (jianshu.com)</a></p>
<p><a href="https://www.cnblogs.com/dennyzhangdd/p/10580446.html">分布式事务（一）原理概览 - 只会一点java - 博客园 (cnblogs.com)</a></p>
<h1 id="DTP模型"><a class="header-anchor" href="#DTP模型"></a>DTP模型</h1>
<p>DTP模型是一种软件体系结构，它允许多个应用程序共享多个资源管理器提供的资源，并允许将它们的工作协调到全局事务中。</p>
<h2 id="元素介绍"><a class="header-anchor" href="#元素介绍"></a>元素介绍</h2>
<ul>
<li>应用程序Application Program, AP
<ul>
<li>定义事务的开始和结束，访问事务边界内的资源，通常决定是提交还是回滚事务。</li>
</ul>
</li>
<li>资源管理器Resource Manager，RM
<ul>
<li>数据库服务，文件系统服务等</li>
</ul>
</li>
<li>事务管理器Transaction Manager, TM
<ul>
<li>管理全局事务，分配事务唯一表示XID，监控事务执行进度，负责事务的提交或回滚。</li>
<li>如果RM是一个CRM，那么在执行两个AP之间的通信时，它将xid传递给合作伙伴？？？？？</li>
</ul>
</li>
<li>通信资源管理器Communication Resource Manager，CRM
<ul>
<li>控制一个TM域内或者跨TM域的分布式应用之间的通信</li>
</ul>
</li>
<li>通信协议Communication Protocol，CP
<ul>
<li>提供给分布式应用程序使用的，由CRM支持的底层通信服务。</li>
</ul>
</li>
</ul>
<h1 id="单应用跨库DTP，跨应用DTP"><a class="header-anchor" href="#单应用跨库DTP，跨应用DTP"></a>单应用跨库DTP，跨应用DTP</h1>
<p>一个AP一个TM，操作多个RM</p>
<p>如果分布式事务中，需要跨多个应用（如微服务），那就必须增加通信资源管理器CRM</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft共识算法</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<ul>
<li>是工程开发首选的共识算法
<ul>
<li>Etcd, Consul</li>
</ul>
</li>
<li>是在Multi-Paxos思想上，做了简化和限制。
<ul>
<li>要求日志必须连续的
<ul>
<li>只要看最后一个log谁更新，O(1)就能证明谁更完整； 若日志不连续，有中间的空格，那就得全量比较，O(n)了； 所以，日志必须连续；用数据结构的维护成本，来降低算法成本，是空间换时间的例子。</li>
</ul>
</li>
<li>只有领导者，追随者，候选人三种状态</li>
</ul>
</li>
<li>本质：强领导者模型，一切以领导者为准，实现一系列值的共识，各个节点日志的一致。</li>
<li>状态机</li>
<li>日志结构
<ul>
<li>列表：{索引，{任期编号Term，指令}}</li>
</ul>
</li>
<li>选举过程
<ul>
<li>随机心跳超时，任期编号</li>
<li>任期投票，一个节点只能投一票。
<ul>
<li>投给日志完整度比自己高的（这会导致领导者的日志完整度不比半数节点低）</li>
<li>先来先得</li>
</ul>
</li>
<li>大多数选票</li>
</ul>
</li>
<li>日志复制的一阶段提交</li>
</ul>
<blockquote>
<p>旁@Tung: 为什么要引入日志。</p>
</blockquote>
<p><strong>如何保证同一时间只有一个领导者？</strong></p>
<p>3 种状态：领导者（Leader）、跟随者（Follower）和候选人（Candidate）</p>
<p>2中RPC消息：RequestVote投票，AppendEntries复制日志和心跳信息</p>
<ul>
<li>候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态</li>
</ul>
<p>在集群中进行成员变更的最大风险是，可能会同时出现 2 个领导者。</p>
<h1 id="疑问"><a class="header-anchor" href="#疑问"></a>疑问</h1>
<ul>
<li>由于leader与follower是一阶段提交，leader commit并响应client写入成功，但再发送下一波心跳前宕机，导致followers没有commit log，这会有问题吗
<ul>
<li>选举出来的新leader，会向其它节点复制日志。如果某条uncommitted的log被发现已经成功复制在大多数节点上，则这条log会更新为commit状态，也会通知其他节点commit</li>
</ul>
</li>
<li>uncommitted的logentry算不算入日志完整度？
<ul>
<li>算的，不然可能会导致丢失，见上个问题。</li>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>分布式理论</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议速览</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/http_protocol_conclusion.html</url>
    <content><![CDATA[<h1 id="什么是HTTP协议"><a class="header-anchor" href="#什么是HTTP协议"></a>什么是HTTP协议</h1>
<p>HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。</p>
<p>HTTP是一个无状态协议，这意味着每个请求都是独立的。每一个请求（Request）必有一个相应（Response）与之对应，每对RESQUEST-RESPONSE之间是没有影响了。也就是说，服务器在没有Request的情况下是不能主动发送Response到客户端的。</p>
<h1 id="HTTP协议的版本与区别"><a class="header-anchor" href="#HTTP协议的版本与区别"></a>HTTP协议的版本与区别</h1>
<p>HTTP协议的版本：HTTP/1.0、HTTP/1.1</p>
<p>在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。（一请求一响应，然后关闭TCP连接）</p>
<p>在HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。（多请求多响应，才关闭TCP连接）</p>
<p>在HTTP1.0中，每次请求资源都要先建立TCP连接（三次握手）之后才开始进行HTTP连接，在得到请求的响应之后，就会断开TCP连接（四次挥手）。这样效率很低， 因此，Keep-Alive功能就出现了，Keep-Alive允许在同一TCP连接中进行多次请求响应连接(REQUEST-RESPONSE)，避免了重复建立连接。而HTTP1.1就是把Keep-Alive纳入了标准，是HTTP1.1的预设的功能。实际上HTTP1.0只要加上Keep-Alive 请求头之后，如果服务器支持Keep-Alive的话，也可以实现该功能。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">Keep-Alive: <span class="hljs-attribute">timeout</span>=5, <span class="hljs-attribute">max</span>=100<br></code></pre></td></tr></table></figure>
<ul>
<li>timeout：过期时间5秒，（对应httpd.conf里的参数是：KeepAliveTimeout）</li>
<li>max: 最多一百次请求，服务器收到一个request，max就减1，到0时强制断开。</li>
</ul>
<p><img src="http://qiniu.tung7.com/1449510434.jpg" alt="Image"></p>
<p><strong>需要注意的是</strong>：Keep-Alive并不能改变HTTP是<code>无状态</code>的事实，因为它只是能使TCP连接不断开，不能使请求响应对之间有联系。要使服务器主动发送响应到客户端就要使用WebSocket协议，这里就不展开了。</p>
<p>**Keep-Alive在Java中的实现：**Java类库中的HttpURLConnection类自动实现了Keep-Alive，其他类库在没有实现Keep-Alive的时候需要手动添加Keep-Alive请求头。 在服务器端HttpServlet、HttpServletRequest、和HttpServletResponse类自动实现了Keep-Alive。</p>
<h1 id="HTTP请求"><a class="header-anchor" href="#HTTP请求"></a>HTTP请求</h1>
<h2 id="HTTP请求包括的内容"><a class="header-anchor" href="#HTTP请求包括的内容"></a>HTTP请求包括的内容</h2>
<p>客户端与服务器建立了TCP连接后，向服务器请求某一WEB资源，我们称之为客户端向服务器发送了一个HTTP请求。</p>
<p>一个完整的HTTP请求应该由三部分组成：<code>请求行部分</code>，<code>请求头部分</code>，<code>实体部分</code>。</p>
<p><img src="http://qiniu.tung7.com/1449511326.jpg" alt="QQ截图20151208020110.jpg"></p>
<h2 id="HTTP请求的细节——请求行"><a class="header-anchor" href="#HTTP请求的细节——请求行"></a>HTTP请求的细节——请求行</h2>
<p>请求行格式：<strong>请求方式 资源名称 HTTP版本号</strong></p>
<p>请求行用于描述客户端的请求方式，请求资源名以及所用的HTTP协议版本号。这在上图中可以看到，请求的方式是GET, 资源名是<a href="http://www.tung7.com/">www.tung7.com</a>， HTTP协议版本号是HTTP/1.1</p>
<p>请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST。而浏览器默认都是使用GET方式。</p>
<p>这两种方式的区别主要表现在数据传递上：如果请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">www.tung7.com/hi.html?name=abc&amp;password=xyz</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure>
<p>GET方式在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K， 而POST方式是通过请求实体发送数据的，传送的数据量无限制。说是无限制，但是还是和服务器端配置有关，倘若服务器端最大单次允许上传大小为5M, 超过后会返回413错误状态码。</p>
<p>**注意的是：**GET方式在请求实体中不能有内容。</p>
<h2 id="HTTP请求的细节——消息头"><a class="header-anchor" href="#HTTP请求的细节——消息头"></a>HTTP请求的细节——消息头</h2>
<p>HTTP请求中的常用消息头</p>
<blockquote>
<p>accept:浏览器通过这个头告诉服务器，它所支持的数据类型<br>
Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集<br>
Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式<br>
Accept-Language：浏览器通过这个头告诉服务器，它的语言环境<br>
Host：浏览器通过这个头告诉服务器，想访问哪台主机<br>
If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间<br>
Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的  可以用于防盗链<br>
Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接<br>
Cache-Control:  指定所有缓存机制在整个请求/响应链中必须服从的指令，max-age=5 ,5s内访问不用去服务器</p>
</blockquote>
<h1 id="HTTP响应"><a class="header-anchor" href="#HTTP响应"></a>HTTP响应</h1>
<h2 id="HTTP响应包括的内容"><a class="header-anchor" href="#HTTP响应包括的内容"></a>HTTP响应包括的内容</h2>
<p>一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、消息头部分、以及实体内容 。</p>
<p><img src="http://qiniu.tung7.com/1449512871.jpg" alt="QQ截图20151208022511.jpg"></p>
<h2 id="HTTP响应的细节——状态行"><a class="header-anchor" href="#HTTP响应的细节——状态行"></a>HTTP响应的细节——状态行</h2>
<p>状态行格式： <strong>HTTP版本号　状态码　原因叙述</strong></p>
<p>状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类，如下所示：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>100 ~ 199</td>
<td>接受到请求，需要提交下一次请求才可以完成请求过程</td>
</tr>
<tr>
<td>200 ~ 299</td>
<td>表示成功接受请求，并完成整个处理过程，常用的是200</td>
</tr>
<tr>
<td>300 ~ 399</td>
<td>为了完成请求需要进一步细化请求，如资源已经移动到一个新地址（跳转） 常用302 304 307</td>
</tr>
<tr>
<td>400 ~ 499</td>
<td>客户端请求有错误， 常用404</td>
</tr>
<tr>
<td>499 ~ 599</td>
<td>服务端出现错误，常用500</td>
</tr>
</tbody>
</table>
<h2 id="HTTP响应细节——常用响应头"><a class="header-anchor" href="#HTTP响应细节——常用响应头"></a>HTTP响应细节——常用响应头</h2>
<p>HTTP响应中的常用响应头(消息头)</p>
<blockquote>
<p>Location: 服务器通过这个头，来告诉浏览器跳到哪里<br>
Server：服务器通过这个头，告诉浏览器服务器的型号<br>
Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式<br>
Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度<br>
Content-Language: 服务器通过这个头，告诉浏览器语言环境<br>
Content-Type：服务器通过这个头，告诉浏览器回送数据的类型<br>
Refresh：服务器通过这个头，告诉浏览器定时刷新<br>
Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据<br>
Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的<br>
Expires: -1 控制浏览器不要缓存<br>
Cache-Control: no-cache <br>
Pragma: no-cache</p>
</blockquote>
<h1 id="在服务端设置响应头来控制客户端浏览器的行为"><a class="header-anchor" href="#在服务端设置响应头来控制客户端浏览器的行为"></a>在服务端设置响应头来控制客户端浏览器的行为</h1>
<h2 id="设置Location响应头，实现请求重定向"><a class="header-anchor" href="#设置Location响应头，实现请求重定向"></a>设置Location响应头，实现请求重定向</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setStatus(<span class="hljs-number">302</span>);<span class="hljs-comment">//设置服务器的响应状态码</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *设置响应头，服务器通过 Location这个头，来告诉浏览器跳到哪里，这就是所谓的请求重定向</span><br><span class="hljs-comment">         */</span><br>        response.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;/re/1.jsp&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当访问该servlet地址时，浏览其会再次访问我们在上面设置的&quot;/re/1.jsp&quot;，也就是重定向到1.jsp。如下是响应行：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">302</span> Moved Temperarily<br></code></pre></td></tr></table></figure>
<h2 id="设置Content-Encoding响应头，告诉浏览器数据的压缩格式"><a class="header-anchor" href="#设置Content-Encoding响应头，告诉浏览器数据的压缩格式"></a>设置Content-Encoding响应头，告诉浏览器数据的压缩格式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *1、使用GZIPOutputStream流来压缩数据</span><br><span class="hljs-comment"> *2、设置响应头Content-Encoding来告诉浏览器，服务器发送回来的数据压缩后的格式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdabcdabcdabcdabcdabcdab&quot;</span> +<br>                <span class="hljs-string">&quot;cdabcdabcdabcdabcdabcdabcdabcdabc&quot;</span> +<br>                <span class="hljs-string">&quot;dabcdabcdabcdabcdabcdabcdabcdabc&quot;</span> +<br>                <span class="hljs-string">&quot;dabcdabcdabcdabcdabcdabcdabcdabcdab&quot;</span> +<br>                <span class="hljs-string">&quot;cdabcdabcdabcdabcdabcdabcdabcdabcdab&quot;</span> +<br>                <span class="hljs-string">&quot;cdabcdabcdabcdabcdabcdabcdabcdabcdab&quot;</span> +<br>                <span class="hljs-string">&quot;cdabcdabcdabcdabcdabcdabcdabcdabcdab&quot;</span> +<br>                <span class="hljs-string">&quot;cdabcdabcdabcdabcdabcdabcdabcdabcdabcd&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;原始数据的大小为：&quot;</span> + data.getBytes().length);<br>        <br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">GZIPOutputStream</span> <span class="hljs-variable">gout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPOutputStream</span>(bout); <span class="hljs-comment">//buffer</span><br>        gout.write(data.getBytes());<br>        gout.close();<br>        <span class="hljs-comment">//得到压缩后的数据</span><br>        <span class="hljs-type">byte</span> g[] = bout.toByteArray();<br>        response.setHeader(<span class="hljs-string">&quot;Content-Encoding&quot;</span>, <span class="hljs-string">&quot;gzip&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Content-Length&quot;</span>,g.length +<span class="hljs-string">&quot;&quot;</span>);<br>        response.getOutputStream().write(g);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="http://qiniu.tung7.com/1449513936.jpg" alt="QQ截图20151208024505.jpg"></p>
<p>原始数据大小272，将近10倍，节约了90%的宽带，实际上没有这么多一般有40-60%。</p>
<p>我们可以在服务器端进行GZIP压缩，如果浏览器支持gzip解压（Accept-Encoding：gzip）那么浏览器会自动帮我们解压。详情见<a href="http://www.tung7.com/post-107.html">使用gzip提高javaweb应用性能</a></p>
<h2 id="设置content-type响应头，指定回送数据类型"><a class="header-anchor" href="#设置content-type响应头，指定回送数据类型"></a>设置content-type响应头，指定回送数据类型</h2>
<p>先来看看前面的一个请求头</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure>
<p>这个请求头表示浏览器能够支持的 MIME 类型。MIME的英文全称是 Multipurpose Internet Mail Extensions（多功能 Internet 邮件扩充服务），最早用于邮件。</p>
<p>**t****ext/html,application/xhtml+xml,application/xml **都是 MIME 类型，也可以称为媒体类型和内容类型，斜杠前面的是 type（类型），斜杠后面的是 subtype（子类型）；type 指定大的范围，subtype 是 type 中范围更明确的类型。Text表示文本信息，文本消息可以是多种字符集和或者多种格式的，Application表示应用程序数据或者二进制数据。</p>
<p>**q=0.9 **表示权重是0.9 (0&lt;q&lt;1), q越大，表示&quot;；&quot;前的指示权重越高,请求越倾向于获得该指示所表示的内容。text/html, application/xhtml+xml, application/xml 的权重为0.9, */*的权重为0.8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;image/jpeg&quot;</span>);<span class="hljs-comment">//使用content-type响应头指定发送给浏览器的数据类型为&quot;image/jpeg&quot;</span><br>        <span class="hljs-comment">//读取02.jpg这张图片，返回一个输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/img/02.jpg&quot;</span>);<br>        <span class="hljs-type">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<span class="hljs-comment">//得到输出流</span><br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//读取输入流(in)里面的内容存储到缓冲区(buffer)</span><br>            out.write(buffer, <span class="hljs-number">0</span>, len);<span class="hljs-comment">//将缓冲区里面的内容输出到浏览器</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="http://qiniu.tung7.com/1449515437.jpg" alt="QQ截图20151208031022.jpg"></p>
<h2 id="设置refresh响应头，让浏览器定时刷新"><a class="header-anchor" href="#设置refresh响应头，让浏览器定时刷新"></a>设置refresh响应头，让浏览器定时刷新</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 设置refresh响应头，让浏览器每隔3秒定时刷新</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// response.setHeader(&quot;refresh&quot;, &quot;3&quot;);</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 设置refresh响应头，让浏览器3秒后跳转到http://www.baidu.com</span><br><span class="hljs-comment">         */</span><br>        response.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>, <span class="hljs-string">&quot;3;url=&#x27;http://www.baidu.com&#x27;&quot;</span>);<br>        response.getWriter().write(<span class="hljs-string">&quot;gacl&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(request, response);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设置content-disposition响应头，让浏览器下载文件"><a class="header-anchor" href="#设置content-disposition响应头，让浏览器下载文件"></a>设置content-disposition响应头，让浏览器下载文件</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 设置content-disposition响应头，让浏览器下载文件</span><br><span class="hljs-comment">         */</span><br>        response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=xxx.jpg&quot;</span>);<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/img/1.jpg&quot;</span>);<br>        <span class="hljs-type">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(request, response);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>访问该servlet的链接的时候，浏览其会弹出下载框。但是我们又时候发现单纯设置content-disposition响应头，不能弹出下载框。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Content-<span class="hljs-built_in">type</span>:application/vnd.ms-excel<br>Content-Disposition:attachment;filename=名称.xls<br></code></pre></td></tr></table></figure>
<p>这时，会直接打开xls文件，而不询问是否下载。解决办法是将Content-type设置为application/octet-stream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Content-<span class="hljs-built_in">type</span>:application/octet-stream .<br>Content-Disposition:attachment;filename=名称.xls<br></code></pre></td></tr></table></figure>
<p>这样浏览器就会弹出下载窗口了。原因是用户电脑上安装了office，浏览器能识别application/octet-stream类型。</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP发送FIN后收不到ACK会发生什么</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/TCP%E5%8F%91%E9%80%81FIN%E5%90%8E%E6%94%B6%E4%B8%8D%E5%88%B0ACK%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<p>如果接收不到</p>
<p>下列表格分为两部分：第一部分是客户端的FIN未能到达Server。第二部分是客户端接收不到服务端对FIN的ACK应答。</p>
<table>
<thead>
<tr>
<th>–</th>
<th>Server(111)</th>
<th>Client(108)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>nc -l 9999</code></td>
<td>`cat /dev/zero</td>
<td>nc 192.168.0.111 9999`</td>
</tr>
<tr>
<td></td>
<td></td>
<td>等待一段时间</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>iptables -A INPUT -p tcp -s 192.168.0.111 --tcp-flags ACK,FIN ACK -j DROP</code></td>
<td>把来自服务端的FIN=1 ACK=1报文DROP掉</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>killall nc</code></td>
<td>促使Client发送FIN请求（实际上会丢失）</td>
</tr>
<tr>
<td></td>
<td>ESTABLISHED</td>
<td>FIN_WAIT1</td>
<td>说明Client的FIN并没有到达Server</td>
</tr>
<tr>
<td></td>
<td>ESTABLISHED</td>
<td>自动销毁</td>
<td>超时后不会进入TIME_WAIT,直接销毁</td>
</tr>
<tr>
<td></td>
<td>----</td>
<td>----</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>nc -l 9999</code></td>
<td><code>nc -vn 192.168.0.111 9999</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>iptables -A INPUT -p tcp -s 192.168.0.111 --tcp-flags ACK ACK -j DROP</code></td>
<td>把来自服务端的ACK=1报文DROP掉</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>killall nc</code></td>
<td>促使Client发送FIN请求</td>
</tr>
<tr>
<td></td>
<td>LAST_ACK</td>
<td>FIN_WAIT1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>自动销毁</td>
<td>自动销毁</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="Linux下FIN-WAIT1，FIN-WAIT2超时时间"><a class="header-anchor" href="#Linux下FIN-WAIT1，FIN-WAIT2超时时间"></a>Linux下FIN_WAIT1，FIN_WAIT2超时时间</h1>
<ul>
<li>tcp_fin_timeout</li>
</ul>
<blockquote>
<p>tcp_fin_timeout (integer; default: 60; since Linux 2.2)<br>
This specifies how many seconds to wait for a final FIN packet before the socket is forcibly closed. This is<br>
strictly a violation of the TCP specification, but required to prevent denial-of-service attacks. In Linux 2.2,<br>
the default value was 180.</p>
</blockquote>
<ul>
<li>tcp_orphan_retries
<ul>
<li>This value influences the timeout of a locally closed TCP connection,<br>
when RTO retransmissions remain unacknowledged.<br>
See tcp_retries2 for more details.  The default value is 8.<br>
If your machine is a loaded WEB server,<br>
you should think about lowering this value, such sockets<br>
may consume significant resources. Cf. tcp_max_orphans.</li>
<li>这个参数表示<strong>如果一直都收不到针对FIN的ACK，那么在彻底销毁这个FIN_WAIT1的连接前，等待几轮RTO退避</strong>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>FIN_WAIT1,FIN_WAIT2,TIME_WAIT和LAST_ACK的超时问题</title>
    <url>/POST/FIN_WAIT1,FIN_WAIT2,TIME_WAIT%E5%92%8CLAST_ACK%E7%9A%84%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="如果FIN-WAIT1等不到ACK"><a class="header-anchor" href="#如果FIN-WAIT1等不到ACK"></a>如果FIN_WAIT1等不到ACK</h1>
<h1 id="如果FIN-WAIT2等不到FIN"><a class="header-anchor" href="#如果FIN-WAIT2等不到FIN"></a>如果FIN_WAIT2等不到FIN</h1>
<h1 id="如果LAST-ACK等不到ACK"><a class="header-anchor" href="#如果LAST-ACK等不到ACK"></a>如果LAST_ACK等不到ACK</h1>
<p>在tcp协议中处于last_ack状态的连接，如果一直收不到对方的ack，会一直处于这个状态吗？ - JCRunner的回答 - 知乎 <a href="https://www.zhihu.com/question/27564314/answer/162476313">https://www.zhihu.com/question/27564314/answer/162476313</a></p>
<h1 id="CLOSE-WAIT与TIME-WAIT过多会影响什么"><a class="header-anchor" href="#CLOSE-WAIT与TIME-WAIT过多会影响什么"></a>CLOSE_WAIT与TIME_WAIT过多会影响什么</h1>
<p>服务端close-wait或者time-wait状态过多会导致什么样的后果？ - 果冻虾仁的回答 - 知乎 <a href="https://www.zhihu.com/question/298214130/answer/1090787813">https://www.zhihu.com/question/298214130/answer/1090787813</a></p>
]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP2.0的新变化</title>
    <url>/POST/HTTP2.0%E7%9A%84%E6%96%B0%E5%8F%98%E5%8C%96.html</url>
    <content><![CDATA[<p>SPDY协议，RFC7540</p>
<p>与HTTP1.1的主要区别</p>
<ul>
<li>从文本协议变为了二进制协议，引入了帧Frame的概念</li>
<li>实现了多路复用，无序的阻塞的。解决了队头阻塞问题head-of-line blocking</li>
<li>支持报头压缩，降低开销</li>
<li>具有主动推送的功能，可以提前将HTML相应中的js,css,img等资源提前推送给浏览器。</li>
</ul>
]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>HTTP2</tag>
      </tags>
  </entry>
  <entry>
    <title>两阶段提交的细致分解</title>
    <url>/POST/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E7%BB%86%E8%87%B4%E5%88%86%E8%A7%A3.html</url>
    <content><![CDATA[<p>keywords: 原子提交，原子提交协议</p>
<p>原子提交（atomic commit）：在分布式系统中，为了维护事务的原子性，所有节点对于事务的结果必须达成共识，要么所有节点全部提交事务，要么所有节点全部放弃事务。这个就叫做原子提交。</p>
<p>原子提交协议，是参与分布式事务节点所使用的一个协作过程，它使多个节点能够在提交事务还是放弃事务上达成共识。</p>
<p>两阶段提交（two-phase commit）：是一种跨多节点实现<strong>原子提交</strong>的算法，即确保所有节点提交或所有节点放弃。它是最常用的原子提交协议。</p>
<p>在单阶段提交的方式中，客户端要求提交事务时，不允许任何节点单方面放弃事务。一般来说，阻止节点提交它自己那部分事务的原因通常与并发控制问题有关（加锁后的死锁问题，需要将事务放弃）。</p>
<p>两阶段提交的设计出发点，是允许任何一个参与者<strong>自行放弃</strong>它自己的那部分事务。</p>
<p>由于事务的原子性要求，如果部分事务别放弃，那么整个分布式事务也必须被放弃。</p>
<p>在两阶段提交的第一阶段，每个参与者投票表决事务时放弃还是提交。一旦参与者投票要求提交事务，那么就不允许放弃事务（任何情况都不允许，宕机，硬盘空间不足，甚至断电都不允许放弃。这需要在工程实现上进行保证）。也就是说，第一阶段中，每个参与者对自己那部分的事务有单方面放弃的权力，放弃则投票放弃整个事务，否则投票提交整个事务。参与者一旦投票完成，就失去了事务单方面的权力，并且这个权力被统一转移到了协调者。协调者依据投票结果，确定一个共同的决定（共识）：是提交事务，还是放弃事务。</p>
<p>协议在无故障的情况下相当简单，但是协议必须在各种故障时也能够正常工作。这个故障包括节点崩溃，消息丢失或者节点暂时失联等等。</p>
<p><a href="https://zhuanlan.zhihu.com/p/358576217">Mysql基于两阶段实现redo、binlog日志一致性 - bluesky的文章 - 知乎 </a></p>
<h1 id="过程"><a class="header-anchor" href="#过程"></a>过程</h1>
<p>角色：客户端client，协调者coordinator，参与者participant</p>
<p>客户端向启动一个分布式事务，它向协调者请求一个事务ID，并将此事务消息发送给所有参与者。</p>
<p>在实际的分布式数据库中，开始两阶段提交前由协调者向若干参与者发送SQL请求或执行计划，包括获取行锁，生成redo数据等操作。</p>
<p>第一阶段：投票阶段/准备阶段，Prepare阶段</p>
<p>第二阶段：完成阶段，Commit阶段</p>
<h1 id="局限"><a class="header-anchor" href="#局限"></a>局限</h1>
<p>阻塞：2PC是一个阻塞式的协议，在所有参与者执行commit/abort之前的任何时间内协调者宕机，都将阻塞事务进程，必须等待协调者恢复后，事务才能继续执行。</p>
<p>延迟：协调者要持久化事务的commit/abort状态后才能发送commit/abort命令，因此全程至少2次RPC延迟（prepare+commit），和3次持久化数据延迟（prepare写日志+协调者状态持久化+commit写日志）。</p>
<h2 id="如何判断binlog和redolog是否达成了一致"><a class="header-anchor" href="#如何判断binlog和redolog是否达成了一致"></a>如何判断binlog和redolog是否达成了一致#</h2>
<p><strong>这个知识点可是纯干货！</strong></p>
<p>当MySQL写完redolog并将它标记为prepare状态时，并且会在redolog中记录一个XID，它全局唯一的标识着这个事务。而当你设置<code>sync_binlog=1</code>时，做完了上面第一阶段写redolog后，mysql就会对应binlog并且会直接将其刷新到磁盘中。</p>
<p>下图就是磁盘上的row格式的binlog记录。binlog结束的位置上也有一个XID。</p>
<p>只要这个XID和redolog中记录的XID是一致的，MySQL就会认为binlog和redolog逻辑上一致。就上面的场景来说就会commit，而如果仅仅是rodolog中记录了XID，binlog中没有，MySQL就会RollBack</p>
<p><img src="https://pic2.zhimg.com/80/v2-217bcf3a4d081e4734b12c32b5a05d55_1440w.jpg" alt="img"></p>
<p>(1)prepare阶段把page物理修改记录到redo buffer，(2)将逻辑操作写binlog缓存区并直接落盘到磁盘binlog文件，(3)commit阶段才允许主线程将redo buffer里的数据刷新到磁盘redo log文件。无论是(1)(2)之间宕机还是(2)(3)之间宕机，都会回滚，(3)之后才会提交。是这样的吗？</p>
<blockquote>
<p>Prepare阶段，将Redo Log写入文件，并刷入磁盘，记录上内部XA事务的ID，同时将Redo Log状态设置为Prepare。Redo Log写入成功后，再将Binlog同样刷入磁盘，记录XA事务ID。</p>
<p>Commit阶段，向磁盘中的Redo Log写入Commit标识，表示事务提交。然后执行器调用存储引擎的接口提交事务。这就是整个过程。</p>
<h3 id="验证2PC机制的可用性"><a class="header-anchor" href="#验证2PC机制的可用性"></a><strong>验证2PC机制的可用性</strong></h3>
<p>这就是2PC提交Redo Log和Binlog的过程，那在这个期间发生了异常，2PC这套机制真的能保证数据一致性吗？</p>
<p>假设Redo Log刷入成功了，但是还没来得及刷入Binlog MySQL就挂了。此时重启之后会发现Redo Log并没有Commit标识，此时根据记录的XA事务找到这个事务，进行回滚。</p>
<p>如果Redo Log刷入成功，而且Binlog也刷入成功了，但是还没有来得及将Redo Log从Prepare改成Commit MySQL就挂了，此时重启会发现虽然Redo Log没有Commit标识，但是通过XID查询到的Binlog却已经成功刷入磁盘了。</p>
<p>此时，虽然Redo Log没有Commit标识，MySQL也要提交这个事务。因为Binlog一旦写入，就可能会被从库或者任何消费Binlog的消费者给消费。如果此时MySQL不提交事务，则可能造成数据不一致。而且目前Redo Log和Binlog从数据层面上，其实已经Ready了，只是差个标志位。</p>
</blockquote>
]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>分布式系统理论</tag>
      </tags>
  </entry>
  <entry>
    <title>初尝Prometheus与Grafana监控Docker</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/%E5%88%9D%E5%B0%9DPrometheus%E4%B8%8EGrafana%E7%9B%91%E6%8E%A7Docker.html</url>
    <content><![CDATA[<h1 id="监控体系需要的四个服务"><a class="header-anchor" href="#监控体系需要的四个服务"></a>监控体系需要的四个服务</h1>
<ul>
<li>n * Node Exporter (收集Host硬件和操作系统信息)</li>
<li>n * cAdvisor (负责收集Host上运行的容器信息)</li>
<li>1 * Prometheus Server(普罗米修斯监控主服务器 )</li>
<li>1 * Grafana (展示普罗米修斯监控界面）</li>
</ul>
<p>被监控的服务器上启动Node Exporter (收集Host硬件和操作系统信息) 以及 cAdvisor (负责收集Host上运行的容器信息)即可</p>
<p>然后在prometheus.yml配置文件中配置上targets地址即可。</p>
<h1 id="规划"><a class="header-anchor" href="#规划"></a>规划</h1>
<p>目前只有一个Host(192.168.0.108)</p>
<p>NodeExporter端口9100</p>
<p>cAdvisor端口8080</p>
<p>Prometheus端口9090</p>
<p>Grafana端口3000</p>
<p><img src="https://tximgcdn.tung7.com/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker_20210804195720_642447.png" alt="部署规划"></p>
<h1 id="启动NodeExporter"><a class="header-anchor" href="#启动NodeExporter"></a>启动NodeExporter</h1>
<p><a href="https://github.com/prometheus/node_exporter/">https://github.com/prometheus/node_exporter/</a></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">docker run -d -p <span class="hljs-number">9100</span>:<span class="hljs-number">9100</span> <span class="hljs-string">\</span><br>-v <span class="hljs-string">&quot;/proc:/host/proc&quot;</span> <span class="hljs-string">\</span><br>-v <span class="hljs-string">&quot;/sys:/host/sys&quot;</span> <span class="hljs-string">\</span><br>-v <span class="hljs-string">&quot;/:/rootfs&quot;</span> <span class="hljs-string">\</span><br>-v <span class="hljs-string">&quot;/etc/localtime:/etc/localtime&quot;</span> <span class="hljs-string">\</span><br>--net=host <span class="hljs-string">\</span><br>--name=node-exporter <span class="hljs-string">\</span><br>prom/node-exporter <span class="hljs-string">\</span><br>--path.procfs /host/proc <span class="hljs-string">\</span><br>--path.sysfs /host/sys <span class="hljs-string">\</span><br>--collector.filesystem.ignored-mount-points <span class="hljs-string">&quot;^/(sys|proc|dev|host|etc)($|/)&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="启动cAdvisor"><a class="header-anchor" href="#启动cAdvisor"></a>启动cAdvisor</h1>
<p><a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">docker run -d \<br>--volume=<span class="hljs-regexp">/:/rootfs</span><span class="hljs-symbol">:ro</span> \<br>--volume=<span class="hljs-regexp">/var/run</span><span class="hljs-symbol">:/var/run</span><span class="hljs-symbol">:rw</span> \<br>--volume=<span class="hljs-regexp">/sys:/sys</span><span class="hljs-symbol">:ro</span> \<br>--volume=<span class="hljs-regexp">/var/lib</span><span class="hljs-regexp">/docker/</span><span class="hljs-symbol">:/var/lib/docker</span><span class="hljs-symbol">:ro</span> \<br>--publish=<span class="hljs-number">8080</span><span class="hljs-symbol">:</span><span class="hljs-number">8080</span> \<br>--detach=<span class="hljs-literal">true</span> \<br>--name=cadvisor \<br>--net=host \<br>-v <span class="hljs-string">&quot;/etc/localtime:/etc/localtime&quot;</span> \<br>google/<span class="hljs-symbol">cadvisor:</span>latest<br></code></pre></td></tr></table></figure>
<h1 id="启动Prometheus"><a class="header-anchor" href="#启动Prometheus"></a>启动Prometheus</h1>
<p><a href="https://prometheus.io/">Prometheus - Monitoring system &amp; time series database</a></p>
<p>prometheus的配置文件，主要是填写监听的地址（所有被监控机器的NodeExporter服务与cAdvisor服务的列表）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># my global config</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br><br><span class="hljs-comment"># Alertmanager configuration</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>          <span class="hljs-comment"># - alertmanager:9093</span><br><br><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br><br><span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br>    <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;docker-cluster&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;192.168.0.108:9100&quot;</span>,<span class="hljs-string">&quot;192.168.0.108:8080&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>启动,注意映射配置文件的目录</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">docker run -d -p <span class="hljs-number">9090</span>:<span class="hljs-number">9090</span> \<br>-v <span class="hljs-regexp">/opt/</span>sc<span class="hljs-regexp">/runner/</span>prometheus.yml:<span class="hljs-regexp">/etc/</span>prometheus/prometheus.yml \<br>-v <span class="hljs-string">&quot;/etc/localtime:/etc/localtime&quot;</span> \<br>--name prometheus \<br>--net=host \<br>prom/prometheus<br></code></pre></td></tr></table></figure>
<h1 id="启动Grafana"><a class="header-anchor" href="#启动Grafana"></a>启动Grafana</h1>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">docker run -d -i -p <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span> <span class="hljs-string">\</span><br>-v <span class="hljs-string">&quot;/etc/localtime:/etc/localtime&quot;</span> <span class="hljs-string">\</span><br>-e <span class="hljs-string">&quot;GF_SERVER_ROOT_URL=http://grafana.server.name&quot;</span> <span class="hljs-string">\</span><br>-e <span class="hljs-string">&quot;GF_SECURITY_ADMIN_PASSWORD=admin8888&quot;</span> <span class="hljs-string">\</span><br>--name grafana <span class="hljs-string">\</span><br>--net=host <span class="hljs-string">\</span><br>grafana/grafana<br></code></pre></td></tr></table></figure>
<p>用户名密码admin/admin8888</p>
<h2 id="配置Prometheus作为Datasource"><a class="header-anchor" href="#配置Prometheus作为Datasource"></a>配置Prometheus作为Datasource</h2>
<p>浏览器访问Gafana的地址192.168.0.108:3000。</p>
<p>Configuration - Data sources - Add data source - 选择Prometheus类型 - 填写URL为：192.168.0.108:9090即可，其它可以默认</p>
<h2 id="导入Dashborad"><a class="header-anchor" href="#导入Dashborad"></a>导入Dashborad</h2>
<p>在下面网站搜索到想要添加的Dashborad。</p>
<p>推荐179，893，8919</p>
<p><a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=docker">Grafana Dashboards - discover and share dashboards for Grafana. | Grafana Labs</a></p>
<p><img src="https://tximgcdn.tung7.com/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker_20210804201558_324957.png" alt=""></p>
<p><img src="https://tximgcdn.tung7.com/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker/%E5%88%9D%E5%B0%9DPrometheus+Grafana%E7%9B%91%E6%8E%A7Docker_20210810190711_869122.png" alt=""></p>
<h1 id="Docker-启动-cAdvisor-报错问题解决"><a class="header-anchor" href="#Docker-启动-cAdvisor-报错问题解决"></a>Docker 启动 cAdvisor 报错问题解决</h1>
<blockquote>
<p>Failed to start container manager: inotify_add_watch<br>
/sys/fs/cgroup/cpuacct,cpu: no such file or directory</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">mount -o remount,rw <span class="hljs-string">&#x27;/sys/fs/cgroup&#x27;</span><br>ln -s <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/</span>cpu,cpuacct <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/</span>cpuacct,cpu<br></code></pre></td></tr></table></figure>
<p>然后重启容器即可。sd</p>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP2与Java9</title>
    <url>/POST/HTTP2.0%E4%B8%8EJava.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>HTTP2</tag>
        <tag>Java9</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP的ISN需要随机生成？</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E7%9A%84ISN%E9%9C%80%E8%A6%81%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90.html</url>
    <content><![CDATA[<ul>
<li>避免ISN预测，防止TCP Reset攻击?
<ul>
<li>防范的关键是在IP层通信的加密?</li>
</ul>
</li>
<li>ISN的生成机制</li>
</ul>
<hr>
<p>下面摘抄RFC793的原文</p>
<blockquote>
<p>Initial Sequence Number Selection</p>
<p>The protocol places no restriction on a particular connection being<br>
used over and over again.  A connection is defined by a pair of<br>
sockets.  New instances of a connection will be referred to as<br>
incarnations of the connection.  The problem that arises from this is<br>
– “how does the TCP identify duplicate segments from previous<br>
incarnations of the connection?”  This problem becomes apparent if the<br>
connection is being opened and closed in quick succession, or if the<br>
connection breaks with loss of memory and is then reestablished.</p>
<p>To avoid confusion we must prevent segments from one incarnation of a<br>
connection from being used while the same sequence numbers may still<br>
be present in the network from an earlier incarnation.  We want to<br>
assure this, even if a TCP crashes and loses all knowledge of the<br>
sequence numbers it has been using.  When new connections are created,<br>
an initial sequence number (ISN) generator is employed which selects a<br>
new 32 bit ISN.  The generator is bound to a (possibly fictitious) 32<br>
bit clock whose low order bit is incremented roughly every 4<br>
microseconds.  Thus, the ISN cycles approximately every 4.55 hours.<br>
Since we assume that segments will stay in the network no more than<br>
the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55<br>
hours we can reasonably assume that ISN’s will be unique.</p>
</blockquote>
<p>一个长度为32bit,每4微妙加一的计数器来选定ISN。然而，这个ISN的规律是可以轻易预测的，从而伪造出一个可以扰乱并注入TCP连接的TCP Segment（只要有正确的Socket和Seq Num）。因此，RFC 793这种选定ISN的做法并不可取。</p>
<p>而后，RFC1948中提出了一个较好的初始化序列号ISN随机生成算法：</p>
<p><strong>ISN = M + F(localhost, localport, remotehost, remoteport).</strong></p>
<p>其中：M是一个计时器，F是一个Hash算法。</p>
<p>当前，大部分操作系统都使用这种半随机的方式去选择ISN。使用“计时器 + 随机偏移量”的方法来选定ISN。</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab | TCP建立连接后链路断开了会发生什么</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%E9%93%BE%E8%B7%AF%E6%96%AD%E5%BC%80%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<ul>
<li>TCP连接是虚拟的，抽象的</li>
<li>对底层链路出现的断开是无感知的，会导致出现假连接</li>
<li>KILL命令直接杀死服务端程序后的连接状态</li>
<li>断网断电后的连接状态</li>
</ul>
<hr>
<p>TCP的连接是一个抽象的概念，RFC793文档中将连接称之为sockets,序号,窗口大小这类信息的组合。</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p>实际上可以这么理解：连接就是在通信双端传输状态（状态机）与状态对应信息（序号，窗口，选项等等）的维持，它是抽象的，TCP端对端通信实际上不存在一条可靠的物理连接，它总要依托下层不可靠的IP层，数据链路层。因此，出现了这个疑问：当连接建立后，物理链路断开了会发生什么？</p>
<ul>
<li>使用<code>kill -9</code>直接杀死服务端程序</li>
<li>拔网线，服务器断电</li>
</ul>
<h1 id="KILL命令直接杀死服务端程序后的连接状态"><a class="header-anchor" href="#KILL命令直接杀死服务端程序后的连接状态"></a>KILL命令直接杀死服务端程序后的连接状态</h1>
<ul>
<li>Server启动服务程序</li>
<li>tcpdump在Client侧进行抓包</li>
<li>Client连接服务程序</li>
<li>杀死服务程序</li>
</ul>
<p>在Server上使用<code>netcat</code>启动一个服务程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># nc -l 9999</span><br></code></pre></td></tr></table></figure>
<p>在Client侧使用<code>tcpdump</code>抓包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tcpdump -i any -n -# port 9999</span><br></code></pre></td></tr></table></figure>
<p>再使用<code>netcat</code>作为Client连接Server的服务程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># nc -vn 192.168.0.108 9999</span><br>Connection to 192.168.0.108 9999 port [tcp/*] succeeded!<br></code></pre></td></tr></table></figure>
<p>使用<code>netstat</code>命令查看连接信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># netstat -antlp | grep 9999</span><br>tcp        0      0 0.0.0.0:9999            0.0.0.0:*               LISTEN      12650/nc            <br>tcp        0      0 192.168.0.108:53756     192.168.0.108:9999      ESTABLISHED 12671/nc            <br>tcp        0      0 192.168.0.108:9999      192.168.0.108:53756     ESTABLISHED 12650/nc    <br></code></pre></td></tr></table></figure>
<p>可以看出Server的服务程序PID=12650，第二条记录为Client到Server的连接，第三条为Server到Client的连接。</p>
<p>杀死服务程序<code>kill -9 12650</code>后，再次查看连接信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># netstat -antlp | grep 9999</span><br>tcp        0      0 192.168.0.108:53756     192.168.0.108:9999      CLOSE_WAIT  12671/nc            <br>tcp        0      0 192.168.0.108:9999      192.168.0.108:53756     FIN_WAIT2   - <br></code></pre></td></tr></table></figure>
<p>杀死进程使得Server发送FIN请求，连接状态变为<code>FIN_WAIT1</code>-&gt;<code>FIN_WAIT2</code>。Client上的连接变为<code>CLOSE_WAIT</code>，说明它收到了FIN请求并回复ACK。</p>
<p>查看tcpdump抓包信息：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> <span class="hljs-number">08</span>:<span class="hljs-number">03</span>:<span class="hljs-number">47.983746</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span> &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct: Flags [S], seq <span class="hljs-number">2732082131</span>, win <span class="hljs-number">43690</span><br><span class="hljs-symbol">2 </span> <span class="hljs-number">08</span>:<span class="hljs-number">03</span>:<span class="hljs-number">47.983789</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span>: Flags [S.], seq <span class="hljs-number">2892591615</span>, ack <span class="hljs-number">2732082132</span>, win <span class="hljs-number">43690</span><br><span class="hljs-symbol">3 </span> <span class="hljs-number">08</span>:<span class="hljs-number">03</span>:<span class="hljs-number">47.983824</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span> &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct: Flags [.], ack <span class="hljs-number">1</span>, win <span class="hljs-number">342</span><br><span class="hljs-symbol">4 </span> <span class="hljs-number">08</span>:<span class="hljs-number">04</span>:<span class="hljs-number">01.168828</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span>: Flags [F.], seq <span class="hljs-number">1</span>, ack <span class="hljs-number">1</span>, win <span class="hljs-number">342</span><br><span class="hljs-symbol">5 </span> <span class="hljs-number">08</span>:<span class="hljs-number">04</span>:<span class="hljs-number">01.169328</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span> &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct: Flags [.], ack <span class="hljs-number">2</span>, win <span class="hljs-number">342</span><br></code></pre></td></tr></table></figure>
<p>前三行是三次握手。后两行正是Server向Client发送的FIN请求。</p>
<blockquote>
<p>Server产生FIN请求的原因是，操作系统在进程退出的时候，会对其所有打开的文件描述符执行close()。对于TCP文件描述符而言，就是关闭连接，发送FIN请求，等待四次挥手的完成。</p>
<p>《unix 网络编程》里面写“TCP FIN sent by kernel when client is killed or crashed”。当程序被kill的时候，内核会发送fin包给对端。这样对端进入close_wait的状态，若epoll注册了HUP的事件，把连接关闭close_wait变为close；若没有处理，对端就有一个close_wait的状态，占用了fd。</p>
</blockquote>
<p>在经过了一段时间之后，再次查看连接状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># netstat -antlp | grep 9999</span><br>tcp        0      0 192.168.0.108:53756     192.168.0.108:9999      CLOSE_WAIT  12671/nc<br></code></pre></td></tr></table></figure>
<p>发现只剩下Client的连接，Server上<code>FIN_WAIT2</code>状态的连接已经消失。tcpdump抓包得知，Client并没有向Server发送FIN请求，那么也就说明Server的<code>FIN_WAIT2</code>状态有等待超时的能力，能够在超时后，自动销毁连接。</p>
<p>当Client在Server连接被销毁后，再次发送数据时，则会收到Server的RST请求。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span> <span class="hljs-number">08</span>:<span class="hljs-number">06</span>:<span class="hljs-number">28.504828</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span> &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct: Flags [P.], seq <span class="hljs-number">1</span>:<span class="hljs-number">3</span>, ack <span class="hljs-number">2</span>, win <span class="hljs-number">342</span><br><span class="hljs-symbol">7 </span> <span class="hljs-number">08</span>:<span class="hljs-number">06</span>:<span class="hljs-number">28.504888</span> IP <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.distinct &gt; <span class="hljs-number">192.168</span>.<span class="hljs-number">0.108</span>.<span class="hljs-number">58274</span>: Flags [R], seq <span class="hljs-number">2892591617</span>, win <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h1 id="断网断电后的连接状态"><a class="header-anchor" href="#断网断电后的连接状态"></a>断网断电后的连接状态</h1>
<p>这里使用两台机器进行试验，中间通过Router进行非直连连接。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">Client(<span class="hljs-number">188</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>A<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Router <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>B<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Server(<span class="hljs-number">108</span>)<br></code></pre></td></tr></table></figure>
<p>Server启动9999断开服务</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># nc -l 9999</span><br></code></pre></td></tr></table></figure>
<p>Client连接Server的9999服务</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># nc -vn 192.168.0.108 9999</span><br></code></pre></td></tr></table></figure>
<p>拔掉Server的网线后，在Client侧查看连接状态，依旧是<code>ESTABLISHED</code>状态</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># netstat -altn | grep 9999</span><br><span class="hljs-attribute">tcp4</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span>  <span class="hljs-number">192.168.0.188</span>.<span class="hljs-number">52210</span>    <span class="hljs-number">192.168.0.108</span>.<span class="hljs-number">9999</span>     ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>如果Client此时尝试发送数据，Client侧会不断进行重传，直到最后发送一个RST请求，报超时异常后，退出Client连接程序，销毁连接。在恢复Server网络，并等待一段时候后，使用<code>netstat</code>查看Server的连接状态，会发现Server到Client的连接将会一直都是<code>ESTABLISHED</code>状态。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># netstat -anltp | grep 9999</span><br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0.0.0:9999</span>            <span class="hljs-number">0.0.0.0</span>:*               LISTEN      <span class="hljs-number">10188</span>/nc            <br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">192.168.0.108:9999</span>      <span class="hljs-number">192.168.0.188:52210</span>     ESTABLISHED <span class="hljs-number">10188</span>/nc <br></code></pre></td></tr></table></figure>
<p>断电的操作和断网的操作是类似的。结果如下：</p>
<ul>
<li>Server断网后，若Server和Client均无数据传输，则Server网络恢复后（断开时长不超过TCP连接超时时间），双方已经能在原来的连接状态（ESTABLISHED）上继续传输数据。</li>
<li>Server断网后，若Client继续发送数据将会超时导致程序退出连接断开（会最后发出一个RST报文段）。至少是2MSL后，恢复Server网络，发现Server上的连接将会一直存在（暂不考虑保活机制），这就是<strong>假连接</strong>现象，假连接会一直占用资源无法释放，为了解决这个问题，TCP引入<strong>保活机制（Keepalive）</strong>，对没有进行通信的连接每隔一段时间进行检查，对失效的连接进行主动销毁。</li>
<li>Server断电后，若Client无数据传输，则Client上的连接状态（ESTABLISHED）将一直保持。但是，很明显的，因为Server侧断电后丢失了连接信息，这个连接已经无法再被重新使用。</li>
</ul>
<h1 id="FIN-WAIT2的超时时间"><a class="header-anchor" href="#FIN-WAIT2的超时时间"></a>FIN_WAIT2的超时时间</h1>
<p>Server主动关闭连接，在进入<code>FIN_WAIT2</code>阶段后，需要Client主动发送FIN请求，表示Client侧的连接可以关闭了。但是，如果Client一直不发送FIN请求呢？操作系统在实现层面会给FIN_WAIT2状态设置超时时间，通过调整内核参数<code>net.ipv4.tcp_fin_timeout</code>进行设置。在超时后，将会直接销毁连接。</p>
<p>实际上，服务器会经常遇到大量FIN_WAIT2状态连接不能及时释放的情况。原因本质上都是服务器作为主动关闭方，Client没有主动发送FIN请求。</p>
<h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1>
<p>试验体现了TCP连接是抽象的，它可以在物理链路断开后依旧保持状态。连接的生命周期就是双端状态机的协商与转换。底层链路的短时间断开，TCP连接是无感知的，这时的连接是假连接。但是双端只要不进行通信，不破坏断开前的连接信息，链路恢复后，假连接又会恢复为有效的连接，双端依旧可以在此连接上继续通信。</p>
<h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1>
<ul>
<li><a href="https://www.zhihu.com/answer/136153506">https://www.zhihu.com/answer/136153506</a></li>
</ul>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机-Java内存区域</title>
    <url>/POST/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>POST</category>
        <category>深入理解JAVA虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>TCP协议需要三次握手的主要原因</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/TCP%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0.html</url>
    <content><![CDATA[<hr>
<ul>
<li>建立连接
<ul>
<li>什么是连接</li>
<li>为什么要建立连接</li>
</ul>
</li>
<li>为什么要握手三次
<ul>
<li>解决old duplicated SYN问题</li>
<li>解决ISN协商问题</li>
</ul>
</li>
<li>半连接状态与RST</li>
</ul>
<hr>
<p>TCP建立连接阶段，需要进行俗称“三次握手”（three-way handshake）的协商过程。这里就引出两个问题。</p>
<ul>
<li>为什么TCP需要“三次握手”？
<ul>
<li>需要解释“三次握手”这个机制的原因</li>
</ul>
</li>
<li>为什么“三次握手”需要三次？
<ul>
<li>需要解释握手次数的细节</li>
</ul>
</li>
</ul>
<p>第一个问题的答案很简单，为了在不可靠的IP层上实现可靠性，通信双方需要对通信信息进行初始化和维持特定的状态。状态初始化的协商过程就是握手机制。这里的通信信息包含序号，窗口大小，选项信息等等，正是这些信息保证了TCP的可靠和流量控制的实现。</p>
<p>第二问题答案：通信双方要交换信息，必然是至少需要两次握手的。那么为什么需要第三次握手就是问题的核心。第一，主要是需要防止已失效的旧的SYN请求（old duplicated）再次到达服务端，导致连接错误建立（如初始序号ISN，窗口大小等等）的异常。其次，由于初始序号ISN的特殊性（必须由对方进行校验），必须要第三次握手，才能保证双方ISN交换成功。最后，三次的握手配合RST标志与半连接状态的设计，提供了异常回退，状态重置的可能，是稳定性的体现。</p>
<h1 id="连接与握手机制"><a class="header-anchor" href="#连接与握手机制"></a>连接与握手机制</h1>
<p>这一小节只讨论握手机制，不讨论具体几次握手。</p>
<h2 id="连接与建立连接"><a class="header-anchor" href="#连接与建立连接"></a>连接与建立连接</h2>
<p>TCP的设计目标就是一款可靠的，<strong>面向连接的</strong>传输层协议。</p>
<p>那什么是连接呢？**连接(connection)**的概念在RFC793文档中是这样暗示的：</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
<p>可靠性和流控机制需要在TCP通信双端初始化和维持特定状态信息。这些信息的组合就称为<strong>连接</strong>，包括双方socket，序号，窗口大小。</p>
</blockquote>
<p>因此，连接的建立就是通信双端对上述信息（sockets, seq, wnd）的协商并达到共识的过程。</p>
<blockquote>
<p>Since connections must be established between unreliable hosts and over the unreliable internet communication system, a handshake mechanism with clock-based sequence numbers is used to avoid erroneous initialization of connections.</p>
<p>由于连接必须在两个不可靠主机，并且在不可靠的IP体系上建立，所以需要一个基于时钟序号的握手机制来避免错误的连接初始化。</p>
</blockquote>
<p>由此看来，握手机制是用来隐藏底层的不可靠性质的。并且，这里提到了<em>一个细节</em>，SYN中的序号是基于时钟的。（<a href="/POST/%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E7%9A%84ISN%E9%9C%80%E8%A6%81%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90.html">为什么TCP的ISN需要随机生成 | Tung7 Note</a>)</p>
<h1 id="为什么是三次"><a class="header-anchor" href="#为什么是三次"></a>为什么是三次</h1>
<ul>
<li>防止旧的已失效的SYN请求，再次到达服务端。</li>
<li>ISN同步问题必须需要三次。</li>
<li>三次握手结合半连接设计，能提供状态回退的能力，也能避免服务端接收到SYN请求后就认为新连接建立了，空等数据而浪费资源的情况。</li>
</ul>
<h2 id="已失效的SYN再次到达"><a class="header-anchor" href="#已失效的SYN再次到达"></a>已失效的SYN再次到达</h2>
<p>为了两端能够同步序号，窗口大小，第一次和第二次握手是必不可少的，那为什么还需要第三次ACK回应呢？主要是为了防止旧的重复的已失效的SYN请求（客户端重发SYN，那么前一个SYN就是已失效的请求）再次到达服务端，因而产生错误（序号迷惑，窗口迷惑，选项迷惑等等问题）。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion. To deal with this, a special control message, reset, has been devised.  If the receiving TCP is in a  non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.</p>
<p>三次握手的主要（principal）原因就是避免旧的重复的连接初始化所引起的混淆。为了解决这个混淆问题，设计出了reset控制信息（RST标志位）。如果接收方在非同步状态（SYN-SENT, SYN-RECEIVED）接收到了RST报文，接收方就会回退到LISTEN状态。</p>
</blockquote>
<p>三次握手（配合半连接状态与RST）可以让连接状态有“回退”的可能，而两次握手是不能达到要求的。由此看来三次握手与半连接（half-open）状态是密不可分的。</p>
<p>下面直接用RFC文档中的原例子说明：</p>
<p><img src="https://tximgcdn.tung7.com/TCP%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0/TCP%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0_20210714224115_154222.png" alt="image-20210714224054097"></p>
<p>在第3行，一个旧的重复的SYN请求比第二行的SYN先到达TCP B，这是TCP B是无法区分这个SYN请求是不是旧的，只能响应ACK并且状态由LISTEN变为SYN-RECEIVED。TCP A发现TCP B响应回来的报文段中的ACK号不匹配，就直接响应RST=1，让TCP B回退到LISTEN状态。随后在第6行，原本正确的SYN请求到达TCP B后就能正常建立连接。但是如果，原本的SYN请求比RST先到达（也就是第5行和第6行互换），那么就会导致TCP B也响应一个RST。</p>
<h2 id="ISN的交换与验证"><a class="header-anchor" href="#ISN的交换与验证"></a>ISN的交换与验证</h2>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s.  The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.  The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>三次握手的另一个必要原因就是为了双方都能正确同步ISN。由于网络不存在一个全局时钟，并且通信双方都有自己的方式得到ISN。接收方是无法判断报文段是否是延误的失效的报文段，除非它记住上一个在连接中使用的序号（这是不可能实现的），所以接收方必须向发送方验证这个SYN。</p>
<h1 id="半连接状态"><a class="header-anchor" href="#半连接状态"></a>半连接状态</h1>
<h1 id="RST"><a class="header-anchor" href="#RST"></a>RST</h1>
<p>RST并不是一定有效的，除了在握手阶段，其他情况下RST包的SEQ序号必须在接收窗口中才有效，否则会被忽略掉。</p>
<blockquote>
<p>Reset Processing</p>
<p>In all states except SYN-SENT, all reset (RST) segments are validated<br>
by checking their SEQ-fields.  A reset is valid if its sequence number<br>
is in the window.  In the SYN-SENT state (a RST received in response<br>
to an initial SYN), the RST is acceptable if the ACK field<br>
acknowledges the SYN.</p>
<p>The receiver of a RST first validates it, then changes state.  If the<br>
receiver was in the LISTEN state, it ignores it.  If the receiver was<br>
in SYN-RECEIVED state and had previously been in the LISTEN state,<br>
then the receiver returns to the LISTEN state, otherwise the receiver<br>
aborts the connection and goes to the CLOSED state.  If the receiver<br>
was in any other state, it aborts the connection and advises the user<br>
and goes to the CLOSED state.</p>
</blockquote>
<h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1>
<ol>
<li>
<p><a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way">tcp - Why do we need a 3-way handshake? Why not just 2-way? - Network Engineering Stack Exchange</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc793#page-10">rfc793 (ietf.org)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础-TCP协议</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/TCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="传输层协议"><a class="header-anchor" href="#传输层协议"></a>传输层协议</h1>
<p>传输层的作用，<u>TCP协议的特点</u></p>
<h1 id="报文首部"><a class="header-anchor" href="#报文首部"></a>报文首部</h1>
<p>参考</p>
<h1 id="可靠性传输"><a class="header-anchor" href="#可靠性传输"></a>可靠性传输</h1>
<p><em>TCP可靠性传输的保证</em>：每个已发送的报文都需要进行确认ACK，对等待ACK超时的报文进行自动重传，使用滑动窗口实现连续重传与累积确认以提高信道利用率。</p>
<p>**停止等待：**发送一个报文，则需等待对端对这个报文的确认ACK</p>
<p>**自动重传请求ARQ(Automatic Repeat reQuest)：**若等待ACK超时了（每个报文分配一个超时计时器）则重发</p>
<p>**连续ARQ：**使用滑动窗口，对报文进行流水线式的连续发送，并且接收方进行累积确认，只需对按序到达的最后高序号分组发送确认。</p>
<p>**Go-Back-N（回退N）问题：**连续ARQ协议下，若中间报文丢失了，发送方无法知道后面报文段下落，只好把后面的报文也都重传一遍。</p>
<p>**以字节为单位的滑动窗口：**报文首部提供一个窗口大小的字段，用以告诉对端，自己接收窗口的剩余字节大小，让对端据此设置其发送窗口。滑动窗口可以控制发送方的发送速率，保证接收方能够来得及处理到来的数据包，本身有流量控制的作用。</p>
<h2 id="TCP如何处理无解的两军问题"><a class="header-anchor" href="#TCP如何处理无解的两军问题"></a>TCP如何处理无解的两军问题</h2>
<p>发送方没有收到已发送报文的确认报文时</p>
<p>接收方重复收到已经回应确认的数据时</p>
<h2 id="缓存与窗口"><a class="header-anchor" href="#缓存与窗口"></a>缓存与窗口</h2>
<p>在实现层面上，TCP协议栈中对发送方和接收方分别有一个缓存区，对应发送缓存和接收缓存。他们和发送窗口，接收窗口不是同一个东西，但却有紧密联系。</p>
<p>发送缓存是TCP协议栈中的缓存区，用来接收应用程序传送过来的，并且准备进行发送的数据，同时也包含了那些已发送的但未收到确认的数据。可以认为发送窗口实际上只是发送缓存的一部分。已发送并确认的数据会从缓存中删除。</p>
<p>接收缓存类似。它用来存放已经确认但尚未被应用程序读取的数据，也包含了到达未确认的数据（因累积确认而没来得及确认的或未按序到达的数据）。具体一点，它对应socket套接字缓冲区（SO_RCVBUF），而接受窗口对应这个缓冲区的可用空间。</p>
<h2 id="重传的时机"><a class="header-anchor" href="#重传的时机"></a>重传的时机</h2>
<blockquote>
<p>重传超时时间的大小 --》 加权平均往返时间SRTT与DRTT --》重传报文段对RTT的影响 --》Karn算法 --》 对Karn算法的改进</p>
</blockquote>
<p>TCP为每一个报文都设置了一个超时计时器，对超时未收到ACK的报文段进行自动重发。而这个超时重传时间（RTO）的值应该取多大呢？</p>
<p>TCP采用的是一种自适应的算法。</p>
<p>往返时间RTT：报文段发出时间与接收到相应确认时间的时间差。</p>
<p>加权平均往返时间SRTT：又称平滑往返时间，s=smoothed。</p>
<p>$$新SRTT = (1-α) * 旧SRTT + α * (新RTT样本)$$</p>
<p>其中0 ≤ α &lt; 1，TCP采用的值为1/8。内核中的计算公式为：</p>
<p>$$SRTT += 1/8 * (m - SRTT)$$</p>
<p>m为当前RTT。</p>
<p>超时重传时间RTO(RetransmissionTimeOut)应该略大于上述SRTT，TCP规定：</p>
<p>$$RTO = SRTT + 4*DRTT$$</p>
<p>RTTd为RTT的偏差的加权平均值，也就是RTTs与RTT差值的加权平均数，反应了实际RTT与SRTT波动幅度。同样地，依据加权平均数递推式，有：</p>
<p>$$新DRTT = (1-β) * 旧DRTT + β * |RTTs - 新RTT|$$</p>
<p>其中0 ≤ β &lt; 1，TCP采用的值为1/4。</p>
<p>因为无法推断出发送方所收到的确认是对最初报文段的确认还是对重传报文段的确认，所以Karn算法就忽略掉重传报文段的RTT：在计算SRTT的时候，不采用重传报文段的RTT样本。</p>
<p>但是Karn算法会导致RTO无法更新的情况。假如网络波动引起某个时间段内的时延大幅增加，报文段都会超时并重传，这时，Karn算法会忽略掉这些重传报文段的RTT，从而导致RTO无法被更新。</p>
<p>实际上TCP协议是这样处理的：当有报文段发送重传的时候，就将其RTO增加为2*RTO，当不再发生重传时，则按上面所诉的SRTT，RTO的式子计算。</p>
<h2 id="Go-Back-N问题"><a class="header-anchor" href="#Go-Back-N问题"></a>Go-Back-N问题</h2>
<p>Go-Back-N问题：由于接收方采用的是累积确认（又称延迟确认，延迟应答），所以无法向发送方反馈中间迟来或丢失报文之后的接收确认情况，使得发送方只能再次发送之后已经收到的数据。为了解决这个问题，TCP协议中提供了一个选择确认（SACK Selective ACK）的机制，它在首部选项字段中增加SACK信息，指明已收到报文段的边界信息。</p>
<p>需要注意的是，选项字段有长度限制，最多40个字节，而一个边界信息就会消耗4字节（一个序号占4字节）。因此，选项字段最多能承载4个边界信息（1字节表示SACK标志位，1字节表示SACK长度，4x4x2=32字节）。</p>
<p>选择确认SACK需要发送方拥有选择重传的能力。</p>
<h1 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h1>
<blockquote>
<p>滑动窗口机制保证控制发送速率，使得接收方处理 --》零窗口通知（接收窗口=0），持续计时器，零窗口探测报文 --》</p>
</blockquote>
<p>流量控制的目的，就是<strong>让发送方的发送速率不要太快，要让接收方来得及接收接收</strong>。利用滑动窗口机制可以很方便地在TCP连接上实现流量控制。</p>
<p>接收窗口rwnd（receiver window）</p>
<p>TCP首部中有一个窗口大小字段，是接收方用来告诉发送方，自己的接受窗口剩余的字节数大小，让发送方以此来设置发送窗口大小。发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p>
<p>当接收方回复的窗口值为零时，也就是零窗口通知，接收方就会启动一个<strong>持续计时器（Persistence Timer）</strong>，若计时器到期之前，若没有收到恢复窗口（rwnd&gt;0）的通知，则会发送一个零窗口探测报文段。</p>
<p><strong>持续计时器</strong>的目的是防止接收方恢复窗口的通知报文段丢失，引起的双方都在死等的问题。</p>
<h2 id="报文段发送的时机"><a class="header-anchor" href="#报文段发送的时机"></a>报文段发送的时机</h2>
<h3 id="Nagle算法"><a class="header-anchor" href="#Nagle算法"></a>Nagle算法</h3>
<h3 id="糊涂窗口综合征"><a class="header-anchor" href="#糊涂窗口综合征"></a>糊涂窗口综合征</h3>
<h1 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h1>
<p>拥塞控制是一个全局性的问题，而流量控制是一个端到端的通信量控制问题。拥塞控制目的是<strong>防止过多的数据注入到网络中，避免发生网络中路由器或者链路的负载持续增加，导致网络过载不可用的情况</strong>。</p>
<p>拥塞窗口（cwnd, Congestion Window）是一条连接中发送方维持的一个状态变量（u32），值大小</p>
<h2 id="拥塞窗口与发送窗口的联系"><a class="header-anchor" href="#拥塞窗口与发送窗口的联系"></a>拥塞窗口与发送窗口的联系</h2>
<p>我们知道TCP报文段首部中，窗口大小的字段值，是接收方告诉发送方自己能还能接收的数据字节数大小。也就是说，发送方发送窗口的大小不能大于接收方接收窗口的大小。另外，为了保证拥塞控制，发送窗口大小也会受到拥塞窗口的因素。snd_wnd=min(rwnd,cwnd*mss)</p>
<h2 id="慢启动与拥塞避免"><a class="header-anchor" href="#慢启动与拥塞避免"></a>慢启动与拥塞避免</h2>
<h2 id="快重传与快恢复"><a class="header-anchor" href="#快重传与快恢复"></a>快重传与快恢复</h2>
<h2 id="Tahoe-Reno与Cubic"><a class="header-anchor" href="#Tahoe-Reno与Cubic"></a>Tahoe, Reno与Cubic</h2>
<h2 id="BBR"><a class="header-anchor" href="#BBR"></a>BBR</h2>
<h1 id="连接管理"><a class="header-anchor" href="#连接管理"></a>连接管理</h1>
<h2 id="三次握手"><a class="header-anchor" href="#三次握手"></a>三次握手</h2>
<ul>
<li>sockets建立，序号同步，窗口协商</li>
<li>历史状态对新连接的影响</li>
</ul>
<h2 id="四次挥手"><a class="header-anchor" href="#四次挥手"></a>四次挥手</h2>
<ul>
<li>全双工？</li>
<li>资源（socket?）释放</li>
</ul>
<h2 id="连接的有限状态机"><a class="header-anchor" href="#连接的有限状态机"></a>连接的有限状态机</h2>
<h1 id="其它"><a class="header-anchor" href="#其它"></a>其它</h1>
<p>携带应答，选择重传机制，</p>
<h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1>
<ul>
<li>《计算机网络（第6版）-谢希仁》</li>
<li><a href="http://packetbomb.com/understanding-throughput-and-tcp-windows/">Understanding Throughput and TCP Windows – PacketBomb</a></li>
<li>如何测量和确定Linux系统中tcp初始发送窗口的大小？ - 腾讯技术工程的回答 - 知乎 <a href="https://www.zhihu.com/question/267728663/answer/331489185">https://www.zhihu.com/question/267728663/answer/331489185</a></li>
</ul>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora自定义Gitee图床上传脚本</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/Typora%E8%87%AA%E5%AE%9A%E4%B9%89Gitee%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC.html</url>
    <content><![CDATA[<h1 id="新建Gitee仓库"><a class="header-anchor" href="#新建Gitee仓库"></a>新建Gitee仓库</h1>
<ul>
<li>仓库必须是<code>开源（所有人可见）</code></li>
<li>选择初始化</li>
</ul>
<img src="https://tximgcdn.tung7.com/Typora自定义Gitee图床上传脚本/Typora自定义Gitee图床上传脚本_20210708212615_220560.png" alt="image-20210612100355952" style="zoom:30%;" />
<h1 id="获取Gitee-OpenAPI的access-token"><a class="header-anchor" href="#获取Gitee-OpenAPI的access-token"></a>获取Gitee OpenAPI的access_token</h1>
<p>在设置-安全设置-私人令牌-生成新令牌，令牌需要有<strong>projects权限</strong>，生成后保存好给到的access_token。</p>
<img src="https://tximgcdn.tung7.com/Typora自定义Gitee图床上传脚本/Typora自定义Gitee图床上传脚本_20210708212711_539618.png" style="zoom:30%;" />
<h1 id="Python3环境与脚本配置变量的修改"><a class="header-anchor" href="#Python3环境与脚本配置变量的修改"></a>Python3环境与脚本配置变量的修改</h1>
<p>提前装好依赖</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">pip3  install -U requests<br>pip3  install -U cos-python-sdk-v5<br>pip3  install opencv-python<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># git commit的信息</span><br>message=<span class="hljs-string">&quot;图床&quot;</span><br><span class="hljs-comment"># 刚刚获取到的私人令牌</span><br>access_token=<span class="hljs-string">&quot;XXXXXX&quot;</span><br><span class="hljs-comment"># gitee的用户名</span><br>owner=<span class="hljs-string">&quot;XXXXXX&quot;</span> <br><span class="hljs-comment"># 刚刚新建的仓库名</span><br>repo=<span class="hljs-string">&quot;pic-repo&quot;</span><br><span class="hljs-comment"># 提交文件目标目录</span><br><span class="hljs-built_in">dir</span>=<span class="hljs-string">&quot;img&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compress_img</span>(<span class="hljs-params">img</span>):<br>    src=cv2.imread(img, <span class="hljs-number">1</span>)<br>    d,fname=os.path.split(img)<br>    purename=os.path.splitext(fname)[<span class="hljs-number">0</span>]<br>    cv2.imwrite(d+<span class="hljs-string">&quot;/&quot;</span>+purename+<span class="hljs-string">&quot;.jpg&quot;</span>, src, [cv2.IMWRITE_JPEG_QUALITY, <span class="hljs-number">80</span>])<br>    <span class="hljs-keyword">return</span> d+<span class="hljs-string">&quot;/&quot;</span>+purename+<span class="hljs-string">&quot;.jpg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_size</span>(<span class="hljs-params">file</span>):<br>    <span class="hljs-comment"># 获取文件大小:KB</span><br>    size = os.path.getsize(file)<br>    <span class="hljs-keyword">return</span> size / <span class="hljs-number">1024</span><br><br>base_url=<span class="hljs-string">&quot;https://gitee.com/api/v5/repos/&quot;</span><br>filename=sys.argv[<span class="hljs-number">1</span>]<br>filepath=sys.argv[<span class="hljs-number">2</span>]<br>imgs=sys.argv[<span class="hljs-number">3</span>:]<br>tmp=<span class="hljs-string">&quot;&quot;&quot;&#123;&quot;access_token&quot;:&quot;%s&quot;,&quot;content&quot;:&quot;%s&quot;,&quot;message&quot;:&quot;%s&quot;&#125;&quot;&quot;&quot;</span><br><br>arr=[]<br>hasF=<span class="hljs-literal">False</span><br><span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> imgs:<br>    file_ext = os.path.splitext(img)[-<span class="hljs-number">1</span>]<br>    newName=<span class="hljs-string">&quot;%s/%s_%s_%s&quot;</span> % (filename, filename,time.strftime(<span class="hljs-string">&quot;%Y%m%d%H%M%S&quot;</span>, time.localtime()),random.randint(<span class="hljs-number">100000</span>, <span class="hljs-number">999999</span>))<br>    url=base_url+owner+<span class="hljs-string">&quot;/&quot;</span>+repo+<span class="hljs-string">&quot;/contents/&quot;</span>+<span class="hljs-built_in">dir</span>+<span class="hljs-string">&quot;/&quot;</span>+newName+file_ext<br>    <br>    <span class="hljs-keyword">if</span> (get_size(img)&gt;<span class="hljs-number">1000</span>):<br>        img = compress_img(img)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(img, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        encode_img = base64.b64encode(f.read())<br>        img_base64 = encode_img.decode()<br>        <span class="hljs-comment">#print(&#x27;data:image/&#123;&#125;;base64,&#123;&#125;&#x27;.format(file_ext[1:], img_base64))</span><br>        headers=&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>:<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>&#125;<br>        data=tmp%(access_token, img_base64, message)<br>        f.close()<br>        <span class="hljs-keyword">try</span>:<br>            res=requests.post(url=url, headers=headers, data=data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>            res.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br>            resBody=json.loads(res.text)<br>            arr.append(resBody[<span class="hljs-string">&#x27;content&#x27;</span>][<span class="hljs-string">&#x27;download_url&#x27;</span>])<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br>            hasF=<span class="hljs-literal">True</span><br><br><span class="hljs-keyword">if</span> (hasF):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Upload Failed:&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Upload Success:&quot;</span>)<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> arr:<br>        <span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<h1 id="Typora配置"><a class="header-anchor" href="#Typora配置"></a>Typora配置</h1>
<ul>
<li>取消勾选本地位置的图片规则
<ul>
<li>这样就不会自动上传图片，等到文章编辑好之后，再手动右键图片进行上传。</li>
<li>截图粘贴的图片默认会放到typora自己的一个资源文件夹，需要定时清理（Mac下为/Users/XXXX/Library/Application Support/typora-user-images）</li>
</ul>
</li>
<li>勾选网络位置的图片规则
<ul>
<li>会自动将网络位置的图片上传到图床</li>
</ul>
</li>
<li>上传服务填写Custom Command</li>
<li>命令填写python脚本，并附带``${filename}<code>与</code>${filepath}`参数
<ul>
<li><code>/usr/bin/python3 /Users/Tung/LocalDoc/hexoblog/cosupload.py &quot;$&#123;filename&#125;&quot; &quot;$&#123;filepath&#125;&quot;</code></li>
<li>环境中可能有多种python环境，手动指定install了依赖包的那个环境即可</li>
</ul>
</li>
</ul>
<img src="https://tximgcdn.tung7.com/Typora自定义Gitee图床上传脚本/Typora自定义Gitee图床上传脚本_20210708212603_404578.png" alt="image-20210612102101852" style="zoom:30%;" />
<p><img src="https://tximgcdn.tung7.com/Typora%E8%87%AA%E5%AE%9A%E4%B9%89Gitee%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC/Typora%E8%87%AA%E5%AE%9A%E4%B9%89Gitee%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC_20230402233103_292999.png" alt="image-20230402233103239"></p>
<h1 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h1>
<p><a href="https://support.typora.io/Upload-Image/#custom">Upload Images (typora.io)</a></p>
<p><a href="https://gitee.com/api/v5/swagger#/postV5ReposOwnerRepoContentsPath">Gitee API 文档</a></p>
]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础-路由选择协议</title>
    <url>/%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<p><img src="../../assets/svg/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.svg" alt="路由选择协议"></p>
<h1 id="为什么需要路由选择"><a class="header-anchor" href="#为什么需要路由选择"></a>为什么需要路由选择</h1>
<p>如今，Internet是世界上最大的互联网络。为了解决主机与主机之间的通信问题，网络层需要考虑如何在庞大的网络中，为数据报的转发进行寻址。路由选择协议在解决主机之间的寻址问题有着重要作用。</p>
<p><strong>路由选择</strong>就是寻找一条能够到达目的地点的路由器序列。不同的路由器序列对应的代价是不一样的，比如费用，延迟，跳数等等。</p>
<p><strong>路由选择协议</strong>用来定义路由器如何实现路由选择功能，以达到让数据报从源主机到目的主机之间的传输路径是<strong>比较好</strong>的路由路径。</p>
<blockquote>
<p>因为在Internet规模如此巨大的情况下，寻找最佳路径的成本和时延是很高的，所以这里是选择一条比较好的，<strong>代价较为低</strong>的路径，而不是最佳的路径。</p>
</blockquote>
<p>我们知道，网络层的路由实际上是<strong>子网到子网的路由</strong>，那么，路由器与路由器之间的路由问题就等价于主机到主机之间的路由问题。这样一来，将网络看作是*<u>有权联通图</u>*的抽象。节点为使用路由器代表的子网，边为链路，边值为度量（路由代价，如跳数，时延，费用等等）。<strong>路由选择算法本质上就是图的路径算法。</strong></p>
<p>路由选择的策略有：</p>
<ul>
<li>静态路由选择策略
<ul>
<li>非自适应，不能及时适应网络状态的变化，适合小型网络</li>
</ul>
</li>
<li>动态路由选择策略（自适应）
<ul>
<li>自适应的，能够较好地适应网络状态的变化，实现较为复杂，开销也较大，所以适合复杂的大型网络。</li>
</ul>
</li>
</ul>
<h1 id="Internet主要的路由选择协议"><a class="header-anchor" href="#Internet主要的路由选择协议"></a>Internet主要的路由选择协议</h1>
<p>现行Internet的路由选择协议主要是<strong>动态的</strong>，分布式路由选择协议。</p>
<p>Internet将整个互联网划分为多个较小的<strong>自治系统（autonomous system）</strong>,每个自治系统内部可以使用多种内部路由选择协议和度量（成本代价的度量），但是一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p>
<p>一个大的ISP就是一个自治系统。</p>
<p>按照自治系统的角度，可以将路由选择协议划分为两大类</p>
<ul>
<li>内部网关协议IGP
<ul>
<li>称之为域内路由选择协议</li>
<li>也就是在一个AS内使用的路由选择协议，与其他AS选用的路由选择协议无关。</li>
<li>目前使用得最多的就是RIP协议，OSPF协议</li>
</ul>
</li>
<li>外部网关协议EGP
<ul>
<li>称之为域间路由选择协议</li>
<li>当数据报需要跨自治系统传输，到达一个AS边界的时候，就需要使用一种协议将路由选择信息（？具体什么信息？）传递到另一个AS中。</li>
<li>目前使用得最多的就是BGP</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>协议</th>
<th>下层协议</th>
<th>算法</th>
<th>范围</th>
<th>环路检测</th>
</tr>
</thead>
<tbody>
<tr>
<td>RIP、RIP2</td>
<td>UDP</td>
<td>距离向量</td>
<td>域内</td>
<td>不支持：使用跳数约束方法</td>
</tr>
<tr>
<td>OSPF</td>
<td>IP</td>
<td>链路状态</td>
<td>域内</td>
<td>支持</td>
</tr>
<tr>
<td>BGP</td>
<td>TCP</td>
<td>路径向量</td>
<td>域间</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h1 id="RIP-Routing-Information-Protocol"><a class="header-anchor" href="#RIP-Routing-Information-Protocol"></a>RIP(Routing Information Protocol)</h1>
<p>一种分布式的，基于<strong>距离矢量算法</strong>的路由选择协议。最大特点就是简单。</p>
<p>RIP认为，好的路由就是通过的路由器的数量少，所以RIP中的“距离”就是“跳数”，每经过一个路由，跳数就增加1。</p>
<h2 id="距离矢量算法Distance-Vector"><a class="header-anchor" href="#距离矢量算法Distance-Vector"></a>距离矢量算法Distance Vector</h2>
<p>DV是一种<strong>局部算法</strong>，路由器只知道与它有物理连接关系的邻居路由，和到他们之间的代价。叠代地与邻居交换路由信息，计算路由信息。这个交换的路由信息就是：“到所有网络的距离和下一跳路由器”。</p>
<p>实现是使用<strong>Bellman-Ford算法</strong>，具体算法实现过程见[#《计算机网络第六版-谢希仁》P153以及P154的例4-5]。</p>
<h2 id="特点"><a class="header-anchor" href="#特点"></a>特点</h2>
<p>RIP允许一条路径<strong>最多包含15个路由</strong>，距离超过15时，就认为不可达，由此可见，RIP只适用于小型网络。</p>
<p>主要特点：</p>
<ul>
<li>
<p>仅仅和相邻路由器交换信息</p>
<ul>
<li>交换的信息就是本路由器当前的路由表</li>
<li>路由表信息：目标网络，到这个网络的最短距离，以及对应的下一跳地址。</li>
</ul>
</li>
<li>
<p>当前路由器到AS中所有网络的最短距离，以及经过每个网络应该经过的下一跳路由器</p>
</li>
<li>
<p>按固定的时间间隔交换路由信息。当网络拓扑变化时，也及时向邻居通告变化信息。</p>
</li>
<li>
<p>**好消息传播得快，坏消息传播的慢。**网络出现故障的传播时间往往需要较长时间（数分钟），这是一个缺点。</p>
</li>
<li>
<p>RIP协议由于发送频率高，所以使用的UDP协议进行信息传送。（可以将RIP协议实现当做是应用程序理解）</p>
</li>
</ul>
<h1 id="OSPF-Open-Shortest-Path-First"><a class="header-anchor" href="#OSPF-Open-Shortest-Path-First"></a>OSPF (Open Shortest Path First)</h1>
<p><strong>开放最短路径优先算法</strong>（之所以叫SPF，是因为使用了Dijkstra提出的SPF算法。），是分布式的，基于<strong>链路状态算法</strong>的路由选择协议。</p>
<h2 id="链路状态算法Link-State"><a class="header-anchor" href="#链路状态算法Link-State"></a>链路状态算法Link State</h2>
<p>LS是一种全局算法，分为两大步骤：所有路由器都要得到全局网络拓扑图和度量信息，对拓扑图进行运算得到路由表。</p>
<p>为了使得所有路由器都拥有完整的拓扑和边的度量信息（代价），当某个路由器的网络状态变化时，可以使用泛洪法，将自身与邻居之间的变化信息广播出去，其它路由器得到信息后继续向外扩散广播。最终所有路由器都能够得知变化信息。</p>
<p>当路由器拥有了全局拓扑结构后，就可以依据Dijkstra SPF算法构造出自己的路由表。</p>
<h2 id="特点："><a class="header-anchor" href="#特点："></a>特点：</h2>
<ul>
<li>使用泛洪（flooding）法向本AS中所有的路由器发送信息。
<ul>
<li>也就是通过所有输出端口向所有邻居发送信息，邻居收到信息之后再次向其所有邻居（排除来源路由器）发送接收到的信息，这样AS中所有路由器都能得到这个信息。</li>
</ul>
</li>
<li>发送的信息就是本路由器<strong>相邻的所有路由器的链路状态</strong>
<ul>
<li>链路状态就是本路由器和哪些路由器相邻，以及链路的度量（metric 表示距离，时延，带宽，费用等等）。这个度量可以理解为代价。</li>
</ul>
</li>
<li>只有链路状态发生变化的时候，才会泛洪信息。与RIP的定时交换信息不同。</li>
<li>每个路由器都有一个链路状态数据库，存放的实际上就是全网（AS）的拓扑结构图，每一个路由器通过全网拓扑图构造出自己的路由表（使用Dijkstra算法计算）</li>
</ul>
<p>为了避免泛洪导致的广播风暴问题，可以将AS再次划分为若干个更小的区域，泛洪就只是在当前区域内泛洪。</p>
<p>OSPF协议报文很短，所以只需要直接使用IP协议进行通信即可，不需要使用UDP。</p>
<h1 id="BGP"><a class="header-anchor" href="#BGP"></a>BGP</h1>
<p>BGP是一个<strong>基于路径向量（path vector）路由选择算法</strong>的，边界网关协议。考虑到实现的复杂度与成本，BGP协议目的不是寻找最佳的路由，而是寻找一条能够达到目的网络的比较好的路由。</p>
<p>原因有两个：</p>
<ul>
<li>Internet规模太大，使得AS之间路由选择非常困难。主干网上的路由表早已经超过5万个网络前缀。如果使用链路状态算法，每一个路由器都需要维持一个很大的链路状态数据库LSDB。同时如此大的LSDB，计算最短路径所花费的时间也太长了。</li>
<li>AS之间的路由选择需要考虑有关策略。不同AS内部的代价可能是不同的，那么在AS之间使用最短路径也是不能适配的。另一方面，不同AS所在的国家地区，可能由于政治，安全等原因不允许某些AS的数据经过。这时，只能是网络管理人员对灭一个路由期进行设置。</li>
</ul>
<p>BGP比较合理的做法是在AS之间交换可达性信息，而不是代价。这样一来BGP就采用了一种与RIP,OSPF都不同的算法：路径向量（Path Vector）算法。</p>
<p>每一个BGP都会由管理员配置一个或者多个路由器作为<strong>BGP发言人（BGP speaker）</strong>，由他们进行路由信息交换。发言人之间需要事先建立TCP连接（端口179），确保通信的质量。当新增路由，撤销路由或者网络异常时，发言人就使用建立的TCP会话交换信息。</p>
<p>发言人借助交换的信息，得到最终的路径信息访问列表（AS Path List），例如要到达网络N1,N2,N3可经过路径(AS1,AS2)。具体例子：参考[《图解TCP/IP 第5版》7.6.2]</p>
]]></content>
      <categories>
        <category>日拱一卒</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD峰会2020摘录</title>
    <url>/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="张逸-民航信息技术总监-《接构领域驱动设计》作者"><a class="header-anchor" href="#张逸-民航信息技术总监-《接构领域驱动设计》作者"></a>张逸 民航信息技术总监 《接构领域驱动设计》作者</h1>
<h2 id="领域驱动设计大揭秘"><a class="header-anchor" href="#领域驱动设计大揭秘"></a>领域驱动设计大揭秘</h2>
<blockquote>
<ol>
<li>DDD vs DDD （数据驱动 vs 领域驱动）</li>
<li>DDD黑铁时代与黄金时代</li>
<li>单体架构是邪恶的吗</li>
<li>DDD的不足与DDD-UP</li>
</ol>
</blockquote>
<h2 id="传统与DDD"><a class="header-anchor" href="#传统与DDD"></a>传统与DDD</h2>
<h3 id="传统设计模型的分析"><a class="header-anchor" href="#传统设计模型的分析"></a>传统设计模型的分析</h3>
<p>ER图，专注数据字段，到类设计层面就是数据表映射到数据类，这种类看作是一个携带数据的一种结构（数据实体）。也就是贫血模型（数据结构与算法分开，只有数据结构的模型）。</p>
<p>字段的重用。从超类的实现，到组合的实现。</p>
<p>贫血模型将算法聚集在一个没有状态的service里面，这个service称之为事务脚本，</p>
<p>上述的贫血模型+事务脚本的结合方式就是一种传统的面向过程的方式。</p>
<p>存在模块，服务，组件的概念</p>
<h3 id="DDD下模型的重用"><a class="header-anchor" href="#DDD下模型的重用"></a>DDD下模型的重用</h3>
<p>属性字段的重用，传统模型会通过超类实现，DDD从组合的角度实现。</p>
<p><strong>限界上下文 - Bounded Context，是业务能力的纵向切分，顺应业务的变化方向</strong></p>
<p>例：对于客户Customer模型而言，它在销售上下文与售后上下文中的关注点是不一样的</p>
<p>BC之间的重用，是借助业务能力进行重用的，而不是直接重用领域模型。</p>
<p>财务上下文中，关注往来账的业务能力。其中有运输费的业务，但是财务BC不具备计算运费的能力，运费领域模型包含了运输费，租赁费，人工费，保费等信息。这些是要在运输上下文中提供。对于财务BC，会提供一个结算账目的业务能力，它在结算的时候，需要得到一个运费，这就需要运输BC的业务能力。可以看到这里是通过业务能力（可能就是我们看到的一种RESTful服务）来保证重用的，而不是直接使用对方的领域模型，从而保证依赖降低（解耦）。</p>
<p>领域模型的知识语境。识别上下文，确定领域模型的知识语境</p>
<p>运输BC，需要商品的信息，但是只需要商品运输高度，运输深度，有没有回收，有没有收税这些属性。</p>
<p>商品BC中会定义一个商品类Product，运输BC中也会定义一个商品类Product，</p>
<p>先是业务层面，领域层面的纵向切分，再是技术角度来划分业务模块，数据访问模块。从编码的角度上看，如果业务发生变化，只影响到了其中一个类。</p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062842_488234.png" alt="image-20210613100555039"></p>
<p><strong>聚合与聚合根</strong></p>
<p>对象的依赖，生命周期的管理。经常大量需要细粒度的类，这样会导致类关系图异常复杂。从对象的相关性进行划分边界进行聚合，然后为每一个聚合定义一个聚合根实体，聚合之间只允许聚合根之间进行关联，以此减少类与类的关系。</p>
<p>聚合根对外提供交互关系，内部的细节是它自己的实现，外部不需要关心。</p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062849_148415.png" alt="image-20210613101813903"></p>
<p><strong>限界上下文</strong>与<strong>聚合</strong>是DDD的核心模式。</p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062856_284094.png" alt="image-20210613102006057"></p>
<h2 id="黑铁时代与黄金时代"><a class="header-anchor" href="#黑铁时代与黄金时代"></a>黑铁时代与黄金时代</h2>
<p>DDD是03年开始当时是一个很新的概念，对开发人员和设计人员来说，第一会导致知识上的增加。他们面临大量新概念新知识涌入的压力，其实是很难接受的。第二，他没有意识到限界上下的价值，BC是架构层次的自治单元。</p>
<p>南北向菱形模型：南向：领域-端口-适配器，北向：远程-本地-领域。 调用一般是南北走向？</p>
<p>随着微服务的诞生，DDD开始火起来。</p>
<p>微服务的协作就是限界上下文的协作。通过**Client防腐层？**调用上游微服务成为合理的选择。</p>
<h2 id="单体架构与领域驱动架构风格"><a class="header-anchor" href="#单体架构与领域驱动架构风格"></a>单体架构与领域驱动架构风格</h2>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062907_866505.png" alt="DDD峰会2020摘录_20210614050949_233675"></p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062913_997895.png" alt="image-20210613111652495"></p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062919_147282.png" alt="事件驱动架构"></p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062926_378798.png" alt="DDD峰会2020摘录_20210614051005_654846"></p>
<h2 id="DDD的不足与补充"><a class="header-anchor" href="#DDD的不足与补充"></a>DDD的不足与补充</h2>
<ul>
<li>缺乏规范的<strong>过程指导</strong>，缺乏<strong>可操作性</strong>，团队实践过程中，更多取决于设计者的行业知识与设计经验，这就存在较大的偶然性。</li>
<li>没有匹配的需求管理体系。不同层次的业务需求贯穿于领域驱动设计过程中的每个环节，识别限界上下文和建立高质量的领域模型<strong>都有赖于</strong>良好的需求。需求管理体系直接影响领域驱动设计的质量。</li>
<li>DDD的核心诉求是让<strong>业务架构</strong>和<strong>应用架构</strong>形成<strong>绑定关系</strong>，以面对需求变化时，使得<strong>应用架构能够适应业务架构的调整</strong>，满足架构的<strong>演进性</strong>。但是DDD却<strong>缺乏面向领域的架构体系</strong>，不足以支撑复杂软件项目的架构需求。
<ul>
<li>目前能和BC对应上的只有分层架构。后来还有六边形架构，还有上面所说的菱形架构</li>
</ul>
</li>
<li>DDD虽然以模型驱动设计为主线，却<strong>没有给出明确的领域建模方法</strong>。我们需要分别为领域<strong>分析建模</strong>，领域<strong>设计建模</strong>和领域<strong>实现建模</strong>提供对应的方法指导，减轻各个建模活动的知识负担，明确每个建模活动活动的领域模型的验证标准，避免领域建模的随意性。
<ul>
<li>分析模型，设计模型，实现模型应该保持一致。但是，没有提供方法告诉我们：怎么去提炼对象，怎么建立模型对象，模型从分析到设计到实现是怎么转换。</li>
</ul>
</li>
</ul>
<p>RUP? 问题空间-解空间</p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062938_941172.png" alt="DDD峰会2020摘录_20210614051041_704101"></p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062947_638824.png" alt="image-20210613123247487"></p>
<h1 id="欧创新-《中台架构与实现：基于DDD和微服务》作者"><a class="header-anchor" href="#欧创新-《中台架构与实现：基于DDD和微服务》作者"></a>欧创新 《中台架构与实现：基于DDD和微服务》作者</h1>
<h2 id="当中台遇上DDD，如何设计微服务"><a class="header-anchor" href="#当中台遇上DDD，如何设计微服务"></a>当中台遇上DDD，如何设计微服务</h2>
<p>顶层设计开始，行业领域不同关注也不同，阿里的通用能力中台关注公共业务领域，主要解决重复造轮子的问题。</p>
<p>战略与战术</p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062953_744390.png" alt="DDD峰会2020摘录_20210614051123_449536"></p>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706062959_205757.png" alt="DDD峰会2020摘录_20210614051117_995382"></p>
<p>DDD下的微服务边界</p>
<ul>
<li>微服务单体内，基于聚合划分的逻辑边界，提供了微服务进一步划分的能力，这就解决了微服务内高内聚下面对变更时修改的难题。</li>
<li>限界上下文边界，在微服务落地的时候，就变成了微服务之间的物理边界。</li>
</ul>
<p><img src="https://tximgcdn.tung7.com/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95/DDD%E5%B3%B0%E4%BC%9A2020%E6%91%98%E5%BD%95_20210706063006_179024.png" alt="image-20210613150558524"></p>
<h1 id="于静-IBM资深应用架构师"><a class="header-anchor" href="#于静-IBM资深应用架构师"></a>于静 IBM资深应用架构师</h1>
<h2 id="领域驱动设计在大型遗留系统改造中的实践"><a class="header-anchor" href="#领域驱动设计在大型遗留系统改造中的实践"></a>领域驱动设计在大型遗留系统改造中的实践</h2>
<p>制定目标与策略-业务梳理-微服务改造-集成测试迁移-反馈。这五个步骤循环往复。</p>
<ul>
<li>业务梳理
<ul>
<li>用领域驱动的方式进行业务建模</li>
<li>抽象出一个业务模型，根据这个模型的关系划分限界上下文。 <strong>关键</strong></li>
<li>有效深刻地理解现有的系统，梳理现有的业务。</li>
<li>系统改造最难的一点就是分析业务和代码：很难理解现有系统的一些业务逻辑，很难理解现有系统为什么这么设计，以及整个系统包含了哪些业务。</li>
</ul>
</li>
<li>微服务改造
<ul>
<li>依据梳理出来的限界上下文，同时也需要先梳理现有系统架构，集成的方式，暴露的API，然后往微服务转换。</li>
</ul>
</li>
<li>测试，生产迁移
<ul>
<li>环境，域名，数据</li>
</ul>
</li>
<li>反馈
<ul>
<li>基于前几步骤，反馈给团队，以便更好地指导下一阶段的改造。</li>
<li>包含业务方反馈？</li>
</ul>
</li>
</ul>
<h2 id="DDD引领微服务系统设计"><a class="header-anchor" href="#DDD引领微服务系统设计"></a>DDD引领微服务系统设计</h2>
<p>如何识别系统边界？识别系统边界的一个实践就是事件风暴工作坊。</p>
<p>要求<strong>业务需求的提出者</strong>与<strong>技术实施者</strong>协作完成整个的领域设计建模（业务人员，开发，QA，PM等等，新实践需要教练主持人，通知准备，引导思路）</p>
<ul>
<li>熟悉项目的成员介绍一下项目情况
<ul>
<li>专注背后的业务讨论</li>
<li>避免开发人员陷入系统设计中，要脱离数据库表设计的固化思维，跳出现有的代码设计。（主持人需要关注并提醒）</li>
</ul>
</li>
<li>做好准备工作</li>
<li>专注业务讨论</li>
<li>可以邀请第三方接口团队人员参与
<ul>
<li>涉及三方接口时，可以邀请二方/三方团队参加</li>
</ul>
</li>
<li>成果记录
<ul>
<li>推荐Mural</li>
</ul>
</li>
</ul>
<p>业务分析过程中，会出现一个疑问：遗留系统的业务逻辑一定都是正确、适用（新变更，新场景）的吗？</p>
<ul>
<li>前后矛盾的逻辑</li>
<li>年久失修的逻辑</li>
<li>无人问津的逻辑</li>
</ul>
<p>我们在设计领域模型的时候，需要考虑，或者顺带着纠正这些问题。</p>
<p>但是这些问题的解决取决于团队对系统的所有权（ownership）的强度（话事权高对改动是十分友好的。）</p>
<h2 id="微服务实战"><a class="header-anchor" href="#微服务实战"></a>微服务实战</h2>
<blockquote>
<p>绞杀者模式：</p>
<p>通过逐步用新应用程序和服务，替换特定功能段，增量迁移旧系统。随着旧系统功能的更换，新系统最终取代了所有旧系统功能，扼杀并停用旧系统。</p>
</blockquote>
<p>第一个功能段，先锋队，挑选一个规模较小，功能简单，业务较为独立的功能模块。</p>
<ul>
<li>明确分层模型中各层的职责</li>
<li>脚手架工程（模板工程）</li>
<li>公共组件</li>
<li>防腐层</li>
<li>测试用例</li>
<li>DevOps</li>
<li>云基础设施</li>
</ul>
<p>士气：功能简单，时间周期战线不能拉太长。</p>
<p>规范：先锋队起试验作用，制定规范。</p>
<h1 id="杨云-ThoughtWorks总监咨询师"><a class="header-anchor" href="#杨云-ThoughtWorks总监咨询师"></a>杨云 ThoughtWorks总监咨询师</h1>
<h2 id="DDD从战略实际到代码落地的三阶段方法"><a class="header-anchor" href="#DDD从战略实际到代码落地的三阶段方法"></a>DDD从战略实际到代码落地的三阶段方法</h2>
<ol>
<li>为什么大家觉得落地难</li>
<li>DDD落地的三阶段方法</li>
<li>事件风暴来做战略建模</li>
<li>用名词动词法做子域内的结构化战术建模</li>
<li>用类型流做行为内部的微观详细设计</li>
</ol>
<p>模型：软件的核心骨架，核心约束，核心概念的一个可视化体现。</p>
<p>百人团队的DDD模型落地，具体到直观的微观模型，保证模型和代码的一致性。</p>
<h1 id="歪：个人重构感悟"><a class="header-anchor" href="#歪：个人重构感悟"></a>歪：个人重构感悟</h1>
<p>术语对齐。事件风暴，业务梳理，设计与落地的走样的问题</p>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka部署</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/Kafka%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h1 id="网站"><a class="header-anchor" href="#网站"></a>网站</h1>
<p>官方下载页：<a href="http://kafka.apache.org/downloads.html">Apache Kafka</a></p>
<h1 id="配置"><a class="header-anchor" href="#配置"></a>配置</h1>
<p>主要的配置<strong>server.properties</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#broker的全局唯一编号，不能重复</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-number">0</span><br><br><span class="hljs-comment">#用来监听链接的端口，producer或consumer将在此端口建立连接</span><br><span class="hljs-attr">port</span>=<span class="hljs-number">9092</span><br><br><span class="hljs-comment">#处理网络请求的线程数量</span><br><span class="hljs-attr">num.network.threads</span>=<span class="hljs-number">3</span><br><br><span class="hljs-comment">#用来处理磁盘IO的线程数量</span><br><span class="hljs-attr">num.io.threads</span>=<span class="hljs-number">8</span><br><br><span class="hljs-comment">#发送套接字的缓冲区大小</span><br><span class="hljs-attr">socket.send.buffer.bytes</span>=<span class="hljs-number">102400</span><br><br><span class="hljs-comment">#接受套接字的缓冲区大小</span><br><span class="hljs-attr">socket.receive.buffer.bytes</span>=<span class="hljs-number">102400</span><br><br><span class="hljs-comment">#请求套接字的缓冲区大小</span><br><span class="hljs-attr">socket.request.max.bytes</span>=<span class="hljs-number">104857600</span><br><br><span class="hljs-comment">#kafka消息存放的路径</span><br><span class="hljs-attr">log.dirs</span>=/home/servers-kafka/logs/kafka<br><br><span class="hljs-comment">#topic在当前broker上的分片个数</span><br><span class="hljs-attr">num.partitions</span>=<span class="hljs-number">2</span><br><br><span class="hljs-comment">#用来恢复和清理data下数据的线程数量</span><br><span class="hljs-attr">num.recovery.threads.per.data.dir</span>=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#segment文件保留的最长时间，超时将被删除</span><br><span class="hljs-attr">log.retention.hours</span>=<span class="hljs-number">168</span><br><br><span class="hljs-comment">#滚动生成新的segment文件的最大时间</span><br><span class="hljs-attr">log.roll.hours</span>=<span class="hljs-number">168</span><br><br><span class="hljs-comment">#日志文件中每个segment的大小，默认为1G</span><br><span class="hljs-attr">log.segment.bytes</span>=<span class="hljs-number">1073741824</span><br><br><span class="hljs-comment">#周期性检查文件大小的时间</span><br><span class="hljs-attr">log.retention.check.interval.ms</span>=<span class="hljs-number">300000</span><br><br><span class="hljs-comment">#日志清理是否打开</span><br><span class="hljs-attr">log.cleaner.enable</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">#broker需要使用zookeeper保存meta数据</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3000</span>,<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3001</span>,<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3002</span><br><br><span class="hljs-comment">#zookeeper链接超时时间</span><br><span class="hljs-attr">zookeeper.connection.timeout.ms</span>=<span class="hljs-number">6000</span><br><br><span class="hljs-comment">#partion buffer中，消息的条数达到阈值，将触发flush到磁盘</span><br><span class="hljs-attr">log.flush.interval.messages</span>=<span class="hljs-number">10000</span><br><br> <br><br><span class="hljs-comment">#消息buffer的时间，达到阈值，将触发flush到磁盘</span><br><span class="hljs-attr">log.flush.interval.ms</span>=<span class="hljs-number">3000</span><br><br><span class="hljs-comment">#删除topic需要server.properties中设置delete.topic.enable=true否则只是标记删除</span><br><span class="hljs-attr">delete.topic.enable</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">#此处的host.name为本机IP(重要),如果不改,则客户端会抛出:Producerconnection to localhost:9092 unsuccessful 错误!</span><br><span class="hljs-attr">host.name</span>=hadoop02<br></code></pre></td></tr></table></figure>
<p><strong>修改producer.properties</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Swarm</title>
    <url>/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/introduction_swarm.html</url>
    <content><![CDATA[<p>原文：<a href="http://blog.daocloud.io/swarm_analysis_part1/">http://blog.daocloud.io/swarm_analysis_part1/</a></p>
<hr>
<h1 id="1-Swarm简介"><a class="header-anchor" href="#1-Swarm简介"></a>1.Swarm简介</h1>
<p>Docker自诞生以来，其容器特性以及镜像特性给DevOps爱好者带来了诸多方便。然而在很长的一段时间内，Docker只能在单host上运行，其跨host的部署、运行与管理能力颇受外界诟病。跨host能力的薄弱，直接导致Docker容器与host的紧耦合，这种情况下，Docker容器的灵活性很难令人满意，容器的迁移、分组等都成为很难实现的功能点。</p>
<p>Swarm是Docker公司在2014年12月初新发布的容器管理工具。和Swarm一起发布的Docker管理工具还有Machine以及Compose。</p>
<p>Swarm是一套较为简单的工具，用以管理Docker集群，使得Docker集群暴露给用户时相当于一个虚拟的整体。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client(dockerclient in go, docker_py, docker等)均可以直接与Swarm通信。Swarm几乎全部用Go语言来完成开发，并且还处于一个Alpha版本，目前在github上发布的版本仅有v0.1.0-rc1。然而Swarm的发展十分快速，功能和特性的变更迭代还非常频繁。因此，可以说Swarm还不推荐被用于生产环境中，但可以肯定的是Swarm是一项很有前途的技术。<br>
Swarm的设计和其他Docker项目一样，遵循“batteries included but removable”原则。笔者对该原则的理解是：batteries included代表设计Swarm时，为了完全体现分布式容器集群部署、运行与管理功能的完整性，Swarm和Docker协同工作，Swarm内部包含了一个较为简易的调度模块，以达到对Docker集群调度管理的效果；“but removable”意味着Swarm与Docker并非紧耦合，同时Swarm中的调度模块同样可以定制化，用户可以按照自己的需求，将其替换为更为强大的调度模块，如Mesos等。另外，这套管理引擎并未侵入Docker的使用，这套机制也为其他容器技术的集群部署、运行与管理方式提供了思路。</p>
<p>本文将从以下两点分析Swarm：</p>
<ul>
<li>Swarm架构</li>
<li>Swarm命令</li>
</ul>
<h1 id="2-Swarm架构"><a class="header-anchor" href="#2-Swarm架构"></a>2.Swarm架构</h1>
<p>Swarm作为一个管理Docker集群的工具，首先需要将其部署起来，可以单独将Swarm部署于一个节点。另外，自然需要一个Docker集群，集群上每一个节点均安装有Docker。具体的Swarm架构图可以参照下图：</p>
<p><img src="http://blog.daocloud.io/wp-content/uploads/2015/01/swarmarchitecture.jpg" alt="17"></p>
<p></p>
<p>图2.1 Swarm架构图</p>
<p>Swarm架构中最主要的处理部分自然是Swarm节点，Swarm管理的对象自然是Docker Cluster，Docker Cluster由多个Docker Node组成，而负责给Swarm发送请求的是Docker Client。</p>
<h1 id="3-Swarm命令"><a class="header-anchor" href="#3-Swarm命令"></a>3.Swarm命令</h1>
<p>Swarm架构图可以让大家对Swarm有一个初步的认识，比如Swarm的具体工作流程：Docker Client发送请求给Swarm；Swarm处理请求并发送至相应的Docker Node；Docker Node执行相应的操作并返回响应。除此之外，Swarm的工作原理依然还不够明了。</p>
<p>深入理解Swarm的工作原理，可以先从Swarm提供的命令入手。Swarm支持的命令主要有4个：swarm create、swarm manage、swarm join、swarm list。当然还有一个swarm help命令，该命令用于指导大家如何正确使用swarm命令，本文不再赘述。</p>
<h2 id="3-1-swarm-create"><a class="header-anchor" href="#3-1-swarm-create"></a>3.1 swarm create</h2>
<p>Swarm中swarm create命令用于创建一个集群标志，用于Swarm管理Docker集群时，Docker Node的节点发现功能。</p>
<p>发起该命令之后，Swarm会前往Docker Hub上内建的发现服务中获取一个全球唯一的token，用以唯一的标识Swarm管理的Docker集群。</p>
<p>注：Swarm的运行需要使用服务发现，目前该服务内建与Docker Hub，该服务发现机制目前还在alpha版本，站点为：<a href="http://discovery-stage.hub/docker.com">http://discovery-stage.hub/docker.com</a> 。</p>
<h2 id="3-2-swarm-manage"><a class="header-anchor" href="#3-2-swarm-manage"></a>3.2 swarm manage</h2>
<p>Swarm中swarm manage是最为重要的管理命令。一旦swarm manage命令在Swarm节点上被触发，则说明用户需要swarm开始管理Docker集群。从运行流程的角度来讲，swarm经历的阶段主要有两点：启动swarm、接收并处理Docker集群管理请求。</p>
<p>Swarm启动的过程包含三个步骤：</p>
<ol>
<li>发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化；</li>
<li>初始化内部调度（scheduler）模块；</li>
<li>创建并启动API监听服务模块；</li>
</ol>
<p>第一个步骤，Swarm发现Docker集群中的节点。发现（discovery）是Swarm中用于维护Docker集群状态的机制。既然涉及到发现（discovery），那在这之前必须先有注册（register）。Swarm中有专门负责发现（discovery）的模块，而关于注册（register）部分，不同的discovery模式下，注册（register）也会有不同的形式。</p>
<p>目前，Swarm中提供了5种不同的发现（discovery）机制：Node Discovery、File Discovery、Consul Discovery、EtcD Discovery和Zookeeper Discovery。</p>
<p>第二个步骤，Swarm内部的调度（scheduler）模块被初始化。swarm通过发现机制发现所有注册的Docker Node，并收集到所有Docker Node的状态以及具体信息。此后，一旦Swarm接收到具体的Docker管理请求，Swarm需要对请求进行处理，并通过所有Docker Node的状态以及具体信息，来筛选（filter）决策到底哪些Docker Node满足要求，并通过一定的策略（strategy）将请求转发至具体的一个Docker Node。</p>
<p>第三个步骤，Swarm创建并初始化API监听服务模块。从功能的角度来讲，可以将该模块抽象为Swarm Server。需要说明的是：虽然Swarm Server完全兼容Docker的API，但是有不少Docker的命令目前是不支持的，毕竟管理Docker集群与管理单独的Docker会有一些区别。当Swarm Server被初始化并完成监听之后，用户即可以通过Docker Client向Swarm发送Docker集群的管理请求。</p>
<p>Swarm的swarm manage接收并处理Docker集群的管理请求，即是Swarm内部多个模块协同合作的结果。请求入口为Swarm Server，处理引擎为Scheduler，节点信息依靠Disocovery。</p>
<h2 id="3-3-swarm-join"><a class="header-anchor" href="#3-3-swarm-join"></a>3.3 swarm join</h2>
<p>Swarm的swarm join命令用于将Docker Node添加至Swarm管理的Docker集群中。从这点也可以看出swarm join命令的执行位于Docker Node，因此在Docker Node上运行该命令，首先需要在Docker Node上安装Swarm，由于该Swarm只会执行swarm join命令，故可以将其当成Docker Node上用于注册的agent模块。</p>
<p>功能而言，swarm join可以认为是完成Docker Node在Swarm节点处的注册（register）工作，以便Swarm在执行swarm manage时可以发现该Docker Node。然而，上文提及的5种discovery模式中，并非每种模式都支持swarm join命令。不支持的discovery的模式有Node Discovery与File Discovery。</p>
<p>Docker Node上swarm join执行之后，标志着Docker Node向Swarm注册，请求加入Swarm管理的Docker集群中。Swarm通过注册信息，发现Docker Node，并获取Docker Node的状态以及具体信息，以便处理Docker请求时作为调度依据。</p>
<h2 id="3-4-swarm-list"><a class="header-anchor" href="#3-4-swarm-list"></a>3.4 swarm list</h2>
<p>Swarm中的swarm list命令用以列举Docker集群中的Docker Node。</p>
<p>Docker Node的信息均来源于Swarm节点上注册的Docker Node。而一个Docker Node在Swarm节点上注册，仅仅是注册了Docker Node的IP地址以及Docker监听的端口号。</p>
<p>使用swarm list命令时，需要指定discovery的类型，类型包括：token、etcd、file、zk以及<ip>。而swarm list并未罗列Docker集群的动态信息，比如Docker Node真实的运行状态，或者Docker Node在Docker集群中扮演的角色信息。</p>
<h1 id="4-总结"><a class="header-anchor" href="#4-总结"></a>4.总结</h1>
<p>Swarm的架构以及命令并没有很复杂，同时也为希望管理Docker集群的Docker爱好者降低了学习和使用门槛。</p>
<p>俗话说得好，没有一种一劳永逸的工具，有效的管理Docker集群同样也是如此。缺乏场景来谈论Swarm的价值，意义并不会很大。相反，探索和挖掘Swarm的特点与功能，并为Docker集群的管理提供一种可选的方案，是Docker爱好者更应该参与的事。</p>
<p>本文初步介绍Swarm，并涉及架构与命令，下期将带来Swarm的具体使用，以及Swarm的架构剖析。</p>
<h1 id="5-作者介绍"><a class="header-anchor" href="#5-作者介绍"></a>5.作者介绍</h1>
<p>孙宏亮，<strong>DaoCloud</strong>初创团队成员，软件工程师，浙江大学VLIS实验室应届研究生。读研期间活跃在PaaS和Docker开源社区，对Cloud Foundry有深入研究和丰富实践，擅长底层平台代码分析，对分布式平台的架构有一定经验，撰写了大量有深度的技术博客。2014年末以合伙人身份加入DaoCloud团队，致力于传播以Docker为主的容器的技术，推动互联网应用的容器化步伐。邮箱：allen.sun@daocloud.io</p>
<h1 id="6-参考文献"><a class="header-anchor" href="#6-参考文献"></a>6.参考文献</h1>
<p>1.<a href="http://github.com/docker/swarm">http://github.com/docker/swarm</a><br>
2.<a href="http://technolo-g.com/intro-to-docker-swarm-pt1-overview/">http://technolo-g.com/intro-to-docker-swarm-pt1-overview/</a><br>
3.<a href="http://technolo-g.com/intro-to-docker-swarm-pt2-config-options-requirements/">http://technolo-g.com/intro-to-docker-swarm-pt2-config-options-requirements/</a></p>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat集群使用redis实现session共享</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/tomcat_redis_session_share.html</url>
    <content><![CDATA[<h1 id="准备"><a class="header-anchor" href="#准备"></a>准备</h1>
<p>本文对Redis做session共享的方案进行验证。使用一个Apache服务器与两个tomcat服务器搭建负载均衡。</p>
<h2 id="打包Tomcat-Redis-Session"><a class="header-anchor" href="#打包Tomcat-Redis-Session"></a>打包Tomcat-Redis-Session</h2>
<ol>
<li>
<p>下载源码 <a href="https://github.com/jcoleman/tomcat-redis-session-manager">https://github.com/jcoleman/tomcat-redis-session-manager</a></p>
</li>
<li>
<p>新建maven工程。</p>
</li>
<li>
<p>修改pom.xml文件。</p>
<p><strong>添加依赖</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>使用JDK1.7</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- compiler插件, 设定JDK版本 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">showWarnings</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">showWarnings</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>导入源码, 打包得到<code>tomcat-redis-session.jar</code></p>
<p>将上面下载下来的源码包中的src，拷贝到工程中的相应位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mvn clean package -Dmaven.test.skip=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="获取其它依赖包"><a class="header-anchor" href="#获取其它依赖包"></a>获取其它依赖包</h2>
<p>下载<code>jedis-2.7.3.jar</code> 和<code>commons-pool2-2.4.1.jar</code></p>
<h1 id="配置Tomcat"><a class="header-anchor" href="#配置Tomcat"></a>配置Tomcat</h1>
<p>准备n台tomcat。</p>
<h2 id="添加jar包"><a class="header-anchor" href="#添加jar包"></a>添加jar包</h2>
<p>将上面得到的<code>tomcat-redis-session.jar</code>， <code>jedis-2.7.3.jar</code>和<code>commons-pool2-2.4.1.jar</code>放入到tomcat目录下的<code>lib/</code>目录下。</p>
<h2 id="配置端口"><a class="header-anchor" href="#配置端口"></a>配置端口</h2>
<p>如果n台tomcat部署在同一台机器上，为避免端口占用，就要修改<code>conf/server.xml</code>中的端口：SHUTDOWN端口，HTTP端口，AJP端口。</p>
<p>这里的两台tomcat的端口如下：</p>
<ul>
<li>HTTP:  8081 – AJP: 8009</li>
<li>HTTP:  8080 – AJP: 8019</li>
</ul>
<h2 id="配置context-xml文件"><a class="header-anchor" href="#配置context-xml文件"></a>配置context.xml文件</h2>
<p>修改每台tomcat的<code>conf/context.xml</code>文件，在<code>Context</code>节点中按实际情况添加如下配置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot;</span> /&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span>  </span><br><span class="hljs-tag">     <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;app.coracle.com&quot;</span>   </span><br><span class="hljs-tag">     <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;6379&quot;</span>   </span><br><span class="hljs-tag">     <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;0&quot;</span>   </span><br><span class="hljs-tag">     <span class="hljs-attr">maxInactiveInterval</span>=<span class="hljs-string">&quot;60&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="配置Apache"><a class="header-anchor" href="#配置Apache"></a>配置Apache</h1>
<p>这里使用的Apache2.4.x。</p>
<h2 id="配置httpd-conf"><a class="header-anchor" href="#配置httpd-conf"></a>配置httpd.conf</h2>
<p>修改Apache目录下的<code>conf/httpd.conf</code>,</p>
<ol>
<li>
<p>打开proxy, banlancer相关的模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">LoadModule proxy_module modules/mod_proxy.so<br>LoadModule proxy_ajp_module modules/mod_proxy_ajp.so<br>LoadModule proxy_balancer_module modules/mod_proxy_balancer.so<br>LoadModule proxy_connect_module modules/mod_proxy_connect.so<br>LoadModule proxy_express_module modules/mod_proxy_express.so<br>LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so<br>LoadModule proxy_ftp_module modules/mod_proxy_ftp.so<br>LoadModule proxy_html_module modules/mod_proxy_html.so<br>LoadModule proxy_http_module modules/mod_proxy_http.so<br>LoadModule proxy_http2_module modules/mod_proxy_http2.so<br>LoadModule proxy_scgi_module modules/mod_proxy_scgi.so<br>LoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.so<br><br>LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so<br><br>LoadModule speling_module modules/mod_speling.so<br>LoadModule slotmem_shm_module modules/mod_slotmem_shm.so<br>LoadModule xml2enc_module modules/mod_xml2enc.so<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>配置VirtualHost</p>
<p>在<code>httpd.conf</code>文件中取消下行的注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Include conf/extra/httpd-vhosts.conf<br></code></pre></td></tr></table></figure>
<p>修改<code>conf/extra/httpd-vhosts.conf</code></p>
<p>根据实际情况添加下面的VirtualHost</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#虚拟机配置,负载均衡配置  注意空格</span><br>&lt;VirtualHost *:80&gt;<br>    DocumentRoot <span class="hljs-string">&quot;d:/Apache24/htdocs&quot;</span><br>    ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On<br>    ProxyPassReverse / balancer://cluster/<br>    ErrorLog <span class="hljs-string">&quot;logs/error-tung.log&quot;</span><br>    CustomLog <span class="hljs-string">&quot;logs/access-tung.log&quot;</span> common<br>&lt;/VirtualHost&gt; <br><br><span class="hljs-comment">#The ProxyRequests directive should usually be set off when using ProxyPass.</span><br>ProxyRequests Off<br>&lt;proxy balancer://cluster&gt;<br>    BalancerMember ajp://localhost:8009 loadfactor=1 smax=5 max=20 ttl=120 retry=300 <span class="hljs-built_in">timeout</span>=15<br>    BalancerMember ajp://localhost:8019 loadfactor=1 smax=5 max=20 ttl=120 retry=300 <span class="hljs-built_in">timeout</span>=15<br>    ProxySet lbmethod=byrequests<br>&lt;/proxy&gt;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>重启apache</p>
</li>
</ol>
<h1 id="导入项目"><a class="header-anchor" href="#导入项目"></a>导入项目</h1>
<p>为了验证sessionid是否相同，只需新建一个最简单的web工程，然后在某个jsp中输出如下内容即可。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> class=<span class="hljs-string">&quot;no-js&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;<br>    &lt;title&gt;xxx&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>This is <span class="hljs-number">8081</span> : &lt;br&gt;<br>&lt;%<br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> request.getSession();<br>    out.print(ss.getId());<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx配置浏览器缓存</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/Nginx%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html</url>
    <content><![CDATA[<p>通过expires指令，将指定后缀的请求设置缓存。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> localblog &#123;<br>  <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.108:4000</span>;<br>&#125;<br><br><br><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span>  <span class="hljs-number">192.168.0.108</span>;<br>  <span class="hljs-attribute">client_max_body_size</span>    <span class="hljs-number">1000M</span>;<br>  <span class="hljs-attribute">sendfile</span>     <span class="hljs-literal">on</span>;<br><br>  <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-comment">#root /opt/dist;</span><br>        <span class="hljs-attribute">proxy_pass</span>  http://localblog;<br>        <span class="hljs-attribute">index</span> index.html;<br><br>        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_filename</span> <span class="hljs-regexp">~* ^.*?\.(ico|jpg|jpeg|gif|png|woff|woff2|bmp|js|css)$)</span> &#123;<br>                <span class="hljs-attribute">expires</span> <span class="hljs-number">1d</span>;<br>        &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="可参考知识点"><a class="header-anchor" href="#可参考知识点"></a>可参考知识点</h2>
<ul>
<li>Last-Modified/If-Modified-Since</li>
<li>Etag/If-None-Match</li>
<li>Cache-Control： max-age和expires</li>
<li>Expires</li>
</ul>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache多域名多站点配置</title>
    <url>/%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5/apache_multi-hosts.html</url>
    <content><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1>
<p>有时候，我们需要多个站点来实现多个需求。一般情况我们都会在站点根目录（如apache/htdocs）下创建多个文件夹：</p>
<table>
<thead>
<tr>
<th>服务器目录</th>
<th>访问地址</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>apache/htdocs/a</td>
<td><a href="http://www.xxx.com/a/">www.xxx.com/a/</a>*</td>
<td>a</td>
</tr>
<tr>
<td>apache/htdocs/b</td>
<td><a href="http://www.xxx.com/b/">www.xxx.com/b/</a>*</td>
<td>b</td>
</tr>
<tr>
<td>apache/htdocs/c</td>
<td><a href="http://www.xxx.com/c/">www.xxx.com/c/</a>*</td>
<td>c</td>
</tr>
</tbody>
</table>
<p>然而这种做法的隔离效果不太好, 在我们只有一台服务器一个IP的情况下，理想的做法是这样的：</p>
<table>
<thead>
<tr>
<th>服务器目录</th>
<th>访问地址</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>apache/htdocs/a</td>
<td><a href="http://a.xxx.com/*">a.xxx.com/*</a></td>
<td>a</td>
</tr>
<tr>
<td>apache/htdocs/b</td>
<td><a href="http://b.xxx.com/*">b.xxx.com/*</a></td>
<td>b</td>
</tr>
<tr>
<td>apache/htdocs/c</td>
<td><a href="http://c.xxx.com/*">c.xxx.com/*</a></td>
<td>c</td>
</tr>
</tbody>
</table>
<h1 id="修改配置文件"><a class="header-anchor" href="#修改配置文件"></a>修改配置文件</h1>
<p>打开appache/conf/http.conf, 在最后面加上：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NameVirtualHost</span> *<br><span class="hljs-section">&lt;VirtualHost *<span class="hljs-number">:80</span>&gt;</span><br><span class="hljs-attribute">ServerAdmin</span> admin@xxx.com<br><span class="hljs-attribute">DocumentRoot</span> /usr/local/apache/htdocs/a<br><span class="hljs-attribute">ServerName</span> a.xxx.com<br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">NameVirtualHost</span> *<br><span class="hljs-section">&lt;VirtualHost *<span class="hljs-number">:80</span>&gt;</span><br><span class="hljs-attribute">ServerAdmin</span> admin@xxx.com<br><span class="hljs-attribute">DocumentRoot</span> /usr/local/apache/htdocs/b<br><span class="hljs-attribute">ServerName</span> b.xxx.com<br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">NameVirtualHost</span> *<br><span class="hljs-section">&lt;VirtualHost *<span class="hljs-number">:80</span>&gt;</span><br><span class="hljs-attribute">ServerAdmin</span> admin@xxx.com<br><span class="hljs-attribute">DocumentRoot</span> /usr/local/apache/htdocs/c<br><span class="hljs-attribute">ServerName</span> c.xxx.com<br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br></code></pre></td></tr></table></figure>
<p>保存重启appache即可。</p>
<h1 id="拓展"><a class="header-anchor" href="#拓展"></a>拓展</h1>
<p>在<a href="http://www.tung7.com/post-91.html">Apache与Tomcat的整合</a>中，已经用Apache连接了Tomcat，下面就为Java站点和PHP站点分配不同域名。</p>
<p>blog.tung7.com用于访问JAVA站点，而blog2.tung7.com用于访问PHP站点。</p>
<p>同样找到apache/conf/http.conf。在最后添加或修改(下面关于Log的配置自行修改)：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"># 设置虚拟主机<br># For Tomcat<br>NameVirtualHost blog.tung7.<span class="hljs-keyword">com</span>:<span class="hljs-number">80</span><br>&lt;VirtualHost blog.tung7.<span class="hljs-keyword">com</span>:<span class="hljs-number">80</span>&gt;<br>     #定义服务名称<br>     ServerName blog.tung7.<span class="hljs-keyword">com</span><br>     #定义站点项目所在路径。<br>     DocumentRoot <span class="hljs-comment">&quot;D:/Apache Software Foundation/Tomcat 7.0/webapps</span><br>     DirectoryIndex login.jsp <span class="hljs-built_in">index</span>.html <span class="hljs-built_in">index</span>.htm<br><br>     JkMount /* blog<br>     JkUnMount /*.html blog<br>     JkUnMount /*.htm blog<br><br> &lt;/VirtualHost&gt;<br> &lt;Directory <span class="hljs-string">&quot;D:/Apache Software Foundation/Tomcat 7.0/webapps&quot;</span>&gt;  <br>     Options Indexes FollowSymLinks  <br>     AllowOverride None  <br>     Order allow,deny  <br>     Allow from <span class="hljs-keyword">all</span>  <br> &lt;/Directory&gt; <br><br># For PHP<br>NameVirtualHost blog2.tung7.<span class="hljs-keyword">com</span>:<span class="hljs-number">80</span><br>&lt;VirtualHost blog2.tung7.<span class="hljs-keyword">com</span>:<span class="hljs-number">80</span>&gt;<br>     ServerAdmin zhuyuandong@vip.qq.<span class="hljs-keyword">com</span><br>     ServerName blog2.tung7.<span class="hljs-keyword">com</span><br>     DocumentRoot <span class="hljs-string">&quot;D:\AppServ\www&quot;</span><br><br>     DirectoryIndex <span class="hljs-built_in">index</span>.html <span class="hljs-built_in">index</span>.htm <span class="hljs-built_in">index</span>.php<br>     ErrorLog logs/blog2-error_log.txt<br>     CustomLog logs/blog2-access_log.txt common<br>&lt;/VirtualHost&gt;<br><br></code></pre></td></tr></table></figure>
<p>保存重启Apache,即可。</p>
<p><a href="http://xn--blog-pr9l020c.tung7.com">访问blog.tung7.com</a>:</p>
<p><img src="https://tximgcdn.tung7.com/apache_multi-hosts/apache_multi-hosts_20210706062821_321473.jpg" alt="Image"></p>
<p><a href="http://xn--blog2-6u8oj48c.tung7.com">访问blog2.tung7.com</a>:</p>
<p><img src="https://tximgcdn.tung7.com/apache_multi-hosts/apache_multi-hosts_20210706062826_646753.jpg" alt="Image"></p>
<p>然而这里还有一个问题，就是我们如果直接使用IP访问结果会怎么样？</p>
<p>实际上，Apache有一个默认的VirtualHost用于IP访问，当httpconf中NameVirtualHost的时候，第一个声明的VirtualHost将用于IP访问。所以，现在如果直接使用IP访问的话，将会访问到JAVA站点。BUT, 我们一般都是禁止使用IP直接访问的，下面来实现禁止IP直接访问。</p>
<h1 id="禁止IP直接访问"><a class="header-anchor" href="#禁止IP直接访问"></a>禁止IP直接访问</h1>
<h2 id="第一种方法"><a class="header-anchor" href="#第一种方法"></a>第一种方法</h2>
<p>同样在http.conf中添加一个VirtualHost</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Forbidden IP</span><br><span class="hljs-attribute">NameVirtualHost</span> <span class="hljs-number">121.121.121.121:80</span><br><span class="hljs-section">&lt;VirtualHost <span class="hljs-number">121.121.121.121:80</span>&gt;</span><br>  <span class="hljs-comment">#必需指定这个ip地址</span><br>     <span class="hljs-attribute">ServerName</span> <span class="hljs-number">121.121.121.121</span><br>     <span class="hljs-section">&lt;Location /&gt;</span><br>     <span class="hljs-attribute">Order</span> <span class="hljs-literal">allow</span>,<span class="hljs-literal">deny</span>  <br>     <span class="hljs-attribute">Deny</span> from <span class="hljs-literal">all</span>  <br>     <span class="hljs-section">&lt;/Location&gt;</span><br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>访问将返回403错误。</p>
<p><img src="https://tximgcdn.tung7.com/apache_multi-hosts/apache_multi-hosts_20210706062832_893141.jpg" alt="Image"></p>
<p>当然，我们可以很闷骚地自己设计错误页面。在&lt;VirtualHost *:80&gt;和</VirtualHost>加入以下代码:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ErrorDocument</span> <span class="hljs-number">500</span> /<span class="hljs-number">500</span>.html<br><span class="hljs-attribute">ErrorDocument</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html<br><span class="hljs-attribute">ErrorDocument</span> <span class="hljs-number">403</span> /<span class="hljs-number">403</span>.html<br><br></code></pre></td></tr></table></figure>
<h2 id="第二种方法"><a class="header-anchor" href="#第二种方法"></a>第二种方法</h2>
<p>第一种方法只是返回403，并没有确切告诉访问者禁止IP访问。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Forbidden IP</span><br><span class="hljs-attribute">NameVirtualHost</span> <span class="hljs-number">121.121.121.121:80</span><br><span class="hljs-section">&lt;VirtualHost <span class="hljs-number">121.121.121.121:80</span>&gt;</span><br>     <span class="hljs-attribute">ServerName</span> <span class="hljs-number">121.121.121.121</span><br>     <span class="hljs-attribute">DocumentRoot</span> <span class="hljs-string">&quot;c:\AppServ\www\nosite&quot;</span><br>     <span class="hljs-attribute">DirectoryIndex</span> index.html<br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>相当于为该IP新建一个站点nosite，然后在里面新建一个设计好的index.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Forbidden View By IP<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Your Nice Design<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>然后直接访问IP就会访问到nosite站点下的index.html了。</p>
]]></content>
      <categories>
        <category>实践出真知</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-Spring-SpringDataJPA环境搭建</title>
    <url>/%E8%8C%B6%E8%AF%9D%E9%97%B2%E8%B0%88/springmvc_spring_spring-data-jpa_env.html</url>
    <content><![CDATA[<h1 id="简述"><a class="header-anchor" href="#简述"></a>简述</h1>
<p>本次环境使用Maven3在Intelij IDEA上搭建，SpringDataJPA的实现商是Hibernate, 数据库Mysql, 连接池Druid。下面只是提供POM文件和相关配置文件的内容，类似于代码段的风格，并不会对IDEA的相关操作进行讲解。</p>
<p>本例只是搭建最基本的运行条件，如文件上传，视图整合等等其它功能需要另行导包配置。</p>
<h1 id="POM-xml"><a class="header-anchor" href="#POM-xml"></a>POM.xml</h1>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tung7.ex<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>这应该是springmvc-spring-springdatajpa最简单整合<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>4.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hibernate.version</span>&gt;</span>4.3.5.Final<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-data-jpa.version</span>&gt;</span>1.7.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-data-jpa.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aspectj.version</span>&gt;</span>1.8.3<span class="hljs-tag">&lt;/<span class="hljs-name">aspectj.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jackson.version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">jackson.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tiles.version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">tiles.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.web<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp.jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Junit --&gt;</span>               <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- spring4.2.5 --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--springmvc --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- spring data jpa  === hibernate --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-data-jpa.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--  druid --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- mysql驱动包 --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- slf4-log4j --&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- JackSon 用于@ResponseBody--&gt;</span>              <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">failOnMissingWebXml</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<h1 id="WEB-xml"><a class="header-anchor" href="#WEB-xml"></a>WEB.xml</h1>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span>         </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         </span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>ex_spring_data_jpa<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/WEB-INF/404.html<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>log4jConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:log4j.properties<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Spring MVC Servlet --&gt;</span>        <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>  <br></code></pre></td></tr></table></figure>
<h1 id="SpringMVC的配置文件spring-mvc-xml"><a class="header-anchor" href="#SpringMVC的配置文件spring-mvc-xml"></a>SpringMVC的配置文件spring-mvc.xml</h1>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>       </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span>       </span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc       </span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd       </span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/beans       </span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd       </span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/context       </span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 自动扫描且只扫描@Controller 防止和applicationContext.xml重复--&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.tung7&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 定义InternalResourceViewResolver --&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contentType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--============= 处理静态文件 ==================--&gt;</span>    <br>    <span class="hljs-comment">&lt;!-- 容器默认的DefaultServletHandler处理 所有静态内容与无RequestMapping处理的URL--&gt;</span>    <br>    <span class="hljs-comment">&lt;!--&lt;mvc:default-servlet-handler /&gt;--&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/content/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/content/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/include/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/include/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/WEB-INF/*.html&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="Spring公共配置applicationContext-xml"><a class="header-anchor" href="#Spring公共配置applicationContext-xml"></a>Spring公共配置applicationContext.xml</h1>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:jpa</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:task</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/task&quot;</span> <span class="hljs-attr">xmlns:cache</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/cache&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span> <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd     http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd   http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">default-lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Spring公共配置<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 使用annotation 自动注册bean, 并保证@Required、@Autowired的属性被注入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.tung7&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag">                                <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Jpa Entity Manager 配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;hibernateJpaVendorAdapter&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;packagesToScan&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.tung7.*.entity&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;persistenceProviderClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaProperties&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hibernateJpaVendorAdapter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;showSql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generateDdl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Jpa 事务配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Spring Data Jpa配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jpa:repositories</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.tung7.*.dao&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">transaction-manager-ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">entity-manager-factory-ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>  /&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 使用annotation定义事务 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- local development环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">ignore-resource-not-found</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:application.properties&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 基本属性 url、user、password --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWait&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;60000&quot;</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;60000&quot;</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300000&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;validationQuery&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SELECT &#x27;x&#x27;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testWhileIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testOnBorrow&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testOnReturn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPreparedStatements&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置监控统计拦截的filters --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;stat&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="log4j-properties"><a class="header-anchor" href="#log4j-properties"></a>log4j.properties</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#log4j.rootLogger=warn,appender1</span><br><span class="hljs-comment">#log4j.rootLogger=info,appender1</span><br>log4j.rootLogger=error,appender1<br><br><span class="hljs-comment">#print to console</span><br>log4j.appender.appender1=org.apache.log4j.ConsoleAppender<br><span class="hljs-comment">#style TTCCLayout</span><br>log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout<br><br></code></pre></td></tr></table></figure>
<h1 id="实例"><a class="header-anchor" href="#实例"></a>实例</h1>
<h2 id="Entity"><a class="header-anchor" href="#Entity"></a>Entity</h2>
<p>两个实体一个是Article, 一个是Sort。Article对Sort是多对一的关系。</p>
<p>Article实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;tung7_article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer gid;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Date date;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> String excerpt;<br>    <span class="hljs-keyword">private</span> String alias;<br>    <span class="hljs-keyword">private</span> Sort sort;<br>    <span class="hljs-keyword">private</span> Integer views;<br>    <span class="hljs-keyword">private</span> Integer comnum;<br>    <span class="hljs-keyword">private</span> Boolean istop;<br>    <span class="hljs-keyword">private</span> Boolean sorttop;<br>    <span class="hljs-keyword">private</span> Boolean ispost;<br>    <span class="hljs-keyword">private</span> Boolean allowremark;<br><br>    <span class="hljs-keyword">private</span> Boolean ispage;<br>    <span class="hljs-keyword">private</span> String template;<br><br>    <span class="hljs-comment">//Setter Getter       @Id</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getGid</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gid;<br>    &#125;<br><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br><br>    <span class="hljs-meta">@ManyToOne</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;sortid&quot;, nullable = true)</span><br>    <span class="hljs-keyword">public</span> Sort <span class="hljs-title function_">getSort</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Sort实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;tung7_sort&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String sortname;<br>    <span class="hljs-keyword">private</span> String alias; <span class="hljs-comment">// Link alias</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-keyword">private</span> String template;<br><br>    <span class="hljs-keyword">private</span> Set&lt;Article&gt; articles;<br><br>    <span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY)</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;sortid&quot;)</span><br>    <span class="hljs-keyword">public</span> Set&lt;Article&gt; <span class="hljs-title function_">getArticles</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> articles;<br>    &#125;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="DAO"><a class="header-anchor" href="#DAO"></a>DAO</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArticleDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PagingAndSortingRepository</span>&lt;Article, Integer&gt; &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Service"><a class="header-anchor" href="#Service"></a>Service</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>        <br>    <span class="hljs-keyword">private</span> ArticleDao articleDao;<br><br>    <span class="hljs-keyword">public</span> PageBean&lt;Article&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(PageBean&lt;Article&gt; pageBean)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curPage</span> <span class="hljs-operator">=</span> pageBean.getCurPage();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">linesize</span> <span class="hljs-operator">=</span> pageBean.getLineSize();<br>        Page&lt;Article&gt; page = articleDao.findAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageRequest</span>(curPage - <span class="hljs-number">1</span>, linesize));<br>        pageBean.setItemSum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(page.getTotalElements()).intValue());<br>        pageBean.setList(page.getContent());<br><br>        <span class="hljs-keyword">return</span> pageBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Controller"><a class="header-anchor" href="#Controller"></a>Controller</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ArticleService articleService;<br><br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(ModelMap mv, <span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="hljs-type">int</span> page)</span> &#123;<br>        PageBean&lt;Article&gt; pageBean = articleService.list(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>&lt;Article&gt;(page, <span class="hljs-number">5</span>));<br>        mv.addAttribute(<span class="hljs-string">&quot;pageBean&quot;</span>, pageBean);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;article&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="JSP"><a class="header-anchor" href="#JSP"></a>JSP</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">article list pageBean:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>pageBean.curPage: $&#123;pageBean.curPage&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>pageBean.itemSum: $&#123;pageBean.itemSum&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>pageBean.pageSum: $&#123;pageBean.pageSum&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>pageBean.lineSize: $&#123;pageBean.lineSize&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;pageBean.list&#125;&quot;</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    ==================================<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    $&#123;item.gid&#125; : <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    ---------------------------------------<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    $&#123;item.sort.sortname&#125; : $&#123;item.title&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    ---------------------------------------<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    $&#123;item.date&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    ==================================<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>茶话闲谈</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Spring</tag>
        <tag>Spring_Data_JPA</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
</search>
